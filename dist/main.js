(()=>{"use strict";var e="undefined"!=typeof Float32Array?Float32Array:Array;function t(){var t=new e(3);return e!=Float32Array&&(t[0]=0,t[1]=0,t[2]=0),t}function n(e,t,n){return e[0]=t[0]+n[0],e[1]=t[1]+n[1],e[2]=t[2]+n[2],e}function i(e,t,n){return e[0]=t[0]*n,e[1]=t[1]*n,e[2]=t[2]*n,e}function r(e,t){var n=t[0],i=t[1],r=t[2],o=n*n+i*i+r*r;return o>0&&(o=1/Math.sqrt(o)),e[0]=t[0]*o,e[1]=t[1]*o,e[2]=t[2]*o,e}function o(e,t,n){var i=t[0],r=t[1],o=t[2],a=n[0],c=n[1],s=n[2];return e[0]=r*s-o*c,e[1]=o*a-i*s,e[2]=i*c-r*a,e}Math.random,Math.PI,Math.hypot||(Math.hypot=function(){for(var e=0,t=arguments.length;t--;)e+=arguments[t]*arguments[t];return Math.sqrt(e)});var a=function(e,t){var n=t[0]-e[0],i=t[1]-e[1],r=t[2]-e[2];return Math.hypot(n,i,r)};function c(e){return e*Math.PI/180}t();class s{constructor(e,n){var i,o,a;this.origin=e,this.direction=r(t(),n),this.inv_direction=[1,1,1],i=this.inv_direction,o=this.inv_direction,a=n,i[0]=o[0]/a[0],i[1]=o[1]/a[1],i[2]=o[2]/a[2]}}class l{constructor(e,t,n,i){this.position=e,this.voxel_position=t,this.voxel=n,this.normal=i}}class v{constructor(){this.color=t(),this.opacity=0,this.roughness=1,this.lightness=0}}const _="@group(0) @binding(0) var screen_sampler : sampler;\r\n@group(0) @binding(1) var color_buffer : texture_2d<f32>;\r\n\r\nstruct VertexOutput {\r\n        @builtin(position) Position : vec4<f32>,\r\n            @location(0) TexCoord : vec2<f32>,\r\n}\r\n\r\n@vertex\r\nfn vert_main(@builtin(vertex_index) VertexIndex : u32) -> VertexOutput {\r\n    var positions = array<vec2<f32>, 6>(\r\n        vec2<f32>( 1.0,  1.0),\r\n        vec2<f32>( 1.0, -1.0),\r\n        vec2<f32>(-1.0, -1.0),\r\n        vec2<f32>( 1.0,  1.0),\r\n        vec2<f32>(-1.0, -1.0),\r\n        vec2<f32>(-1.0,  1.0)\r\n    );\r\n\r\n    var texCoords = array<vec2<f32>, 6>(\r\n        vec2<f32>(1.0, 0.0),\r\n        vec2<f32>(1.0, 1.0),\r\n        vec2<f32>(0.0, 1.0),\r\n        vec2<f32>(1.0, 0.0),\r\n        vec2<f32>(0.0, 1.0),\r\n        vec2<f32>(0.0, 0.0)\r\n    );\r\n\r\n    var output : VertexOutput;\r\n    output.Position = vec4<f32>(positions[VertexIndex], 0.0, 1.0);\r\n    output.TexCoord = texCoords[VertexIndex];\r\n    return output;\r\n}\r\n\r\n@fragment\r\nfn frag_main(@location(0) TexCoord : vec2<f32>) -> @location(0) vec4<f32> {\r\n    return textureSample(color_buffer, screen_sampler, TexCoord);\r\n}";var u=function(e,t,n,i){return new(n||(n=Promise))((function(r,o){function a(e){try{s(i.next(e))}catch(e){o(e)}}function c(e){try{s(i.throw(e))}catch(e){o(e)}}function s(e){var t;e.done?r(e.value):(t=e.value,t instanceof n?t:new n((function(e){e(t)}))).then(a,c)}s((i=i.apply(e,t||[])).next())}))};const h=document.getElementById("canv"),d=document.getElementById("fps");let x=new class{constructor(n,i,r){var o;this.forward=t(),this.right=t(),this.up=t(),this.position=n,this.eulers=[0,r,i],this.view=(o=new e(16),e!=Float32Array&&(o[1]=0,o[2]=0,o[3]=0,o[4]=0,o[6]=0,o[7]=0,o[8]=0,o[9]=0,o[11]=0,o[12]=0,o[13]=0,o[14]=0),o[0]=1,o[5]=1,o[10]=1,o[15]=1,o),this.update(),this.inputs=[!1,!1,!1,!1,!1,!1],this.speed=4}tick(e){let o=t();this.inputs[0]&&n(o,o,this.forward),this.inputs[1]&&n(o,o,this.right),this.inputs[2]&&n(o,o,i(t(),this.forward,-1)),this.inputs[3]&&n(o,o,i(t(),this.right,-1)),this.inputs[4]&&n(o,o,this.up),this.inputs[5]&&n(o,o,i(t(),this.up,-1)),r(o,o),n(this.position,this.position,i(t(),o,this.speed*e))}update(){this.forward=[Math.cos(c(this.eulers[2]))*Math.cos(c(this.eulers[1])),Math.sin(c(this.eulers[2]))*Math.cos(c(this.eulers[1])),Math.sin(c(this.eulers[1]))],r(this.right,o(this.right,this.forward,[0,0,1])),r(this.up,o(this.up,this.right,this.forward)),n(t(),this.position,this.forward)}mouse_move(e,t){e.eulers[1]=Math.min(90,Math.max(-90,e.eulers[1]-t.movementY)),e.eulers[2]=(e.eulers[2]-t.movementX)%360,e.update()}keyboard_down(e,t){"e"==t.key&&(e.inputs[0]=!0),"d"==t.key&&(e.inputs[2]=!0),"f"==t.key&&(e.inputs[1]=!0),"s"==t.key&&(e.inputs[3]=!0),"r"==t.key&&(e.inputs[4]=!0),"w"==t.key&&(e.inputs[5]=!0)}keyboard_up(e,t){"e"==t.key&&(e.inputs[0]=!1),"d"==t.key&&(e.inputs[2]=!1),"f"==t.key&&(e.inputs[1]=!1),"s"==t.key&&(e.inputs[3]=!1),"r"==t.key&&(e.inputs[4]=!1),"w"==t.key&&(e.inputs[5]=!1)}screen_to_ray(e,r,o,a){const c=(e-o/2)/o,l=(r-a/2)/-a;let v=t();return n(v,v,this.forward),n(v,v,i(t(),this.right,c)),n(v,v,i(t(),this.up,l)),new s(this.position,v)}}([0,0,0],0,0);const f=new class{constructor(e){this.grid_size=8,this.voxel_count=16,this.camera=e,this.grid=new Array(this.grid_size*this.grid_size*this.grid_size),this.boundary_min=[-this.grid_size/2,-this.grid_size/2,-this.grid_size/2],this.boundary_max=[this.grid_size/2,this.grid_size/2,this.grid_size/2],this.voxel_size=this.grid_size/this.voxel_count,this.initialize_grid(),this.direct_light=r(t(),[1.5,.6,1]),this.direct_light_brightness=1}initialize_grid(){this.grid=new Array(this.voxel_count**3);for(let e=0;e<this.voxel_count;e++)for(let t=0;t<this.voxel_count;t++)for(let n=0;n<this.voxel_count;n++){let i=new v;i.color=[0,0,0],i.opacity=0,this.grid[n*this.voxel_count*this.voxel_count+t*this.voxel_count+e]=i}}initialize_default_grid(){for(let e=0;e<this.voxel_count;e++)for(let t=0;t<this.voxel_count;t++)for(let n=0;n<this.voxel_count;n++){let i=new v;n<1&&(i.opacity=1,i.color=[e/4,t/4,.9],i.lightness=0,i.roughness=1),n>14&&(i.opacity=1,i.color=[.2,t/4,.7],i.roughness=.2,i.lightness=0),a([e,t,n],[this.voxel_count/2,this.voxel_count/2,this.voxel_count/2])>8&&(i.opacity=1,i.color=[e/4,t/4,n/4],i.lightness=0,i.roughness=1),i.color=[.8,.8,.8],this.set_voxel_comp(i,e,t,n)}}ray_any(e){let r=0,o=1/0;for(let t=0;t<3;t++){let n=(this.boundary_min[t]-e.origin[t])*e.inv_direction[t],i=(this.boundary_max[t]-e.origin[t])*e.inv_direction[t];r=Math.min(Math.max(n,r),Math.max(i,r)),o=Math.max(Math.min(n,o),Math.min(i,o))}if(r>o)return;const a=n(t(),e.origin,i(t(),e.direction,r)),c=n(t(),e.origin,i(t(),e.direction,o));let s=[Math.max(0,Math.min(this.voxel_count-1,Math.floor((a[0]-this.boundary_min[0])/this.voxel_size))),Math.max(0,Math.min(this.voxel_count-1,Math.floor((a[1]-this.boundary_min[1])/this.voxel_size))),Math.max(0,Math.min(this.voxel_count-1,Math.floor((a[2]-this.boundary_min[2])/this.voxel_size)))],v=[s[0]+1,s[1]+1,s[2]+1],_=[0,0,0],u=[0,0,0],h=[0,0,0],d=[0,0,0],x=r,f=[0,0,0];for(let t=0;t<3;t++)d[t]=Math.max(0,Math.min(this.voxel_count-1,Math.floor((c[t]-this.boundary_min[t])/this.voxel_size))),e.direction[t]>0?(_[t]=1,h[t]=this.voxel_size/e.direction[t],u[t]=r+(this.boundary_min[t]+v[t]*this.voxel_size-a[t])/e.direction[t]):e.direction[t]<0?(_[t]=-1,h[t]=this.voxel_size/-e.direction[t],u[t]=r+(this.boundary_min[t]+s[t]*this.voxel_size-a[t])/e.direction[t]):(_[t]=0,h[t]=o,u[t]=o);for(;s[0]<this.voxel_count&&s[0]>=0&&s[1]<this.voxel_count&&s[1]>=0&&s[2]<this.voxel_count&&s[2]>=0;){if(this.get_voxel(s).opacity>.01){const r=n(t(),e.origin,i(t(),e.direction,x));return new l(r,s,this.get_voxel(s),f)}u[0]<u[1]&&u[0]<u[2]?(s[0]+=_[0],x=u[0],u[0]+=h[0],f=[-_[0],0,0]):u[1]<u[2]?(s[1]+=_[1],x=u[1],u[1]+=h[1],f=[0,-_[1],0]):(s[2]+=_[2],x=u[2],u[2]+=h[2],f=[0,0,-_[2]])}}get_voxel_id_comp(e,t,n){return n*this.voxel_count*this.voxel_count+t*this.voxel_count+e}get_voxel_id(e){return e[2]*this.voxel_count*this.voxel_count+e[1]*this.voxel_count+e[0]}get_voxel_comp(e,t,n){return this.grid[n*this.voxel_count*this.voxel_count+t*this.voxel_count+e]}get_voxel(e){return this.grid[e[2]*this.voxel_count*this.voxel_count+e[1]*this.voxel_count+e[0]]}set_voxel(e,t){t[0]>0&&t[0]<this.voxel_count-1&&t[1]>0&&t[1]<this.voxel_count-1&&t[2]>0&&t[2]<this.voxel_count-1&&(this.grid[t[2]*this.voxel_count*this.voxel_count+t[1]*this.voxel_count+t[0]]=e)}set_voxel_comp(e,t,n,i){t>0&&t<this.voxel_count-1&&n>0&&n<this.voxel_count-1&&i>0&&i<this.voxel_count-1&&(this.grid[i*this.voxel_count*this.voxel_count+n*this.voxel_count+t]=e)}}(x),m=new class{constructor(e,t){this.render=()=>{var e,t,n,i,r;null===(e=this.device)||void 0===e||e.queue.writeBuffer(this.sceneParameters,0,new Float32Array([this.scene.camera.position[0],this.scene.camera.position[1],this.scene.camera.position[2],(new Date).getMilliseconds(),this.scene.camera.forward[0],this.scene.camera.forward[1],this.scene.camera.forward[2],0,this.scene.camera.right[0],this.scene.camera.right[1],this.scene.camera.right[2],0,this.scene.camera.up[0],this.scene.camera.up[1],this.scene.camera.up[2],0,this.scene.direct_light[0],this.scene.direct_light[1],this.scene.direct_light[2],this.scene.direct_light_brightness]),0,20);const o=new Float32Array(8*this.scene.grid.length);for(let e=0;e<this.scene.grid.length;++e)o[8*e]=this.scene.grid[e].color[0],o[8*e+1]=this.scene.grid[e].color[1],o[8*e+2]=this.scene.grid[e].color[2],o[8*e+3]=this.scene.grid[e].opacity,o[8*e+4]=this.scene.grid[e].roughness,o[8*e+5]=this.scene.grid[e].lightness,o[8*e+6]=0,o[8*e+7]=0;null===(t=this.device)||void 0===t||t.queue.writeBuffer(this.sceneData,0,o,0,8*this.scene.grid.length);const a=null===(n=this.device)||void 0===n?void 0:n.createCommandEncoder(),c=null==a?void 0:a.beginComputePass();null==c||c.setPipeline(this.ray_tracing_pipeline),null==c||c.setBindGroup(0,this.ray_tracing_bind_group),null==c||c.dispatchWorkgroups(this.canvas.width/16,this.canvas.height/16,1),null==c||c.end();const s=null===(i=this.context)||void 0===i?void 0:i.getCurrentTexture().createView(),l=null==a?void 0:a.beginRenderPass({colorAttachments:[{view:s,clearValue:{r:.5,g:0,b:.25,a:1},loadOp:"clear",storeOp:"store"}]});null==l||l.setPipeline(this.screen_pipeline),null==l||l.setBindGroup(0,this.screen_bind_group),null==l||l.draw(6,1,0,0),null==l||l.end(),null===(r=this.device)||void 0===r||r.queue.submit([null==a?void 0:a.finish()])},this.canvas=e,this.scene=t}initialize(){return u(this,void 0,void 0,(function*(){yield this.setupDevice(),yield this.createAssets(),yield this.setupPipeline()}))}setupDevice(){var e,t;return u(this,void 0,void 0,(function*(){this.adapter=yield null===(e=navigator.gpu)||void 0===e?void 0:e.requestAdapter(),this.device=yield null===(t=this.adapter)||void 0===t?void 0:t.requestDevice(),this.context=this.canvas.getContext("webgpu"),this.format="bgra8unorm",this.context.configure({device:this.device,format:this.format,alphaMode:"opaque"})}))}createAssets(){var e,t,n,i,r;return u(this,void 0,void 0,(function*(){this.color_buffer=null===(e=this.device)||void 0===e?void 0:e.createTexture({size:{width:this.canvas.width,height:this.canvas.height},format:"rgba8unorm",usage:GPUTextureUsage.COPY_DST|GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.TEXTURE_BINDING}),this.color_buffer_view=null===(t=this.color_buffer)||void 0===t?void 0:t.createView(),this.sampler=null===(n=this.device)||void 0===n?void 0:n.createSampler({addressModeU:"repeat",addressModeV:"repeat",magFilter:"linear",minFilter:"nearest",mipmapFilter:"nearest",maxAnisotropy:1}),this.sceneParameters=null===(i=this.device)||void 0===i?void 0:i.createBuffer({size:80,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST});const o=this.scene.voxel_count*this.scene.voxel_count*this.scene.voxel_count;this.sceneData=null===(r=this.device)||void 0===r?void 0:r.createBuffer({size:8*o*4,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST})}))}setupPipeline(){var e,t,n,i,r,o,a,c;return u(this,void 0,void 0,(function*(){const s=null===(e=this.device)||void 0===e?void 0:e.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,storageTexture:{access:"write-only",format:"rgba8unorm",viewDimension:"2d"}},{binding:1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},{binding:2,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}}]});this.ray_tracing_bind_group=null===(t=this.device)||void 0===t?void 0:t.createBindGroup({layout:s,label:"Ray tracing bind group",entries:[{binding:0,resource:this.color_buffer_view},{binding:1,resource:{buffer:this.sceneParameters}},{binding:2,resource:{buffer:this.sceneData}}]});const l=null===(n=this.device)||void 0===n?void 0:n.createPipelineLayout({bindGroupLayouts:[s]});this.ray_tracing_pipeline=null===(i=this.device)||void 0===i?void 0:i.createComputePipeline({label:"Ray tracing pipeline",layout:l,compute:{entryPoint:"main",module:this.device.createShaderModule({code:"@group(0) @binding(0) var color_buffer: texture_storage_2d<rgba8unorm, write>;\r\n@group(0) @binding(1) var<uniform> scene: SceneParameter;\r\n@group(0) @binding(2) var<storage, read> scene_data: SceneData;\r\n\r\noverride grid_size: f32 = 2f;\r\noverride voxel_count: i32 = 4;\r\nvar<private> voxel_size: f32 = grid_size / f32(voxel_count);\r\nvar<private> boundary_min: vec3<f32> = vec3<f32>(f32(-grid_size) / 2, f32(-grid_size) / 2, f32(-grid_size) / 2);\r\nvar<private> boundary_max: vec3<f32> = vec3<f32>(f32(grid_size) / 2, f32(grid_size) / 2, f32(grid_size) / 2);\r\nvar<private> depth_clip_min: f32 = 1f;\r\nvar<private> depth_clip_max: f32 = 10f;\r\n\r\nvar<private> rng_seed: u32;\r\n\r\nconst samples: i32 = 100;\r\nconst light_bounces: i32 = 3;\r\nconst reflection_bounces: i32 = 1;\r\nconst scatter: i32 = 5;\r\nconst ambient_light: f32 = 0.03;\r\nconst ao: f32 = 0.2;\r\n\r\nstruct SceneParameter {\r\n    camera_pos: vec3<f32>,\r\n    rng_start: f32,\r\n    camera_forward: vec3<f32>,\r\n    camera_right: vec3<f32>,\r\n    camera_up: vec3<f32>,\r\n    direct_light: vec3<f32>,\r\n    direct_light_brightness: f32,\r\n}\r\n\r\nstruct Voxel {\r\n\tcolor: vec3<f32>,\r\n\topacity: f32,\r\n\troughness: f32,\r\n\tlightness: f32,\r\n}\r\n\r\nstruct SceneData {\r\n\tdata: array<Voxel>,\r\n}\r\n\r\nstruct Ray {\r\n    origin: vec3<f32>,\r\n    direction: vec3<f32>,\r\n    inv_direction: vec3<f32>,\r\n}\r\n\r\nstruct RayHit {\r\n\tposition: vec3<f32>,\r\n\tdepth: f32,\r\n\tvoxel_position: vec3<i32>,\r\n\tvoxel: Voxel,\r\n\tnormal: vec3<f32>,\r\n}\r\n\r\n@compute @workgroup_size(16,16,1)\r\nfn main(@builtin(global_invocation_id) GlobalInvocationID : vec3<u32>) {\r\n    let screen_size: vec2<u32> = textureDimensions(color_buffer);\r\n    let screen_pos : vec2<i32> = vec2<i32>(i32(GlobalInvocationID.x), i32(GlobalInvocationID.y));\r\n    //rng_seed = GlobalInvocationID.x + GlobalInvocationID.y * GlobalInvocationID.x * u32(scene.rng_start);\r\n    rng_seed = GlobalInvocationID.x + 50 + (GlobalInvocationID.y + 50) * (GlobalInvocationID.x + 100) * 1000 * u32(scene.rng_start);\r\n    //rng_seed = GlobalInvocationID.x + GlobalInvocationID.y * u32(scene.rng_start);\r\n\r\n    var pixel_color: vec3<f32>;\r\n    for (var i = 0; i < samples; i++){\r\n\r\n\t    let horizontal_coefficient: f32 = (f32(screen_pos.x) + rng() - 0.5 - f32(screen_size.x) / 2) / f32(screen_size.x);\r\n\t    let vertical_coefficient: f32 = (f32(screen_pos.y) + rng() - 0.5 - f32(screen_size.y) / 2) / -f32(screen_size.y);\r\n\r\n\t    let ray_direction = normalize(scene.camera_forward\r\n\t\t\t    + horizontal_coefficient * scene.camera_right\r\n\t\t\t    + vertical_coefficient * scene.camera_up);\r\n\t    let ray: Ray = Ray(scene.camera_pos, ray_direction, 1 / ray_direction);\r\n\t    pixel_color += trace(ray, light_bounces);\r\n    }\r\n\r\n    let correction = 1.0 / f32(samples);\r\n    pixel_color = sqrt(correction * pixel_color);\r\n\r\n    textureStore(color_buffer, screen_pos, vec4<f32>(pixel_color, 1.0));\r\n}\r\n\r\nfn rng_hash(seed: u32) -> u32 {\r\n\tvar x = ( seed << 10u );\r\n\tx ^= ( x >>  6u );\r\n\tx += ( x <<  3u );\r\n\tx ^= ( x >> 11u );\r\n\tx += ( x << 15u );\r\n\treturn x;\r\n}\r\n\r\nfn rng() -> f32 {\r\n\trng_seed++;\r\n\treturn bitcast<f32>((rng_hash(rng_seed) >> 9) | 0x3f800000 ) - 1.0;\r\n}\r\n\r\nfn ray_reflect(ray: Ray, position: vec3<f32>, normal: vec3<f32>) -> Ray {\r\n\tlet reflect = ray.direction - 2 * dot(ray.direction, normal) * normal;\r\n\treturn Ray(position, reflect, 1 / reflect);\r\n}\r\n\r\nfn get_voxel_id(v: vec3<i32>) -> i32 {\r\n\treturn v.z * voxel_count * voxel_count + v.y * voxel_count + v.x;\r\n}\r\n\r\nfn get_voxel(v: vec3<i32>) -> Voxel {\r\n\treturn scene_data.data[v.z * voxel_count * voxel_count + v.y * voxel_count + v.x];\r\n}\r\n\r\nfn random_unit_vector() -> vec3<f32> {\r\n\tvar v = vec3<f32>(rng() * 2 - 1, rng() * 2 - 1, rng() * 2 - 1);\r\n\twhile (v.x * v.x + v.y * v.y + v.z * v.z > 1.0){\r\n\t\tv = vec3<f32>(rng() * 2 - 1, rng() * 2 - 1, rng() * 2 - 1);\r\n\t}\r\n\treturn normalize(v);\r\n}\r\nfn gamma_correct(color: vec3<f32>) -> vec3<f32> {\r\n    return color / f32(samples);\r\n}\r\n\r\nfn trace(ray: Ray, depth: i32) -> vec3<f32> {\r\n\tvar hit: RayHit;\r\n\tvar bounces: array<RayHit, reflection_bounces>;\r\n\tvar curr_ray = ray;\r\n\t//var color = vec3<f32>(0.2);\r\n\tvar color = ray.direction;\r\n\r\n\tfor (var i = 0; i < reflection_bounces; i++){\r\n\t\tif(voxel_ray_any(curr_ray, 0.001, &hit)){\r\n\t\t\t//return vec3<f32>(get_hit_ao(hit));\r\n\t\t\tbounces[i] = hit;\r\n\t\t\tcurr_ray = ray_reflect(curr_ray, hit.position, hit.normal);\r\n\t\t}\r\n\t}\r\n\r\n\tfor (var i: i32 = reflection_bounces; i >= 0; i--){\r\n\t\tif (all(bounces[i].normal == vec3<f32>(0))){\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\tlet t = bounces[i].voxel.roughness;\r\n\t\t//color = bounces[i].voxel.color * illumination(bounces[i].position);\r\n\t\tcolor = color * (1 - t) + t * bounces[i].voxel.color * illumination(bounces[i].position) * (1 - get_hit_ao(bounces[i]));\r\n\t}\r\n\r\n\treturn color;\r\n}\r\n\r\nfn illumination(p: vec3<f32>) -> f32 {\r\n\tvar hit: RayHit;\r\n\tif (!voxel_ray_any(Ray(p, scene.direct_light, 1 / scene.direct_light), 0.001, &hit)){\r\n\t\treturn scene.direct_light_brightness;\r\n\t}\r\n\treturn 0.2;\r\n}\r\n\r\nfn voxel_ray_any(ray: Ray, start_tolerance: f32, hit: ptr<function, RayHit>) -> bool {\r\n\tvar tmin: f32 = 0.0;\r\n\tvar tmax: f32 = 300000000;\r\n\tfor (var d: i32 = 0; d < 3; d++) {\r\n\t\tlet t1 = (boundary_min[d] - ray.origin[d]) * ray.inv_direction[d];\r\n\t\tlet t2 = (boundary_max[d] - ray.origin[d]) * ray.inv_direction[d];\r\n\r\n\t\ttmin = min(max(t1, tmin), max(t2, tmin));\r\n\t\ttmax = max(min(t1, tmax), min(t2, tmax));\r\n\t}\r\n\t// Hier ist noch ein Fehler drin, tritt nur von ausserhalb des grid auf, das kommt ja vielleicht eh noch weg\r\n\tif tmin > tmax { return false; }\r\n    \tlet ray_entry = ray.origin + ray.direction * tmin;\r\n\tlet ray_exit = ray.origin + ray.direction * tmax;\r\n\r\n\tvar voxel: vec3<i32> = max(vec3<i32>(0), min(vec3<i32>(voxel_count - 1), vec3<i32>((ray_entry - boundary_min) / f32(voxel_size))));\r\n\t//var end_voxel: vec3<i32> = max(vec3<i32>(0), min(vec3<i32>(voxel_count - 1), vec3<i32>((ray_exit - boundary_min - ray.direction * 0.000001) / f32(voxel_size))));\r\n\r\n\tlet direction_zeros: vec3<bool> = ray.direction == vec3<f32>(0);\r\n\tlet step: vec3<i32> = vec3<i32>(sign(ray.direction));\r\n\tlet tdelta: vec3<f32> = select(voxel_size / abs(ray.direction), vec3<f32>(tmax), direction_zeros);\r\n\tlet voxel_boundary: vec3<f32> = vec3<f32>(voxel + max(vec3<i32>(0), step)) * voxel_size;\r\n\tvar tmax_comp: vec3<f32> = select(tmin + (boundary_min + voxel_boundary - ray_entry) / ray.direction, vec3<f32>(tmax), direction_zeros);\r\n\tvar thit: f32 = tmin;\r\n\tvar hit_normal: vec3<f32> = vec3<f32>(0, 0, 0);\r\n\r\n\twhile(all(voxel >= vec3<i32>(0)) && all(voxel < vec3<i32>(voxel_count))) {\r\n\t\tlet hit_voxel = get_voxel(voxel);\r\n\t\tif (hit_voxel.opacity > 0.01 && all(tmax_comp > vec3<f32>(start_tolerance))){\r\n\t\t\t(*hit).position = ray.origin + ray.direction * thit;\r\n\t\t\t(*hit).voxel = hit_voxel;\r\n\t\t\t(*hit).voxel_position = voxel;\r\n\t\t\t(*hit).depth = 1 - (thit - depth_clip_min) / (depth_clip_max - depth_clip_min);\r\n\t\t\t(*hit).normal = hit_normal;\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\tif (tmax_comp.x < tmax_comp.y && tmax_comp.x < tmax_comp.z) {\r\n\t\t\tvoxel.x += step.x;\r\n\t\t\tthit = tmax_comp.x;\r\n\t\t\ttmax_comp.x += tdelta.x;\r\n\t\t\thit_normal = vec3<f32>(f32(-step.x), 0, 0);\r\n\t\t} else if (tmax_comp.y < tmax_comp.z){\r\n\t\t\tvoxel.y += step.y;\r\n\t\t\tthit = tmax_comp.y;\r\n\t\t\ttmax_comp.y += tdelta.y;\r\n\t\t\thit_normal = vec3<f32>(0, f32(-step.y), 0);\r\n\t\t} else {\r\n\t\t\tvoxel.z += step.z;\r\n\t\t\tthit = tmax_comp.z;\r\n\t\t\ttmax_comp.z += tdelta.z;\r\n\t\t\thit_normal = vec3<f32>(0, 0, f32(-step.z));\r\n\t\t}\r\n\t}\r\n\r\n\treturn false;\r\n}\r\n\r\nfn get_hit_ao(hit: RayHit) -> f32 {\r\n\tlet voxel = hit.voxel_position + vec3<i32>(hit.normal);\r\n\tlet expo = 6f;\r\n\tlet fac = 0.2;\r\n\r\n\tlet dist = pow(((hit.position - (vec3<f32>(voxel) * voxel_size - grid_size / 2)) / voxel_size), vec3<f32>(expo));\r\n\tlet inv_dist = pow(((hit.position - (vec3<f32>(voxel + 1) * voxel_size - grid_size / 2)) / voxel_size), vec3<f32>(expo));\r\n\r\n\tlet ao = dist * fac * (1 - abs(hit.normal));\r\n\tlet inv_ao = inv_dist * fac * (1 - abs(hit.normal));\r\n\r\n\tlet cond_ao = ao * vec3<f32>(\r\n\t\tget_voxel(vec3<i32>(voxel.x + 1, voxel.y, voxel.z)).opacity,\r\n\t\tget_voxel(vec3<i32>(voxel.x, voxel.y + 1, voxel.z)).opacity,\r\n\t\tget_voxel(vec3<i32>(voxel.x, voxel.y, voxel.z + 1)).opacity,\r\n\t);\r\n\r\n\tlet cond_inv_ao = inv_ao * vec3<f32>(\r\n\t\tget_voxel(vec3<i32>(voxel.x - 1, voxel.y, voxel.z)).opacity,\r\n\t\tget_voxel(vec3<i32>(voxel.x, voxel.y - 1, voxel.z)).opacity,\r\n\t\tget_voxel(vec3<i32>(voxel.x, voxel.y, voxel.z - 1)).opacity,\r\n\t);\r\n\r\n\tvar corner_ao = 0f;\r\n\tif (get_voxel(vec3<i32>(voxel.x + 1, voxel.y + 1, voxel.z)).opacity > 0.01){\r\n\t\tcorner_ao = max(corner_ao, min(ao.x, ao.y) * (1 - min(1, ceil(cond_ao.x + cond_ao.y))));\r\n\t}\r\n\tif (get_voxel(vec3<i32>(voxel.x - 1, voxel.y + 1, voxel.z)).opacity > 0.01){\r\n\t\tcorner_ao = max(corner_ao, min(inv_ao.x, ao.y) * (1 - min(1, ceil(cond_inv_ao.x + cond_ao.y))));\r\n\t}\r\n\tif (get_voxel(vec3<i32>(voxel.x + 1, voxel.y - 1, voxel.z)).opacity > 0.01){\r\n\t\tcorner_ao = max(corner_ao, min(ao.x, inv_ao.y) * (1 - min(1, ceil(cond_ao.x + cond_inv_ao.y))));\r\n\t}\r\n\tif (get_voxel(vec3<i32>(voxel.x - 1, voxel.y - 1, voxel.z)).opacity > 0.01){\r\n\t\tcorner_ao = max(corner_ao, min(inv_ao.x, inv_ao.y) * (1 - min(1, ceil(cond_inv_ao.x + cond_inv_ao.y))));\r\n\t}\r\n\r\n\tif (get_voxel(vec3<i32>(voxel.x, voxel.y + 1, voxel.z + 1)).opacity > 0.01){\r\n\t\tcorner_ao = max(corner_ao, min(ao.y, ao.z) * (1 - min(1, ceil(cond_ao.y + cond_ao.z))));\r\n\t}\r\n\tif (get_voxel(vec3<i32>(voxel.x, voxel.y - 1, voxel.z + 1)).opacity > 0.01){\r\n\t\tcorner_ao = max(corner_ao, min(inv_ao.y, ao.z) * (1 - min(1, ceil(cond_inv_ao.y + cond_ao.z))));\r\n\t}\r\n\tif (get_voxel(vec3<i32>(voxel.x, voxel.y - 1, voxel.z - 1)).opacity > 0.01){\r\n\t\tcorner_ao = max(corner_ao, min(inv_ao.y, inv_ao.z) * (1 - min(1, ceil(cond_inv_ao.y + cond_inv_ao.z))));\r\n\t}\r\n\tif (get_voxel(vec3<i32>(voxel.x, voxel.y + 1, voxel.z - 1)).opacity > 0.01){\r\n\t\tcorner_ao = max(corner_ao, min(ao.y, inv_ao.z) * (1 - min(1, ceil(cond_ao.y + cond_inv_ao.z))));\r\n\t}\r\n\r\n\tif (get_voxel(vec3<i32>(voxel.x + 1, voxel.y, voxel.z + 1)).opacity > 0.01){\r\n\t\tcorner_ao = max(corner_ao, min(ao.x, ao.z) * (1 - min(1, ceil(cond_ao.x + cond_ao.z))));\r\n\t}\r\n\tif (get_voxel(vec3<i32>(voxel.x - 1, voxel.y, voxel.z + 1)).opacity > 0.01){\r\n\t\tcorner_ao = max(corner_ao, min(inv_ao.x, ao.z) * (1 - min(1, ceil(cond_inv_ao.x + cond_ao.z))));\r\n\t}\r\n\tif (get_voxel(vec3<i32>(voxel.x - 1, voxel.y, voxel.z - 1)).opacity > 0.01){\r\n\t\tcorner_ao = max(corner_ao, min(inv_ao.x, inv_ao.z) * (1 - min(1, ceil(cond_inv_ao.x + cond_inv_ao.z))));\r\n\t}\r\n\tif (get_voxel(vec3<i32>(voxel.x + 1, voxel.y, voxel.z - 1)).opacity > 0.01){\r\n\t\tcorner_ao = max(corner_ao, min(ao.x, inv_ao.z) * (1 - min(1, ceil(cond_ao.x + cond_inv_ao.z))));\r\n\t}\r\n\r\n\t//var remove_ao: f32;\r\n\t//if (get_voxel(vec3<))\r\n\r\n\treturn cond_ao.x + cond_ao.y + cond_ao.z + cond_inv_ao.x + cond_inv_ao.y + cond_inv_ao.z + corner_ao;\r\n}\r\n"}),constants:{grid_size:this.scene.grid_size,voxel_count:this.scene.voxel_count}}});const v=null===(r=this.device)||void 0===r?void 0:r.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.FRAGMENT,sampler:{}},{binding:1,visibility:GPUShaderStage.FRAGMENT,texture:{}}]});this.screen_bind_group=null===(o=this.device)||void 0===o?void 0:o.createBindGroup({layout:v,entries:[{binding:0,resource:this.sampler},{binding:1,resource:this.color_buffer_view}]});const u=null===(a=this.device)||void 0===a?void 0:a.createPipelineLayout({bindGroupLayouts:[v]});this.screen_pipeline=null===(c=this.device)||void 0===c?void 0:c.createRenderPipeline({layout:u,vertex:{module:this.device.createShaderModule({code:_}),entryPoint:"vert_main"},fragment:{module:this.device.createShaderModule({code:_}),entryPoint:"frag_main",targets:[{format:"bgra8unorm"}]},primitive:{topology:"triangle-list",cullMode:"back",frontFace:"cw"}})}))}}(h,f);f.initialize_default_grid(),m.initialize();let p=performance.now(),y=!1;addEventListener("mousedown",(e=>{2==e.button&&(y=!0)})),addEventListener("mouseup",(e=>{if(2==e.button&&(y=!1),0==e.button){const t=h.getBoundingClientRect(),n=e.clientX-t.left,i=e.clientY-t.top,r=f.ray_any(x.screen_to_ray(n,i,h.width,h.height));if(r){let e=new v;e.opacity=0,f.set_voxel(e,r.voxel_position)}}})),addEventListener("mousemove",(e=>{y&&x.mouse_move(x,e)})),addEventListener("contextmenu",(e=>(e.preventDefault(),!1))),addEventListener("keydown",(e=>{x.keyboard_down(x,e)})),addEventListener("keyup",(e=>{x.keyboard_up(x,e)})),requestAnimationFrame((function e(){m.render();const t=performance.now()-p;x.tick(t/1e3),p=performance.now(),d.innerText=Math.round(1/t*1e3).toString()+" fps",requestAnimationFrame(e)}))})();
//# sourceMappingURL=main.js.map