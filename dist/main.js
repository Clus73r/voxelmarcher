(()=>{"use strict";var e="undefined"!=typeof Float32Array?Float32Array:Array;function t(){var t=new e(3);return e!=Float32Array&&(t[0]=0,t[1]=0,t[2]=0),t}function r(e,t,r){return e[0]=t[0]+r[0],e[1]=t[1]+r[1],e[2]=t[2]+r[2],e}function n(e,t,r){return e[0]=t[0]*r,e[1]=t[1]*r,e[2]=t[2]*r,e}function i(e,t,r){var n=t[0],i=t[1],o=t[2],a=r[0],s=r[1],c=r[2];return e[0]=i*c-o*s,e[1]=o*a-n*c,e[2]=n*s-i*a,e}function o(e){return e*Math.PI/180}Math.random,Math.PI,Math.hypot||(Math.hypot=function(){for(var e=0,t=arguments.length;t--;)e+=arguments[t]*arguments[t];return Math.sqrt(e)}),t();const a="@group(0) @binding(0) var screen_sampler : sampler;\r\n@group(0) @binding(1) var color_buffer : texture_2d<f32>;\r\n\r\nstruct VertexOutput {\r\n        @builtin(position) Position : vec4<f32>,\r\n            @location(0) TexCoord : vec2<f32>,\r\n}\r\n\r\n@vertex\r\nfn vert_main(@builtin(vertex_index) VertexIndex : u32) -> VertexOutput {\r\n    var positions = array<vec2<f32>, 6>(\r\n        vec2<f32>( 1.0,  1.0),\r\n        vec2<f32>( 1.0, -1.0),\r\n        vec2<f32>(-1.0, -1.0),\r\n        vec2<f32>( 1.0,  1.0),\r\n        vec2<f32>(-1.0, -1.0),\r\n        vec2<f32>(-1.0,  1.0)\r\n    );\r\n\r\n    var texCoords = array<vec2<f32>, 6>(\r\n        vec2<f32>(1.0, 0.0),\r\n        vec2<f32>(1.0, 1.0),\r\n        vec2<f32>(0.0, 1.0),\r\n        vec2<f32>(1.0, 0.0),\r\n        vec2<f32>(0.0, 1.0),\r\n        vec2<f32>(0.0, 0.0)\r\n    );\r\n\r\n    var output : VertexOutput;\r\n    output.Position = vec4<f32>(positions[VertexIndex], 0.0, 1.0);\r\n    output.TexCoord = texCoords[VertexIndex];\r\n    return output;\r\n}\r\n\r\n@fragment\r\nfn frag_main(@location(0) TexCoord : vec2<f32>) -> @location(0) vec4<f32> {\r\n    return textureSample(color_buffer, screen_sampler, TexCoord);\r\n}";var s=function(e,t,r,n){return new(r||(r=Promise))((function(i,o){function a(e){try{c(n.next(e))}catch(e){o(e)}}function s(e){try{c(n.throw(e))}catch(e){o(e)}}function c(e){var t;e.done?i(e.value):(t=e.value,t instanceof r?t:new r((function(e){e(t)}))).then(a,s)}c((n=n.apply(e,t||[])).next())}))};const c=32,d=document.getElementById("canv"),u=document.getElementById("fps");let l=new class{constructor(r,n,i){var o;this.forward=t(),this.right=t(),this.up=t(),this.position=r,this.eulers=[0,i,n],this.view=(o=new e(16),e!=Float32Array&&(o[1]=0,o[2]=0,o[3]=0,o[4]=0,o[6]=0,o[7]=0,o[8]=0,o[9]=0,o[11]=0,o[12]=0,o[13]=0,o[14]=0),o[0]=1,o[5]=1,o[10]=1,o[15]=1,o),this.update(),this.inputs=[!1,!1,!1,!1,!1,!1],this.speed=1}tick(e){let i=t();var o,a,s,c,d,u;this.inputs[0]&&r(i,i,this.forward),this.inputs[1]&&r(i,i,this.right),this.inputs[2]&&r(i,i,n(t(),this.forward,-1)),this.inputs[3]&&r(i,i,n(t(),this.right,-1)),this.inputs[4]&&r(i,i,this.up),this.inputs[5]&&r(i,i,n(t(),this.up,-1)),o=i,s=(a=i)[0],c=a[1],d=a[2],(u=s*s+c*c+d*d)>0&&(u=1/Math.sqrt(u)),o[0]=a[0]*u,o[1]=a[1]*u,o[2]=a[2]*u,r(this.position,this.position,n(t(),i,this.speed*e))}update(){this.forward=[Math.cos(o(this.eulers[2]))*Math.cos(o(this.eulers[1])),Math.sin(o(this.eulers[2]))*Math.cos(o(this.eulers[1])),Math.sin(o(this.eulers[1]))],i(this.right,this.forward,[0,0,1]),i(this.up,this.right,this.forward),r(t(),this.position,this.forward)}mouse_move(e,t){e.eulers[1]=(e.eulers[1]+t.movementY)%360,e.eulers[2]=(e.eulers[2]-t.movementX)%360,e.update()}keyboard_down(e,t){"e"==t.key&&(e.inputs[0]=!0),"d"==t.key&&(e.inputs[2]=!0),"f"==t.key&&(e.inputs[1]=!0),"s"==t.key&&(e.inputs[3]=!0),"r"==t.key&&(e.inputs[5]=!0),"w"==t.key&&(e.inputs[4]=!0)}keyboard_up(e,t){"e"==t.key&&(e.inputs[0]=!1),"d"==t.key&&(e.inputs[2]=!1),"f"==t.key&&(e.inputs[1]=!1),"s"==t.key&&(e.inputs[3]=!1),"r"==t.key&&(e.inputs[5]=!1),"w"==t.key&&(e.inputs[4]=!1)}}([-8,0,0],0,0);const v=new class{constructor(e){this.camera=e,this.grid=new Array(32768),this.boundary_length=32}initialize_grid(){for(let e=0;e<c;e++)for(let t=0;t<c;t++)for(let r=0;r<c;r++)e>30||r<1?this.set_voxel(1,e,t,r):this.set_voxel(0,e,t,r)}get_voxel(e,t,r){return this.grid[r*c*c+t*c+e]}set_voxel(e,t,r,n){this.grid[n*c*c+r*c+t]=e}}(l),h=new class{constructor(e,t){this.render=()=>{var e,t,r,n;null===(e=this.device)||void 0===e||e.queue.writeBuffer(this.sceneParameters,0,new Float32Array([this.scene.camera.position[0],this.scene.camera.position[1],this.scene.camera.position[2],0,this.scene.camera.forward[0],this.scene.camera.forward[1],this.scene.camera.forward[2],0,this.scene.camera.right[0],this.scene.camera.right[1],this.scene.camera.right[2],0,this.scene.camera.up[0],this.scene.camera.up[1],this.scene.camera.up[2],0]),0,16);const i=null===(t=this.device)||void 0===t?void 0:t.createCommandEncoder(),o=null==i?void 0:i.beginComputePass();null==o||o.setPipeline(this.ray_tracing_pipeline),null==o||o.setBindGroup(0,this.ray_tracing_bind_group),null==o||o.dispatchWorkgroups(this.canvas.width,this.canvas.height,1),null==o||o.end();const a=null===(r=this.context)||void 0===r?void 0:r.getCurrentTexture().createView(),s=null==i?void 0:i.beginRenderPass({colorAttachments:[{view:a,clearValue:{r:.5,g:0,b:.25,a:1},loadOp:"clear",storeOp:"store"}]});null==s||s.setPipeline(this.screen_pipeline),null==s||s.setBindGroup(0,this.screen_bind_group),null==s||s.draw(6,1,0,0),null==s||s.end(),null===(n=this.device)||void 0===n||n.queue.submit([null==i?void 0:i.finish()])},this.canvas=e,this.scene=t}initialize(){return s(this,void 0,void 0,(function*(){yield this.setupDevice(),yield this.createAssets(),yield this.setupPipeline()}))}setupDevice(){var e,t;return s(this,void 0,void 0,(function*(){this.adapter=yield null===(e=navigator.gpu)||void 0===e?void 0:e.requestAdapter(),this.device=yield null===(t=this.adapter)||void 0===t?void 0:t.requestDevice(),this.context=this.canvas.getContext("webgpu"),this.format="bgra8unorm",this.context.configure({device:this.device,format:this.format,alphaMode:"opaque"})}))}createAssets(){var e,t,r,n;return s(this,void 0,void 0,(function*(){this.color_buffer=null===(e=this.device)||void 0===e?void 0:e.createTexture({size:{width:this.canvas.width,height:this.canvas.height},format:"rgba8unorm",usage:GPUTextureUsage.COPY_DST|GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.TEXTURE_BINDING}),this.color_buffer_view=null===(t=this.color_buffer)||void 0===t?void 0:t.createView(),this.sampler=null===(r=this.device)||void 0===r?void 0:r.createSampler({addressModeU:"repeat",addressModeV:"repeat",magFilter:"linear",minFilter:"nearest",mipmapFilter:"nearest",maxAnisotropy:1}),this.sceneParameters=null===(n=this.device)||void 0===n?void 0:n.createBuffer({size:64,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST})}))}setupPipeline(){var e,t,r,n,i,o,c,d;return s(this,void 0,void 0,(function*(){const s=null===(e=this.device)||void 0===e?void 0:e.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,storageTexture:{access:"write-only",format:"rgba8unorm",viewDimension:"2d"}},{binding:1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}}]});this.ray_tracing_bind_group=null===(t=this.device)||void 0===t?void 0:t.createBindGroup({layout:s,label:"Ray tracing bind group",entries:[{binding:0,resource:this.color_buffer_view},{binding:1,resource:{buffer:this.sceneParameters}}]});const u=null===(r=this.device)||void 0===r?void 0:r.createPipelineLayout({bindGroupLayouts:[s]});this.ray_tracing_pipeline=null===(n=this.device)||void 0===n?void 0:n.createComputePipeline({label:"Ray tracing pipeline",layout:u,compute:{entryPoint:"main",module:this.device.createShaderModule({code:"@group(0) @binding(0) var color_buffer: texture_storage_2d<rgba8unorm, write>;\r\n@group(0) @binding(1) var<uniform> scene: SceneData;\r\n\r\nconst grid_size: i32 = 2;\r\nconst voxel_count: i32 = 4;\r\nconst voxel_size: f32 = f32(grid_size) / f32(voxel_count);\r\nconst boundary_min: vec3<f32> = vec3<f32>(f32(-grid_size) / 2, f32(-grid_size) / 2, f32(-grid_size) / 2);\r\nconst boundary_max: vec3<f32> = vec3<f32>(f32(grid_size) / 2, f32(grid_size) / 2, f32(grid_size) / 2);\r\n\r\nstruct Ray {\r\n    origin: vec3<f32>,\r\n    direction: vec3<f32>,\r\n    inv_direction: vec3<f32>,\r\n}\r\n\r\nstruct RayHit {\r\n\tposition: vec3<f32>,\r\n\tvoxel: i32,\r\n}\r\n\r\nstruct SceneData {\r\n    cameraPos: vec3<f32>,\r\n    cameraForwards: vec3<f32>,\r\n    cameraRight: vec3<f32>,\r\n    cameraUp: vec3<f32>,\r\n}\r\n\r\nstruct VoxelData {\r\n\tdata: array<i32, 64>,\r\n}\r\n\r\n@compute @workgroup_size(1,1,1)\r\nfn main(@builtin(global_invocation_id) GlobalInvocationID : vec3<u32>) {\r\n    let screen_size: vec2<u32> = textureDimensions(color_buffer);\r\n    let screen_pos : vec2<i32> = vec2<i32>(i32(GlobalInvocationID.x), i32(GlobalInvocationID.y));\r\n\r\n    let horizontal_coefficient: f32 = (f32(screen_pos.x) - f32(screen_size.x) / 2) / f32(screen_size.x);\r\n    let vertical_coefficient: f32 = (f32(screen_pos.y) - f32(screen_size.y) / 2) / f32(screen_size.y);\r\n\r\n\r\n    let ray_direction = normalize(scene.cameraForwards\r\n\t+ horizontal_coefficient * scene.cameraRight\r\n\t+ vertical_coefficient * scene.cameraUp);\r\n    let ray: Ray = Ray(scene.cameraPos, ray_direction, 1 / ray_direction);\r\n\r\n    var pixel_color : vec3<f32> = vec3<f32>(ray_direction[0], ray_direction[1], ray_direction[2]);\r\n    pixel_color += 0.8;\r\n    /* pixel_color  */\r\n\r\n\tvar hit: RayHit;\r\n    if (voxel_ray_any(ray, &hit)){\r\n\t    pixel_color = vec3<f32>((hit.position - boundary_min) / f32(voxel_count));\r\n    }\r\n    textureStore(color_buffer, screen_pos, vec4<f32>(pixel_color, 1.0));\r\n}\r\n\r\nfn voxel_ray_any(ray: Ray, hit: ptr<function, RayHit>) -> bool {\r\n\tvar tmin: f32 = 0.0;\r\n\tvar tmax: f32 = 300000000;\r\n\tfor (var d: i32 = 0; d < 3; d++) {\r\n\t\tlet t1 = (boundary_min[d] - ray.origin[d]) * ray.inv_direction[d];\r\n\t\tlet t2 = (boundary_max[d] - ray.origin[d]) * ray.inv_direction[d];\r\n\r\n\t\ttmin = min(max(t1, tmin), max(t2, tmin));\r\n\t\ttmax = max(min(t1, tmax), min(t2, tmax));\r\n\t}\r\n\tif tmin > tmax { return false; }\r\n    \tlet ray_hit = ray.origin + ray.direction * tmin;\r\n\tlet ray_exit = ray.origin + ray.direction * tmax;\r\n\r\n\tvar voxel: vec3<i32> = vec3<i32>(\r\n\t\tmin(voxel_count - 1, i32((ray_hit[0] - boundary_min[0]) / f32(voxel_size))),\r\n\t\tmin(voxel_count - 1, i32((ray_hit[1] - boundary_min[1]) / f32(voxel_size))),\r\n\t\tmin(voxel_count - 1, i32((ray_hit[2] - boundary_min[2]) / f32(voxel_size))));\r\n\r\n\tvar tmax_comp: vec3<f32> = vec3<f32>(0, 0, 0);\r\n\tvar tdelta: vec3<f32> = vec3<f32>(0, 0, 0);\r\n\tvar step: vec3<i32> = vec3<i32>(0, 0, 0);\r\n\tlet next_voxel: vec3<i32> = voxel + step;\r\n\r\n\tvar current_index: vec3<i32> = vec3<i32>(0, 0, 0);\r\n\r\n\tfor (var d: i32; d < 3; d++){\r\n\t\tif (ray.direction[d] > 0.0){\r\n\t\t\tstep[d] = 1;\r\n\t\t\tcurrent_index[d] = i32(max(0, floor((ray.origin[d] - boundary_min[d]) / voxel_size)));\r\n\t\t\ttdelta[d] = voxel_size / ray.direction[d];\r\n\t\t\t//tmax_comp[d] = tmin + (boundary_min[d] + f32(next_voxel[d]) * voxel_size - ray_hit[d]) / ray.direction[d];\r\n\t\t\ttmax_comp[d] = tmin + (boundary_min[d] + f32(current_index[d]) * voxel_size - ray_hit[d]) / ray.direction[d];\r\n\r\n\t\t} else if (ray.direction[d] < 0.0){\r\n\t\t\tstep[d] = -1;\r\n\t\t\ttdelta[d] = voxel_size / (-ray.direction[d]);\r\n\t\t\tlet prev_voxel: i32 = voxel[d] - 1;\r\n\t\t\ttmax_comp[d] = tmin + (boundary_min[d] + f32(prev_voxel) * voxel_size - ray_hit[d]) / ray.direction[d];\r\n\t\t} else {\r\n\t\t\tstep[d] = 0;\r\n\t\t\ttdelta[d] = tmax;\r\n\t\t\ttmax_comp[d] = tmax;\r\n\t\t}\r\n\t}\r\n\t\r\n\twhile(\r\n\t\tvoxel.x >= 0 && voxel.x < voxel_count &&\r\n\t\tvoxel.y >= 0 && voxel.y < voxel_count &&\r\n\t\tvoxel.z >= 0 && voxel.z < voxel_count\r\n\t) {\r\n\t\tif (get_voxel(voxel) != 0){\r\n\t\t\t(*hit).position = ray.origin + ray.direction * tmax_comp;\r\n\t\t\t(*hit).voxel = get_voxel(voxel);\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\tif (tmax_comp.x < tmax_comp.y && tmax_comp.x < tmax_comp.z) {\r\n\t\t\tvoxel.x += step.x;\r\n\t\t\ttmax_comp.x += tdelta.x;\r\n\t\t} else if (tmax_comp.y < tmax_comp.z){\r\n\t\t\tvoxel.y += step.y;\r\n\t\t\ttmax_comp.y += tdelta.y;\r\n\t\t} else {\r\n\t\t\tvoxel.z += step.z;\r\n\t\t\ttmax_comp.z += tdelta.z;\r\n\t\t}\r\n\t}\r\n\r\n\treturn false;\r\n}\r\n\r\nfn get_voxel(v: vec3<i32>) -> i32 {\r\n\tlet x: i32 = v.x;\r\n\tconst g: array<i32, 64> = array<i32, 64>(\r\n\t\t1, 1, 1, 1,\r\n\t\t0, 0, 0, 0,\r\n\t\t1, 1, 1, 1,\r\n\t\t0, 0, 0, 0,\r\n\t\t1, 1, 1, 1,\r\n\t\t0, 0, 0, 0,\r\n\t\t1, 1, 1, 1,\r\n\t\t0, 0, 0, 0,\r\n\t\t1, 1, 1, 1,\r\n\t\t0, 0, 0, 0,\r\n\t\t1, 1, 1, 1,\r\n\t\t0, 0, 0, 0,\r\n\t\t1, 1, 1, 1,\r\n\t\t0, 0, 0, 0,\r\n\t\t0, 0, 0, 0,\r\n\t\t1, 1, 1, 1,\r\n\t);\r\n\treturn g[v.z * voxel_count * voxel_count + v.y * voxel_count + v.x];\r\n}\r\n"})}});const l=null===(i=this.device)||void 0===i?void 0:i.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.FRAGMENT,sampler:{}},{binding:1,visibility:GPUShaderStage.FRAGMENT,texture:{}}]});this.screen_bind_group=null===(o=this.device)||void 0===o?void 0:o.createBindGroup({layout:l,entries:[{binding:0,resource:this.sampler},{binding:1,resource:this.color_buffer_view}]});const v=null===(c=this.device)||void 0===c?void 0:c.createPipelineLayout({bindGroupLayouts:[l]});this.screen_pipeline=null===(d=this.device)||void 0===d?void 0:d.createRenderPipeline({layout:v,vertex:{module:this.device.createShaderModule({code:a}),entryPoint:"vert_main"},fragment:{module:this.device.createShaderModule({code:a}),entryPoint:"frag_main",targets:[{format:"bgra8unorm"}]},primitive:{topology:"triangle-list",cullMode:"back",frontFace:"cw"}})}))}}(d,v);h.initialize();let f=performance.now(),p=!1;addEventListener("mousedown",(e=>{p=!0})),addEventListener("mouseup",(e=>{p=!1})),addEventListener("mousemove",(e=>{p&&l.mouse_move(l,e)})),addEventListener("keydown",(e=>{l.keyboard_down(l,e)})),addEventListener("keyup",(e=>{l.keyboard_up(l,e)})),requestAnimationFrame((function e(){h.render();const t=performance.now()-f;l.tick(1/t),f=performance.now(),u.innerText=Math.round(1/t*1e3).toString()+" fps",requestAnimationFrame(e)}))})();