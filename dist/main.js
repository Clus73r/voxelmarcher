(()=>{"use strict";const t="@group(0) @binding(0) var screen_sampler : sampler;\r\n@group(0) @binding(1) var color_buffer : texture_2d<f32>;\r\n@group(0) @binding(2) var secondary_buffer : texture_2d<f32>;\r\n\r\nstruct VertexOutput {\r\n        @builtin(position) Position : vec4<f32>,\r\n            @location(0) TexCoord : vec2<f32>,\r\n}\r\n\r\n@vertex\r\nfn vert_main(@builtin(vertex_index) VertexIndex : u32) -> VertexOutput {\r\n    var positions = array<vec2<f32>, 6>(\r\n        vec2<f32>( 1.0,  1.0),\r\n        vec2<f32>( 1.0, -1.0),\r\n        vec2<f32>(-1.0, -1.0),\r\n        vec2<f32>( 1.0,  1.0),\r\n        vec2<f32>(-1.0, -1.0),\r\n        vec2<f32>(-1.0,  1.0)\r\n    );\r\n\r\n    var texCoords = array<vec2<f32>, 6>(\r\n        vec2<f32>(1.0, 0.0),\r\n        vec2<f32>(1.0, 1.0),\r\n        vec2<f32>(0.0, 1.0),\r\n        vec2<f32>(1.0, 0.0),\r\n        vec2<f32>(0.0, 1.0),\r\n        vec2<f32>(0.0, 0.0)\r\n    );\r\n\r\n    var output : VertexOutput;\r\n    output.Position = vec4<f32>(positions[VertexIndex], 0.0, 1.0);\r\n    output.TexCoord = texCoords[VertexIndex];\r\n    return output;\r\n}\r\n\r\nconst ao_blur_steps = 7;\r\nconst ao_blur_radius = 0.00f / f32(ao_blur_steps);\r\nconst ao_strength = 1;\r\n\r\n@fragment\r\nfn frag_main(@location(0) TexCoord : vec2<f32>) -> @location(0) vec4<f32> {\r\n\tvar acc = 0f;\r\n\tlet blur_offset = (ao_blur_radius * f32(ao_blur_steps)) / 2;\r\n\tfor (var x = 0; x < ao_blur_steps; x++){\r\n\t\tfor (var y = 0; y < ao_blur_steps; y++){\r\n\t\t\tacc += textureSample(secondary_buffer, screen_sampler, vec2<f32>(TexCoord.x - blur_offset + ao_blur_radius * f32(x), TexCoord.y - blur_offset + ao_blur_radius * f32(y))).x;\r\n\t\t}\r\n\t}\r\n\tacc /= f32(ao_blur_steps) * f32(ao_blur_steps);\r\n\r\n    // return vec4<f32>(acc, acc, acc, 1.0);\r\n    return textureSample(color_buffer, screen_sampler, TexCoord) * (1 - acc * ao_strength);\r\n}\r\n";var e=function(t,e,r,n){return new(r||(r=Promise))((function(i,o){function s(t){try{c(n.next(t))}catch(t){o(t)}}function a(t){try{c(n.throw(t))}catch(t){o(t)}}function c(t){var e;t.done?i(t.value):(e=t.value,e instanceof r?e:new r((function(t){t(e)}))).then(s,a)}c((n=n.apply(t,e||[])).next())}))};let r=1e-6,n=Float32Array;function i(t=0,e=0){const r=new n(2);return void 0!==t&&(r[0]=t,void 0!==e&&(r[1]=e)),r}const o=i;function s(t,e,r){return(r=r||new n(2))[0]=t[0]-e[0],r[1]=t[1]-e[1],r}const a=s;function c(t,e,r){return(r=r||new n(2))[0]=t[0]*e,r[1]=t[1]*e,r}const l=c;function u(t,e){return(e=e||new n(2))[0]=1/t[0],e[1]=1/t[1],e}const h=u;function _(t,e){return t[0]*e[0]+t[1]*e[1]}function d(t){const e=t[0],r=t[1];return Math.sqrt(e*e+r*r)}const v=d;function m(t){const e=t[0],r=t[1];return e*e+r*r}const f=m;function p(t,e){const r=t[0]-e[0],n=t[1]-e[1];return Math.sqrt(r*r+n*n)}const x=p;function g(t,e){const r=t[0]-e[0],n=t[1]-e[1];return r*r+n*n}const y=g;function b(t,e){return(e=e||new n(2))[0]=t[0],e[1]=t[1],e}const w=b;function z(t,e,r){return(r=r||new n(2))[0]=t[0]*e[0],r[1]=t[1]*e[1],r}const M=z;function P(t,e,r){return(r=r||new n(2))[0]=t[0]/e[0],r[1]=t[1]/e[1],r}const I=P;var S=Object.freeze({__proto__:null,add:function(t,e,r){return(r=r||new n(2))[0]=t[0]+e[0],r[1]=t[1]+e[1],r},addScaled:function(t,e,r,i){return(i=i||new n(2))[0]=t[0]+e[0]*r,i[1]=t[1]+e[1]*r,i},angle:function(t,e){const r=t[0],n=t[1],i=t[0],o=t[1],s=Math.sqrt(r*r+n*n)*Math.sqrt(i*i+o*o),a=s&&_(t,e)/s;return Math.acos(a)},ceil:function(t,e){return(e=e||new n(2))[0]=Math.ceil(t[0]),e[1]=Math.ceil(t[1]),e},clamp:function(t,e=0,r=1,i){return(i=i||new n(2))[0]=Math.min(r,Math.max(e,t[0])),i[1]=Math.min(r,Math.max(e,t[1])),i},clone:w,copy:b,create:i,cross:function(t,e,r){r=r||new n(3);const i=t[0]*e[1]-t[1]*e[0];return r[0]=0,r[1]=0,r[2]=i,r},dist:x,distSq:y,distance:p,distanceSq:g,div:I,divScalar:function(t,e,r){return(r=r||new n(2))[0]=t[0]/e,r[1]=t[1]/e,r},divide:P,dot:_,equals:function(t,e){return t[0]===e[0]&&t[1]===e[1]},equalsApproximately:function(t,e){return Math.abs(t[0]-e[0])<r&&Math.abs(t[1]-e[1])<r},floor:function(t,e){return(e=e||new n(2))[0]=Math.floor(t[0]),e[1]=Math.floor(t[1]),e},fromValues:o,inverse:u,invert:h,len:v,lenSq:f,length:d,lengthSq:m,lerp:function(t,e,r,i){return(i=i||new n(2))[0]=t[0]+r*(e[0]-t[0]),i[1]=t[1]+r*(e[1]-t[1]),i},lerpV:function(t,e,r,i){return(i=i||new n(2))[0]=t[0]+r[0]*(e[0]-t[0]),i[1]=t[1]+r[1]*(e[1]-t[1]),i},max:function(t,e,r){return(r=r||new n(2))[0]=Math.max(t[0],e[0]),r[1]=Math.max(t[1],e[1]),r},min:function(t,e,r){return(r=r||new n(2))[0]=Math.min(t[0],e[0]),r[1]=Math.min(t[1],e[1]),r},mul:M,mulScalar:c,multiply:z,negate:function(t,e){return(e=e||new n(2))[0]=-t[0],e[1]=-t[1],e},normalize:function(t,e){e=e||new n(2);const r=t[0],i=t[1],o=Math.sqrt(r*r+i*i);return o>1e-5?(e[0]=r/o,e[1]=i/o):(e[0]=0,e[1]=0),e},random:function(t=1,e){e=e||new n(2);const r=2*Math.random()*Math.PI;return e[0]=Math.cos(r)*t,e[1]=Math.sin(r)*t,e},round:function(t,e){return(e=e||new n(2))[0]=Math.round(t[0]),e[1]=Math.round(t[1]),e},scale:l,setDefaultType:function(t){const e=n;return n=t,e},sub:a,subtract:s,transformMat3:function(t,e,r){r=r||new n(2);const i=t[0],o=t[1];return r[0]=e[0]*i+e[4]*o+e[8],r[1]=e[1]*i+e[5]*o+e[9],r},transformMat4:function(t,e,r){r=r||new n(2);const i=t[0],o=t[1];return r[0]=i*e[0]+o*e[4]+e[12],r[1]=i*e[1]+o*e[5]+e[13],r},zero:function(t){return(t=t||new n(2))[0]=0,t[1]=0,t}});Float32Array;new Map([[Float32Array,()=>new Float32Array(12)],[Float64Array,()=>new Float64Array(12)],[Array,()=>new Array(12).fill(0)]]).get(Float32Array);let k=Float32Array;function E(t,e,r){const n=new k(3);return void 0!==t&&(n[0]=t,void 0!==e&&(n[1]=e,void 0!==r&&(n[2]=r))),n}const R=E;function G(t,e,r){return(r=r||new k(3))[0]=t[0]-e[0],r[1]=t[1]-e[1],r[2]=t[2]-e[2],r}const T=G;function U(t,e,r){return(r=r||new k(3))[0]=t[0]*e,r[1]=t[1]*e,r[2]=t[2]*e,r}const D=U;function B(t,e){return(e=e||new k(3))[0]=1/t[0],e[1]=1/t[1],e[2]=1/t[2],e}const L=B;function q(t,e){return t[0]*e[0]+t[1]*e[1]+t[2]*e[2]}function A(t){const e=t[0],r=t[1],n=t[2];return Math.sqrt(e*e+r*r+n*n)}const F=A;function O(t){const e=t[0],r=t[1],n=t[2];return e*e+r*r+n*n}const C=O;function V(t,e){const r=t[0]-e[0],n=t[1]-e[1],i=t[2]-e[2];return Math.sqrt(r*r+n*n+i*i)}const H=V;function N(t,e){const r=t[0]-e[0],n=t[1]-e[1],i=t[2]-e[2];return r*r+n*n+i*i}const Y=N;function j(t,e){return(e=e||new k(3))[0]=t[0],e[1]=t[1],e[2]=t[2],e}const X=j;function J(t,e,r){return(r=r||new k(3))[0]=t[0]*e[0],r[1]=t[1]*e[1],r[2]=t[2]*e[2],r}const W=J;function K(t,e,r){return(r=r||new k(3))[0]=t[0]/e[0],r[1]=t[1]/e[1],r[2]=t[2]/e[2],r}const Q=K;var Z=Object.freeze({__proto__:null,add:function(t,e,r){return(r=r||new k(3))[0]=t[0]+e[0],r[1]=t[1]+e[1],r[2]=t[2]+e[2],r},addScaled:function(t,e,r,n){return(n=n||new k(3))[0]=t[0]+e[0]*r,n[1]=t[1]+e[1]*r,n[2]=t[2]+e[2]*r,n},angle:function(t,e){const r=t[0],n=t[1],i=t[2],o=t[0],s=t[1],a=t[2],c=Math.sqrt(r*r+n*n+i*i)*Math.sqrt(o*o+s*s+a*a),l=c&&q(t,e)/c;return Math.acos(l)},ceil:function(t,e){return(e=e||new k(3))[0]=Math.ceil(t[0]),e[1]=Math.ceil(t[1]),e[2]=Math.ceil(t[2]),e},clamp:function(t,e=0,r=1,n){return(n=n||new k(3))[0]=Math.min(r,Math.max(e,t[0])),n[1]=Math.min(r,Math.max(e,t[1])),n[2]=Math.min(r,Math.max(e,t[2])),n},clone:X,copy:j,create:E,cross:function(t,e,r){r=r||new k(3);const n=t[2]*e[0]-t[0]*e[2],i=t[0]*e[1]-t[1]*e[0];return r[0]=t[1]*e[2]-t[2]*e[1],r[1]=n,r[2]=i,r},dist:H,distSq:Y,distance:V,distanceSq:N,div:Q,divScalar:function(t,e,r){return(r=r||new k(3))[0]=t[0]/e,r[1]=t[1]/e,r[2]=t[2]/e,r},divide:K,dot:q,equals:function(t,e){return t[0]===e[0]&&t[1]===e[1]&&t[2]===e[2]},equalsApproximately:function(t,e){return Math.abs(t[0]-e[0])<r&&Math.abs(t[1]-e[1])<r&&Math.abs(t[2]-e[2])<r},floor:function(t,e){return(e=e||new k(3))[0]=Math.floor(t[0]),e[1]=Math.floor(t[1]),e[2]=Math.floor(t[2]),e},fromValues:R,getAxis:function(t,e,r){const n=4*e;return(r=r||new k(3))[0]=t[n+0],r[1]=t[n+1],r[2]=t[n+2],r},getScaling:function(t,e){e=e||new k(3);const r=t[0],n=t[1],i=t[2],o=t[4],s=t[5],a=t[6],c=t[8],l=t[9],u=t[10];return e[0]=Math.sqrt(r*r+n*n+i*i),e[1]=Math.sqrt(o*o+s*s+a*a),e[2]=Math.sqrt(c*c+l*l+u*u),e},getTranslation:function(t,e){return(e=e||new k(3))[0]=t[12],e[1]=t[13],e[2]=t[14],e},inverse:B,invert:L,len:F,lenSq:C,length:A,lengthSq:O,lerp:function(t,e,r,n){return(n=n||new k(3))[0]=t[0]+r*(e[0]-t[0]),n[1]=t[1]+r*(e[1]-t[1]),n[2]=t[2]+r*(e[2]-t[2]),n},lerpV:function(t,e,r,n){return(n=n||new k(3))[0]=t[0]+r[0]*(e[0]-t[0]),n[1]=t[1]+r[1]*(e[1]-t[1]),n[2]=t[2]+r[2]*(e[2]-t[2]),n},max:function(t,e,r){return(r=r||new k(3))[0]=Math.max(t[0],e[0]),r[1]=Math.max(t[1],e[1]),r[2]=Math.max(t[2],e[2]),r},min:function(t,e,r){return(r=r||new k(3))[0]=Math.min(t[0],e[0]),r[1]=Math.min(t[1],e[1]),r[2]=Math.min(t[2],e[2]),r},mul:W,mulScalar:U,multiply:J,negate:function(t,e){return(e=e||new k(3))[0]=-t[0],e[1]=-t[1],e[2]=-t[2],e},normalize:function(t,e){e=e||new k(3);const r=t[0],n=t[1],i=t[2],o=Math.sqrt(r*r+n*n+i*i);return o>1e-5?(e[0]=r/o,e[1]=n/o,e[2]=i/o):(e[0]=0,e[1]=0,e[2]=0),e},random:function(t=1,e){e=e||new k(3);const r=2*Math.random()*Math.PI,n=2*Math.random()-1,i=Math.sqrt(1-n*n)*t;return e[0]=Math.cos(r)*i,e[1]=Math.sin(r)*i,e[2]=n*t,e},round:function(t,e){return(e=e||new k(3))[0]=Math.round(t[0]),e[1]=Math.round(t[1]),e[2]=Math.round(t[2]),e},scale:D,setDefaultType:function(t){const e=k;return k=t,e},sub:T,subtract:G,transformMat3:function(t,e,r){r=r||new k(3);const n=t[0],i=t[1],o=t[2];return r[0]=n*e[0]+i*e[4]+o*e[8],r[1]=n*e[1]+i*e[5]+o*e[9],r[2]=n*e[2]+i*e[6]+o*e[10],r},transformMat4:function(t,e,r){r=r||new k(3);const n=t[0],i=t[1],o=t[2],s=e[3]*n+e[7]*i+e[11]*o+e[15]||1;return r[0]=(e[0]*n+e[4]*i+e[8]*o+e[12])/s,r[1]=(e[1]*n+e[5]*i+e[9]*o+e[13])/s,r[2]=(e[2]*n+e[6]*i+e[10]*o+e[14])/s,r},transformMat4Upper3x3:function(t,e,r){r=r||new k(3);const n=t[0],i=t[1],o=t[2];return r[0]=n*e[0]+i*e[4]+o*e[8],r[1]=n*e[1]+i*e[5]+o*e[9],r[2]=n*e[2]+i*e[6]+o*e[10],r},zero:function(t){return(t=t||new k(3))[0]=0,t[1]=0,t[2]=0,t}});function $(t){return t*Math.PI/180}Float32Array,Float32Array,Float32Array;class tt{constructor(t,e){this.origin=t,this.direction=Z.normalize(e),this.inv_direction=[1,1,1],Z.div(this.inv_direction,e,this.inv_direction)}}class et{constructor(t,e,r,n){this.position=t,this.voxel_position=e,this.voxel=r,this.normal=n}}class rt{constructor(){this.color=Z.create(),this.opacity=0,this.roughness=1,this.lightness=0}}class nt{constructor(){this.gi=Z.create()}}class it{constructor(t,e,r){this.dragged=!1,this.velocity=[0,0],this.distance=8,this.forward=Z.create(),this.right=Z.create(),this.up=Z.create(),this.position=Z.create(),this.eulers=[0,r,e],this.distance=t}update(){this.eulers[1]=Math.min(80,Math.max(-80,this.eulers[1])),this.eulers[2]=this.eulers[2]%360,this.forward=[Math.cos($(this.eulers[2]))*Math.cos($(this.eulers[1])),Math.sin($(this.eulers[2]))*Math.cos($(this.eulers[1])),Math.sin($(this.eulers[1]))],Z.normalize(Z.cross(this.forward,[0,0,1],this.right),this.right),Z.normalize(Z.cross(this.right,this.forward,this.up),this.up),Z.scale(this.forward,-this.distance,this.position)}tick(t){this.dragged||(this.eulers[1]-=this.velocity[1],this.eulers[2]-=this.velocity[0]),S.scale(this.velocity,.96*(1-t),this.velocity),this.update()}screen_to_ray(t,e,r,n){const i=(t-r/2)/r,o=(e-n/2)/-n;let s=Z.create();return Z.add(s,this.forward,s),Z.add(s,Z.scale(this.right,i),s),Z.add(s,Z.scale(this.up,o),s),new tt(this.position,s)}}const ot=document.getElementById("canv"),st=document.getElementById("fps"),at=(document.getElementById("kloppenheim_02"),document.getElementById("slice-canvas")),ct=new class{constructor(){this.grid_size=9,this.voxel_count=24,this.ao_strength=.8,this.ambient_light=.2,this.grid=new Array(this.grid_size*this.grid_size*this.grid_size),this.meta_grid=new Array(this.grid_size*this.grid_size*this.grid_size),this.boundary_min=[-this.grid_size/2,-this.grid_size/2,-this.grid_size/2],this.boundary_max=[this.grid_size/2,this.grid_size/2,this.grid_size/2],this.voxel_size=this.grid_size/this.voxel_count,this.initialize_grid(),this.direct_light=Z.normalize([1.5,.6,3]),this.direct_light_brightness=1,this.background_color=[0,0,0],this.input_direct_light=document.getElementById("sun_strength"),this.input_direct_light.addEventListener("input",(t=>{this.direct_light_brightness=parseInt(this.input_direct_light.value)/50})),this.input_direct_light_phi=document.getElementById("sun_phi"),this.input_direct_light_theta=document.getElementById("sun_theta"),this.input_direct_light_phi.addEventListener("input",(t=>{this.updateDirectLight(parseInt(this.input_direct_light_phi.value),parseInt(this.input_direct_light_theta.value))})),this.input_direct_light_theta.addEventListener("input",(t=>{this.updateDirectLight(parseInt(this.input_direct_light_phi.value),parseInt(this.input_direct_light_theta.value))})),this.input_ao_strength=document.getElementById("ao_strength"),this.input_ao_strength.addEventListener("input",(t=>{this.ao_strength=parseInt(this.input_ao_strength.value)/100})),this.input_ambient_light=document.getElementById("ambient_light"),this.input_ambient_light.addEventListener("input",(t=>{this.ambient_light=parseInt(this.input_ambient_light.value)/100}))}updateDirectLight(t,e){this.direct_light=[Math.cos($(e))*Math.cos($(t)),Math.sin($(e))*Math.cos($(t)),Math.sin($(t))]}serialize_scene(){return JSON.stringify(this)}deserialize_scene(t){const e=JSON.parse(t);this.grid=e.grid,this.background_color=e.background_color,this.grid_size=this.grid_size,this.boundary_min=e.boundary_min,this.boundary_max=e.boundary_max,this.voxel_count=e.voxel_count,this.direct_light=e.direct_light,this.direct_light_brightness=e.direct_light_brightness,this.input_direct_light.value=(100*e.direct_light_brightness).toString(),this.ao_strength=e.ao_strength,this.ambient_light=e.ambient_light}initialize_grid(){this.grid=new Array(this.voxel_count**3),this.meta_grid=new Array(this.voxel_count**3);for(let t=0;t<this.voxel_count;t++)for(let e=0;e<this.voxel_count;e++)for(let r=0;r<this.voxel_count;r++){let n=new rt;n.color=[0,0,0],n.opacity=0,this.grid[r*this.voxel_count*this.voxel_count+e*this.voxel_count+t]=n;let i=new nt;this.meta_grid[r*this.voxel_count*this.voxel_count+e*this.voxel_count+t]=i}}initialize_default_grid(){for(let t=0;t<this.voxel_count;t++)for(let e=0;e<this.voxel_count;e++)for(let r=0;r<this.voxel_count;r++){let n=new rt;r<3&&(n.color=[t/this.voxel_count,e/this.voxel_count,r/this.voxel_count],Z.scale(n.color,2,n.color),n.opacity=1,n.lightness=0,n.roughness=1),Z.dist([t,e,r],[this.voxel_count/2,this.voxel_count/2,this.voxel_count/2])<5&&(n.opacity=1,n.color=[.2,e/this.voxel_count+.3,r/this.voxel_count+.3],Z.scale(n.color,2,n.color),n.lightness=0,n.roughness=1),(t==this.voxel_count-2||e<2)&&(n.color=[t/this.voxel_count,e/this.voxel_count,r/this.voxel_count],n.opacity=1,n.roughness=.3),n.color[0]=Math.min(1,n.color[0]),n.color[1]=Math.min(1,n.color[1]),n.color[2]=Math.min(1,n.color[2]),this.set_voxel_comp(n,t,e,r)}this.calc_gi()}calc_gi(){for(let t=0;t<this.voxel_count;t++)for(let e=0;e<this.voxel_count;e++)for(let r=0;r<this.voxel_count;r++){const n=new tt(this.get_voxel_center([t,e,r]),Z.inverse(this.direct_light));this.ray_any(n)||(this.meta_grid[this.get_voxel_id([t,e,r])].gi=Z.scale([1,1,1],this.direct_light_brightness))}}ray_any(t){let e=0,r=1/0;for(let n=0;n<3;n++){let i=(this.boundary_min[n]-t.origin[n])*t.inv_direction[n],o=(this.boundary_max[n]-t.origin[n])*t.inv_direction[n];e=Math.min(Math.max(i,e),Math.max(o,e)),r=Math.max(Math.min(i,r),Math.min(o,r))}if(e>r)return;const n=Z.add(t.origin,Z.scale(t.direction,e)),i=Z.add(t.origin,Z.scale(t.direction,r));let o=[Math.max(0,Math.min(this.voxel_count-1,Math.floor((n[0]-this.boundary_min[0])/this.voxel_size))),Math.max(0,Math.min(this.voxel_count-1,Math.floor((n[1]-this.boundary_min[1])/this.voxel_size))),Math.max(0,Math.min(this.voxel_count-1,Math.floor((n[2]-this.boundary_min[2])/this.voxel_size)))],s=[o[0]+1,o[1]+1,o[2]+1],a=[0,0,0],c=[0,0,0],l=[0,0,0],u=[0,0,0],h=e,_=[0,0,0];for(let h=0;h<3;h++)u[h]=Math.max(0,Math.min(this.voxel_count-1,Math.floor((i[h]-this.boundary_min[h])/this.voxel_size))),t.direction[h]>0?(a[h]=1,l[h]=this.voxel_size/t.direction[h],c[h]=e+(this.boundary_min[h]+s[h]*this.voxel_size-n[h])/t.direction[h]):t.direction[h]<0?(a[h]=-1,l[h]=this.voxel_size/-t.direction[h],c[h]=e+(this.boundary_min[h]+o[h]*this.voxel_size-n[h])/t.direction[h]):(a[h]=0,l[h]=r,c[h]=r);for(;o[0]<this.voxel_count&&o[0]>=0&&o[1]<this.voxel_count&&o[1]>=0&&o[2]<this.voxel_count&&o[2]>=0;){if(this.get_voxel(o).opacity>.01){const e=Z.add(t.origin,Z.scale(t.direction,h));return new et(e,o,this.get_voxel(o),_)}c[0]<c[1]&&c[0]<c[2]?(o[0]+=a[0],h=c[0],c[0]+=l[0],_=[-a[0],0,0]):c[1]<c[2]?(o[1]+=a[1],h=c[1],c[1]+=l[1],_=[0,-a[1],0]):(o[2]+=a[2],h=c[2],c[2]+=l[2],_=[0,0,-a[2]])}}get_voxel_center(t){return[t[0]*this.voxel_size-this.boundary_min[0],t[1]*this.voxel_size-this.boundary_min[1],t[2]*this.voxel_size-this.boundary_min[2]]}get_voxel_id_comp(t,e,r){return r*this.voxel_count*this.voxel_count+e*this.voxel_count+t}get_voxel_id(t){return t[2]*this.voxel_count*this.voxel_count+t[1]*this.voxel_count+t[0]}get_voxel_comp(t,e,r){return this.grid[r*this.voxel_count*this.voxel_count+e*this.voxel_count+t]}get_voxel(t){return this.grid[t[2]*this.voxel_count*this.voxel_count+t[1]*this.voxel_count+t[0]]}set_voxel(t,e){e[0]>0&&e[0]<this.voxel_count-1&&e[1]>0&&e[1]<this.voxel_count-1&&e[2]>0&&e[2]<this.voxel_count-1&&(this.grid[e[2]*this.voxel_count*this.voxel_count+e[1]*this.voxel_count+e[0]]=t)}set_voxel_comp(t,e,r,n){e>0&&e<this.voxel_count-1&&r>0&&r<this.voxel_count-1&&n>0&&n<this.voxel_count-1&&(this.grid[n*this.voxel_count*this.voxel_count+r*this.voxel_count+e]=t)}};let lt=new class{constructor(t,e,r,n,i){this.mouse_down=!1,this.mouse_dragged=!1,this.over_canvas=!1,this.last_move=0,this.velocity=[0,0],this.selected_color=[0,0,0],this.selected_roughness=1,this.selected_opacity=1,this.selected_lightness=0,this.camera=new it(r,n,i),this.last_move=performance.now(),this.last_movement=[0,0],this.scene=t,this.canvas=e,this.selected_tool="place",this.blub_high=document.getElementById("blub_high"),this.blub_low=document.getElementById("blub_low"),this.setup()}tick(t){this.camera.tick(t)}setup(){var t,e,r,n,i,o,s;this.canvas.addEventListener("mouseover",(t=>{this.over_canvas=!0})),this.canvas.addEventListener("mouseout",(t=>{this.over_canvas=!1})),addEventListener("mousedown",(t=>{this.over_canvas&&0==t.button&&(this.mouse_down=!0,this.mouse_dragged=!1,this.camera.dragged=!0,this.last_move=performance.now())})),addEventListener("mouseup",(t=>{if(0==t.button&&(this.mouse_down&&(this.camera.velocity=[...this.velocity]),this.mouse_down=!1,this.camera.dragged=!1,!this.mouse_dragged)){const e=this.canvas.getBoundingClientRect(),r=t.clientX-e.left,n=t.clientY-e.top;let i=this.scene.ray_any(this.camera.screen_to_ray(r,n,e.width,e.height));if(i)switch(this.selected_tool){case"place":let t=new rt;t.color=this.selected_color,t.roughness=this.selected_roughness,t.lightness=this.selected_lightness,t.opacity=this.selected_opacity,this.scene.set_voxel(t,i.voxel_position.map(((t,e)=>t+i.normal[e]))),this.blub_high.play();break;case"replace":let e=new rt;e.color=this.selected_color,e.roughness=this.selected_roughness,e.lightness=this.selected_lightness,e.opacity=this.selected_opacity,this.scene.set_voxel(e,i.voxel_position),this.blub_high.play();break;case"remove":let r=new rt;r.opacity=0,this.scene.set_voxel(r,i.voxel_position),this.blub_low.play()}}})),addEventListener("mousemove",(t=>{this.last_movement=S.scale([t.movementX,t.movementY],.2),this.mouse_down&&this.mouse_drag(t),this.calculate_velocity(),this.last_move=performance.now()})),null===(t=document.getElementById("color_value"))||void 0===t||t.addEventListener("input",(t=>{var e;const r=t.target.value;this.selected_color=Z.scale(null===(e=r.match(/\w\w/g))||void 0===e?void 0:e.map((t=>parseInt(t,16))),1/255)})),null===(e=document.getElementById("roughness_value"))||void 0===e||e.addEventListener("input",(t=>{this.selected_roughness=1-parseInt(t.target.value)/100})),null===(r=document.getElementById("lightness_value"))||void 0===r||r.addEventListener("input",(t=>{this.selected_lightness=parseInt(t.target.value)/25})),null===(n=document.getElementById("opacity_value"))||void 0===n||n.addEventListener("input",(t=>{this.selected_opacity=parseInt(t.target.value)/100})),null===(i=document.getElementById("tool-place-button"))||void 0===i||i.addEventListener("change",(t=>{this.selected_tool="place"})),null===(o=document.getElementById("tool-replace-button"))||void 0===o||o.addEventListener("change",(t=>{this.selected_tool="replace"})),null===(s=document.getElementById("tool-remove-button"))||void 0===s||s.addEventListener("change",(t=>{this.selected_tool="remove"}))}calculate_velocity(){const t=performance.now()-this.last_move;S.scale(this.last_movement,1/t,this.velocity)}mouse_drag(t){this.camera.eulers[1]=this.camera.eulers[1]-this.last_movement[1],this.camera.eulers[2]=this.camera.eulers[2]-this.last_movement[0],this.mouse_dragged=!0}}(ct,ot,12,0,0),ut=new class{constructor(t,e,r){this.initialized=!1,this.render=()=>{var t,e,r,n,i,o,s;if(!this.initialized)return;let a=[];for(let t=0;t<this.scene.voxel_count;t++)for(let e=0;e<this.scene.voxel_count;e++)for(let r=0;r<this.scene.voxel_count;r++)this.scene.get_voxel([t,e,r]).lightness>0&&a.push([t,e,r]);null===(t=this.device)||void 0===t||t.queue.writeBuffer(this.sceneParameters,0,new Float32Array([this.camera.position[0],this.camera.position[1],this.camera.position[2],(new Date).getMilliseconds(),this.camera.forward[0],this.camera.forward[1],this.camera.forward[2],a.length,this.camera.right[0],this.camera.right[1],this.camera.right[2],this.scene.ao_strength,this.camera.up[0],this.camera.up[1],this.camera.up[2],this.scene.ambient_light,this.scene.direct_light[0],this.scene.direct_light[1],this.scene.direct_light[2],this.scene.direct_light_brightness,this.scene.background_color[0],this.scene.background_color[1],this.scene.background_color[2],0]),0,24);const c=new Float32Array(4*a.length);for(let t=0;t<a.length;++t)c[4*t]=a[t][0],c[4*t+1]=a[t][1],c[4*t+2]=a[t][2],c[4*t+3]=0;null===(e=this.device)||void 0===e||e.queue.writeBuffer(this.lightData,0,c,0,4*a.length);const l=new Float32Array(8*this.scene.grid.length);for(let t=0;t<this.scene.grid.length;++t)l[8*t]=this.scene.grid[t].color[0],l[8*t+1]=this.scene.grid[t].color[1],l[8*t+2]=this.scene.grid[t].color[2],l[8*t+3]=this.scene.grid[t].opacity,l[8*t+4]=this.scene.grid[t].roughness,l[8*t+5]=this.scene.grid[t].lightness,l[8*t+6]=0,l[8*t+7]=0;const u=new Float32Array(8*this.scene.grid.length);for(let t=0;t<this.scene.grid.length;++t)u[8*t]=this.scene.meta_grid[t].gi[0],u[8*t+1]=this.scene.meta_grid[t].gi[1],u[8*t+2]=this.scene.meta_grid[t].gi[2],u[8*t+3]=0,u[8*t+4]=0,u[8*t+5]=0,u[8*t+6]=0,u[8*t+7]=0;null===(r=this.device)||void 0===r||r.queue.writeBuffer(this.sceneData,0,l,0,8*this.scene.grid.length),null===(n=this.device)||void 0===n||n.queue.writeBuffer(this.sceneMetaData,0,u,0,8*this.scene.grid.length);const h=null===(i=this.device)||void 0===i?void 0:i.createCommandEncoder(),_=null==h?void 0:h.beginComputePass();null==_||_.setPipeline(this.ray_tracing_pipeline),null==_||_.setBindGroup(0,this.ray_tracing_bind_group),null==_||_.dispatchWorkgroups(this.canvas.width/16,this.canvas.height/16,1),null==_||_.end();const d=null===(o=this.context)||void 0===o?void 0:o.getCurrentTexture().createView(),v=null==h?void 0:h.beginRenderPass({colorAttachments:[{view:d,clearValue:{r:.5,g:0,b:.25,a:1},loadOp:"clear",storeOp:"store"}]});null==v||v.setPipeline(this.screen_pipeline),null==v||v.setBindGroup(0,this.screen_bind_group),null==v||v.draw(6,1,0,0),null==v||v.end(),null===(s=this.device)||void 0===s||s.queue.submit([null==h?void 0:h.finish()])},this.canvas=t,this.scene=e,this.pathtracing=!1,this.camera=r}initialize(t){return e(this,void 0,void 0,(function*(){this.pathtracing=t,yield this.setupDevice(),yield this.createAssets(),yield this.setupPipeline(),this.initialized=!0}))}set_hdr(t){}shutdown(){var t,e,r;this.initialized=!1,null===(t=this.device)||void 0===t||t.destroy(),null===(e=this.color_buffer)||void 0===e||e.destroy(),null===(r=this.secondary_buffer)||void 0===r||r.destroy()}setupDevice(){var t,r;return e(this,void 0,void 0,(function*(){this.adapter=yield null===(t=navigator.gpu)||void 0===t?void 0:t.requestAdapter(),this.device=yield null===(r=this.adapter)||void 0===r?void 0:r.requestDevice(),this.context=this.canvas.getContext("webgpu"),this.format="bgra8unorm",this.context.configure({device:this.device,format:this.format,alphaMode:"opaque"})}))}createAssets(){var t,r,n,i,o,s,a,c,l;return e(this,void 0,void 0,(function*(){this.color_buffer=null===(t=this.device)||void 0===t?void 0:t.createTexture({size:{width:this.canvas.width,height:this.canvas.height},format:"rgba8unorm",usage:GPUTextureUsage.COPY_DST|GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.TEXTURE_BINDING}),this.secondary_buffer=null===(r=this.device)||void 0===r?void 0:r.createTexture({size:{width:this.canvas.width,height:this.canvas.height},format:"rgba8unorm",usage:GPUTextureUsage.COPY_DST|GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.TEXTURE_BINDING}),this.color_buffer_view=null===(n=this.color_buffer)||void 0===n?void 0:n.createView(),this.secondary_buffer_view=null===(i=this.secondary_buffer)||void 0===i?void 0:i.createView(),this.sampler=null===(o=this.device)||void 0===o?void 0:o.createSampler({addressModeU:"repeat",addressModeV:"repeat",magFilter:"linear",minFilter:"nearest",mipmapFilter:"nearest",maxAnisotropy:1}),this.sceneParameters=null===(s=this.device)||void 0===s?void 0:s.createBuffer({size:96,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST});const e=this.scene.voxel_count*this.scene.voxel_count*this.scene.voxel_count;this.sceneData=null===(a=this.device)||void 0===a?void 0:a.createBuffer({size:8*e*4,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),this.sceneMetaData=null===(c=this.device)||void 0===c?void 0:c.createBuffer({size:8*e*4,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),this.lightData=null===(l=this.device)||void 0===l?void 0:l.createBuffer({size:512,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST})}))}setupPipeline(){var r,n,i,o,s,a,c,l;return e(this,void 0,void 0,(function*(){const e=null===(r=this.device)||void 0===r?void 0:r.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,storageTexture:{access:"write-only",format:"rgba8unorm",viewDimension:"2d"}},{binding:1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},{binding:2,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:3,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:4,visibility:GPUShaderStage.COMPUTE,storageTexture:{access:"write-only",format:"rgba8unorm",viewDimension:"2d"}},{binding:5,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}}]});this.ray_tracing_bind_group=null===(n=this.device)||void 0===n?void 0:n.createBindGroup({layout:e,label:"Ray tracing bind group",entries:[{binding:0,resource:this.color_buffer_view},{binding:1,resource:{buffer:this.sceneParameters}},{binding:2,resource:{buffer:this.sceneData}},{binding:3,resource:{buffer:this.lightData}},{binding:4,resource:this.secondary_buffer_view},{binding:5,resource:{buffer:this.sceneMetaData}}]});const u=null===(i=this.device)||void 0===i?void 0:i.createPipelineLayout({bindGroupLayouts:[e]});this.ray_tracing_pipeline=null===(o=this.device)||void 0===o?void 0:o.createComputePipeline({label:"Ray tracing pipeline",layout:u,compute:{entryPoint:"main",module:this.device.createShaderModule({code:"@group(0) @binding(0) var color_buffer: texture_storage_2d<rgba8unorm, write>;\r\n@group(0) @binding(1) var<uniform> scene: SceneParameter;\r\n@group(0) @binding(2) var<storage, read> scene_data: SceneData;\r\n// @group(0) @binding(3) var hdr_tex: texture_2d<f32>;\r\n// @group(0) @binding(4) var hdr_sampler: sampler;\r\n@group(0) @binding(3) var<storage, read> lights: LightData;\r\n@group(0) @binding(4) var secondary_buffer: texture_storage_2d<rgba8unorm, write>;\r\n@group(0) @binding(5) var<storage, read> scene_meta_data: SceneMetaData;\r\n\r\noverride grid_size: f32 = 2f;\r\noverride voxel_count: i32 = 4;\r\nvar<private> voxel_size: f32 = grid_size / f32(voxel_count);\r\nvar<private> boundary_min: vec3<f32> = vec3<f32>(f32(-grid_size) / 2, f32(-grid_size) / 2, f32(-grid_size) / 2);\r\nvar<private> boundary_max: vec3<f32> = vec3<f32>(f32(grid_size) / 2, f32(grid_size) / 2, f32(grid_size) / 2);\r\nvar<private> depth_clip_min: f32 = 1f;\r\nvar<private> depth_clip_max: f32 = 10f;\r\n\r\nvar<private> rng_seed: u32;\r\nvar<private> rng_seed_steady: u32;\r\n\r\nconst samples: i32 = 1;\r\nconst light_bounces: i32 = 3;\r\nconst max_penetrations: i32 = 3;\r\nconst reflection_bounces: i32 = 3;\r\nconst scatter: i32 = 5;\r\n// const ambient_light: f32 = 0.03;\r\nconst pi = 3.14159265359;\r\n\r\n// const background: vec3<f32> = vec3<f32>(24f / 255f, 24f / 255f, 37f / 255f);\r\n\r\nstruct SceneParameter {\r\n    camera_pos: vec3<f32>,\r\n    rng_start: f32,\r\n    camera_forward: vec3<f32>,\r\n    light_count: f32,\r\n    camera_right: vec3<f32>,\r\n\tao_strength: f32,\r\n    camera_up: vec3<f32>,\r\n\tambient_light: f32,\r\n    direct_light: vec3<f32>,\r\n    direct_light_brightness: f32,\r\n\tbackground_color: vec3<f32>,\r\n}\r\n\r\nstruct Voxel {\r\n\tcolor: vec3<f32>,\r\n\topacity: f32,\r\n\troughness: f32,\r\n\tlightness: f32,\r\n}\r\n\r\nstruct MetaVoxel {\r\n\tgi: vec3<f32>,\r\n\tsomethingelse: vec3<f32>\r\n}\r\n\r\nstruct SceneData {\r\n\tdata: array<Voxel>,\r\n}\r\n\r\nstruct SceneMetaData {\r\n\tdata: array<MetaVoxel>,\r\n}\r\n\r\nstruct LightData {\r\n\tdata: array<Light>,\r\n}\r\n\r\nstruct Light {\r\n\tlocation: vec3<f32>,\r\n\temitter_type: f32,\r\n}\r\n\r\nstruct Ray {\r\n    origin: vec3<f32>,\r\n    direction: vec3<f32>,\r\n    inv_direction: vec3<f32>,\r\n}\r\n\r\nstruct RayHit {\r\n\tposition: vec3<f32>,\r\n\tdepth: f32,\r\n\tvoxel_position: vec3<i32>,\r\n\tvoxel: Voxel,\r\n\tnormal: vec3<f32>,\r\n\tray_direction: vec3<f32>,\r\n\texit_position: vec3<f32>,\r\n\tao: f32,\r\n\tuv: vec2<f32>,\r\n}\r\n\r\nstruct TraceResult {\r\n\tcolor: vec3<f32>,\r\n\tao: f32,\r\n}\r\n\r\n@compute @workgroup_size(16,16,1)\r\nfn main(@builtin(global_invocation_id) GlobalInvocationID : vec3<u32>) {\r\n    let screen_size: vec2<u32> = textureDimensions(color_buffer);\r\n    let screen_pos : vec2<i32> = vec2<i32>(i32(GlobalInvocationID.x), i32(GlobalInvocationID.y));\r\n    // rng_seed = GlobalInvocationID.x + 50 + (GlobalInvocationID.y + 50) * (GlobalInvocationID.x + 100) * 1000 * u32(scene.rng_start);\r\n    rng_seed = GlobalInvocationID.x + 50 + (GlobalInvocationID.y + 50) * (GlobalInvocationID.x + 100) * 1000;\r\n    rng_seed_steady = GlobalInvocationID.x + 150 + (GlobalInvocationID.y + 75) * (GlobalInvocationID.x + 350) * 1000;\r\n\r\n    var pixel_color: vec3<f32>;\r\n    var pixel_ao: f32;\r\n    for (var i = 0; i < samples; i++){\r\n\r\n\t    let rng_offset: vec2<f32> = select(vec2<f32>(0), vec2<f32>(rng() - 0.5, rng() - 0.5), samples > 1);\r\n\t    let horizontal_coefficient: f32 = (f32(screen_pos.x) + rng_offset.x - f32(screen_size.x) / 2) / f32(screen_size.x);\r\n\t    let vertical_coefficient: f32 = (f32(screen_pos.y) + rng_offset.y - f32(screen_size.y) / 2) / -f32(screen_size.y);\r\n\r\n\t    let ray_direction = normalize(scene.camera_forward\r\n\t\t\t    + horizontal_coefficient * scene.camera_right\r\n\t\t\t    + vertical_coefficient * scene.camera_up);\r\n\t    let ray: Ray = Ray(scene.camera_pos, ray_direction, 1 / ray_direction);\r\n\t    let trace_result = trace(ray, light_bounces);\r\n\t    // pixel_color += trace(ray, light_bounces);\r\n\t    // pixel_color += trace_result.color;\r\n\t    pixel_color += trace_result;\r\n\t    // pixel_ao += trace_result.ao;\r\n    }\r\n\r\n    // let correction = 1.0 / f32(samples);\r\n    // pixel_color = sqrt(correction * pixel_color);\r\n\r\n\tpixel_color /= f32(samples);\r\n\t// pixel_ao /= f32(samples);\r\n\r\n    /* pixel_color = textureSampleLevel(hdr_tex, hdr_sampler, vec2<f32>(f32(GlobalInvocationID.x) / f32(screen_size.x), f32(GlobalInvocationID.y) / f32(screen_size.y) * 2), 0.0).rgb; */\r\n\r\n    textureStore(color_buffer, screen_pos, vec4<f32>(pixel_color, 1.0));\r\n    // textureStore(secondary_buffer, screen_pos, vec4<f32>(pixel_ao, 0, 0, 1.0));\r\n}\r\n\r\nfn rng_hash(seed: u32) -> u32 {\r\n\tvar x = ( seed << 10u );\r\n\tx ^= ( x >>  6u );\r\n\tx += ( x <<  3u );\r\n\tx ^= ( x >> 11u );\r\n\tx += ( x << 15u );\r\n\treturn x;\r\n}\r\n\r\nfn rng() -> f32 {\r\n\trng_seed++;\r\n\treturn bitcast<f32>((rng_hash(rng_seed) >> 9) | 0x3f800000 ) - 1.0;\r\n}\r\n\r\nfn rng_steady() -> f32 {\r\n\trng_seed_steady++;\r\n\treturn bitcast<f32>((rng_hash(rng_seed_steady) >> 9) | 0x3f800000 ) - 1.0;\r\n}\r\n\r\nfn ray_reflect(ray: Ray, position: vec3<f32>, normal: vec3<f32>) -> Ray {\r\n\tlet reflect = ray.direction - 2 * dot(ray.direction, normal) * normal;\r\n\treturn Ray(position, reflect, 1 / reflect);\r\n}\r\n\r\nfn get_voxel_id(v: vec3<i32>) -> i32 {\r\n\treturn v.z * voxel_count * voxel_count + v.y * voxel_count + v.x;\r\n}\r\n\r\nfn get_voxel(v: vec3<i32>) -> Voxel {\r\n\treturn scene_data.data[v.z * voxel_count * voxel_count + v.y * voxel_count + v.x];\r\n}\r\n\r\nfn get_meta_voxel(v: vec3<i32>) -> MetaVoxel {\r\n\treturn scene_meta_data.data[v.z * voxel_count * voxel_count + v.y * voxel_count + v.x];\r\n}\r\n\r\nfn get_voxel_by_position(v: vec3<f32>) -> Voxel {\r\n\treturn get_voxel(vec3<i32>((v - boundary_min) / f32(voxel_size)));\r\n}\r\n\r\nfn sample_spherical_map(v: vec3<f32>) -> vec2<f32> {\r\n\tlet theta = atan2(v.x, v.y);\r\n\tlet phi = acos(v.z);\r\n\tlet raw_u = theta / (2 * pi);\r\n\tlet uv = vec2<f32>(\r\n\t\t1 - (raw_u + 0.5),\r\n\t\tphi / pi\r\n\t);\r\n\treturn uv;\r\n}\r\n\r\nfn random_unit_vector() -> vec3<f32> {\r\n\tlet phi = rng() * pi * 2;\r\n\tlet costheta = rng() * 2 - 1;\r\n\t\tlet theta = acos(costheta);\r\n\tlet x = sin(theta) * cos(phi);\r\n\tlet y = sin(theta) * sin(phi);\r\n\tlet z = cos(theta);\r\n\treturn vec3<f32>(x, y, z);\r\n}\r\n"+(this.pathtracing?"const light_scatter_samples: i32 = 2;\r\n\r\nfn gamma_correct(color: vec3<f32>) -> vec3<f32> {\r\n    let correction = 1.0 / f32(samples);\r\n    return sqrt(correction * color);\r\n}\r\n\r\nfn trace(ray: Ray, depth: i32) -> vec3<f32> {\r\n\tif (depth <= 0) {\r\n\t\treturn vec3<f32>(0);\r\n\t}\r\n\t\tvar accum: vec3<f32> = vec3<f32>(0.0);\r\n\t\tvar mask: vec3<f32> = vec3<f32>(1.0);\r\n\t\tvar curr_ray: Ray = ray;\r\n\t\tvar curr_hit: RayHit;\r\n\t\tvar refl: f32 = 1.0;\r\n\t\tvar hits: i32 = 0;\r\n\r\n\t\tvar bounce_results: array<RayHit, light_bounces>;\r\n\r\n\t\tfor (; hits < light_bounces;){\r\n\t\t\tif (voxel_ray_any(curr_ray, 0.0001, &curr_hit)) {\r\n\t\t\t\tlet bounce_direction = random_unit_vector() + curr_hit.normal;\r\n\t\t\t\tif (all(bounce_direction == vec3<f32>(0))){\r\n\t\t\t\t\tcurr_ray = Ray(curr_hit.position, curr_hit.normal, 1 / curr_hit.normal);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tlet normalized = normalize(bounce_direction);\r\n\t\t\t\t\tcurr_ray = Ray(curr_hit.position, normalized, 1 / normalized);\r\n\t\t\t\t}\r\n\t\t\t\tbounce_results[hits] = curr_hit;\r\n\t\t\t\thits++;\r\n\t\t\t} else {\r\n\t\t\t\t// accum = pow(textureSampleLevel(hdr_tex, hdr_sampler, sample_spherical_map(curr_ray.direction), 0.0).rgb, vec3<f32>(2)) * 5;\r\n\t\t\t\taccum = vec3<f32>(pow(max(0, dot(curr_ray.direction, scene.direct_light) - 0.98) * 40, 1));\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (hits == 0){\r\n\t\t\t// return textureSampleLevel(hdr_tex, hdr_sampler, sample_spherical_map(ray.direction), 0.0).rgb;\r\n\t\t\treturn vec3<f32>(pow(max(0, dot(ray.direction, scene.direct_light) - 0.95) * 20, 1));\r\n\t\t}\r\n\t\tif (hits == light_bounces){\r\n\t\t\taccum = vec3<f32>(0, 0, 0);\r\n\t\t} else {\r\n\t\t\t// accum = textureSampleLevel(hdr_tex, hdr_sampler, sample_spherical_map(bounce_results[hits - 1].ray_direction), 0.0).rgb;\r\n\t\t\t/* accum = vec3<f32>(max(0, dot(bounce_results[hits - 1].ray_direction, scene.direct_light))); */\r\n\t\t\t// accum = vec3<f32>(0);\r\n\t\t}\r\n\t\tfor (var i: i32 = hits - 1; i >= 0; i--){\r\n\t\t\tlet bounce = bounce_results[i];\r\n\t\t\t/* accum = min(vec3<f32>(1), accum) * min(vec3<f32>(1), bounce.voxel.color); */\r\n\t\t\taccum = accum * bounce.voxel.color\r\n\t\t\t\t+ bounce_results[i].voxel.lightness * bounce_results[i].voxel.color;\r\n\t\t\t// if (all(bounce.normal == vec3<f32>(0)) && all(bounce.ray_direction == vec3<f32>(0))){\r\n\t\t\t// \t// accum = textureSampleLevel(hdr_tex, hdr_sampler, sample_spherical_map(bounce_results[i].ray_direction), 0.0).rgb;\r\n\t\t\t// \taccum = vec3<f32>(0.5);\r\n\t\t\t// \tcontinue;\r\n\t\t\t// }\r\n\t\t\t// accum = accum * bounce.voxel.color;\r\n\t\t\t// accum = accum * bounce.voxel.color;\r\n\t\t}\r\n\treturn accum; // / f32(light_scatter_samples);\r\n}\r\n\r\nfn direct_illumination(orig_hit: RayHit, refl: ptr<function, f32>) -> vec3<f32> {\r\n\tvar hit: RayHit;\r\n\tif (!voxel_ray_any(Ray(orig_hit.position, scene.direct_light, 1 / scene.direct_light), 0.00001, &hit)){\r\n\t\treturn scene.direct_light_brightness * orig_hit.voxel.color;\r\n\t} else {\r\n\t\treturn 0.2 * orig_hit.voxel.color;\r\n\t}\r\n}\r\n\r\nfn voxel_ray_any(ray: Ray, start_tolerance: f32, hit: ptr<function, RayHit>) -> bool {\r\n\tvar tmin: f32 = 0.0;\r\n\tvar tmax: f32 = 300000000;\r\n\tfor (var d: i32 = 0; d < 3; d++) {\r\n\t\tlet t1 = (boundary_min[d] - ray.origin[d]) * ray.inv_direction[d];\r\n\t\tlet t2 = (boundary_max[d] - ray.origin[d]) * ray.inv_direction[d];\r\n\r\n\t\ttmin = min(max(t1, tmin), max(t2, tmin));\r\n\t\ttmax = max(min(t1, tmax), min(t2, tmax));\r\n\t}\r\n\t// Hier ist noch ein Fehler drin, tritt nur von ausserhalb des grid auf, das kommt ja vielleicht eh noch weg\r\n\tif tmin > tmax { return false; }\r\n    \tlet ray_entry = ray.origin + ray.direction * tmin;\r\n\tlet ray_exit = ray.origin + ray.direction * tmax;\r\n\r\n\tvar voxel: vec3<i32> = max(vec3<i32>(0), min(vec3<i32>(voxel_count - 1), vec3<i32>((ray_entry - boundary_min) / f32(voxel_size))));\r\n\t//var end_voxel: vec3<i32> = max(vec3<i32>(0), min(vec3<i32>(voxel_count - 1), vec3<i32>((ray_exit - boundary_min - ray.direction * 0.000001) / f32(voxel_size))));\r\n\r\n\tlet direction_zeros: vec3<bool> = ray.direction == vec3<f32>(0);\r\n\tlet step: vec3<i32> = vec3<i32>(sign(ray.direction));\r\n\tlet tdelta: vec3<f32> = select(voxel_size / abs(ray.direction), vec3<f32>(tmax), direction_zeros);\r\n\tlet voxel_boundary: vec3<f32> = vec3<f32>(voxel + max(vec3<i32>(0), step)) * voxel_size;\r\n\tvar tmax_comp: vec3<f32> = select(tmin + (boundary_min + voxel_boundary - ray_entry) / ray.direction, vec3<f32>(tmax), direction_zeros);\r\n\tvar thit: f32 = tmin;\r\n\tvar hit_normal: vec3<f32> = vec3<f32>(0, 0, 0);\r\n\r\n\twhile(all(voxel >= vec3<i32>(0)) && all(voxel < vec3<i32>(voxel_count))) {\r\n\t\tlet hit_voxel = get_voxel(voxel);\r\n\t\tif (hit_voxel.opacity > 0.01 && all(tmax_comp > vec3<f32>(start_tolerance))){\r\n\t\t\t(*hit).position = ray.origin + ray.direction * thit;\r\n\t\t\t(*hit).voxel = hit_voxel;\r\n\t\t\t(*hit).voxel_position = voxel;\r\n\t\t\t(*hit).depth = 1 - (thit - depth_clip_min) / (depth_clip_max - depth_clip_min);\r\n\t\t\t(*hit).normal = hit_normal;\r\n\t\t\t(*hit).ray_direction = ray.direction;\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\tif (tmax_comp.x < tmax_comp.y && tmax_comp.x < tmax_comp.z) {\r\n\t\t\tvoxel.x += step.x;\r\n\t\t\tthit = tmax_comp.x;\r\n\t\t\ttmax_comp.x += tdelta.x;\r\n\t\t\thit_normal = vec3<f32>(f32(-step.x), 0, 0);\r\n\t\t} else if (tmax_comp.y < tmax_comp.z){\r\n\t\t\tvoxel.y += step.y;\r\n\t\t\tthit = tmax_comp.y;\r\n\t\t\ttmax_comp.y += tdelta.y;\r\n\t\t\thit_normal = vec3<f32>(0, f32(-step.y), 0);\r\n\t\t} else {\r\n\t\t\tvoxel.z += step.z;\r\n\t\t\tthit = tmax_comp.z;\r\n\t\t\ttmax_comp.z += tdelta.z;\r\n\t\t\thit_normal = vec3<f32>(0, 0, f32(-step.z));\r\n\t\t}\r\n\t}\r\n\r\n\treturn false;\r\n}\r\n":"struct penetration {\r\n\tcolor: vec3<f32>,\r\n\tao: f32,\r\n\thit: RayHit,\r\n}\r\n\r\nfn gamma_correct(color: vec3<f32>) -> vec3<f32> {\r\n    return color / f32(samples);\r\n}\r\n\r\nfn trace(ray: Ray, depth: i32) -> vec3<f32> {\r\n\tvar hit: RayHit;\r\n\tvar bounces: array<RayHit, reflection_bounces>;\r\n\tvar curr_ray = ray;\r\n\tvar hits: i32 = 0;\r\n\tvar has_next_ray = true;\r\n\tvar penetrations: array<penetration, max_penetrations>;\r\n\tvar penetration_count = 0;\r\n\r\n\tfor (var p = 0; p < max_penetrations; p++){\r\n\t\tvar color = vec3<f32>(0.0);\r\n\t\tvar ao = 0f;\r\n\t\tvar first_hit: RayHit;\r\n\t\tfor (var i = 0; i < reflection_bounces; i++){\r\n\t\t\tif(voxel_ray_any(curr_ray, 0.001, &hit)){\r\n\t\t\t\t// return TraceResult(vec3<f32>(hit.uv.x), 0.0);\r\n\t\t\t\tbounces[i] = hit;\r\n\t\t\t\tcurr_ray = ray_reflect(curr_ray, hit.position, hit.normal);\r\n\t\t\t\thits++;\r\n\t\t\t\tif (i == 0){\r\n\t\t\t\t\tfirst_hit = hit;\r\n\t\t\t\t}\r\n\t\t\t\tif (hit.voxel.roughness > 0.99){\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\t// return TraceResult(vec3<f32>(0.1), 0.0);\r\n\t\t\t\tcolor = scene.background_color;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (hits == 0){\r\n\t\t\tbreak;\r\n\t\t\t// return background;\r\n\t\t\t// return ray.direction;\r\n\t\t}\r\n\t\t// return vec3<f32>(0.2, 0.4, 0.5);\r\n\t\t// return vec3<f32>(bounces[0].uv.x, bounces[0].uv.y, 0.0);\r\n\r\n\t\tfor (var i: i32 = hits; i >= 0; i--){\r\n\t\t\t\t// return TraceResult(vec3<f32>(0.5), 0.0);\r\n\t\t\t// return TraceResult(vec3<f32>(bounces[i].uv.x), 0.0);\r\n\t\t\tlet t = bounces[i].voxel.roughness;\r\n\t\t\tcolor = color * (1 - t) + t * bounces[i].voxel.color * illumination(bounces[i].position);\r\n\t\t\tif (i == 0){\r\n\t\t\t\t//ao = get_point_ao(bounces[0].position);\r\n\t\t\t\tao = 0;\r\n\t\t\t\tlet nrm = vec3<i32>(bounces[i].normal);\r\n\t\t\t\tlet uv = bounces[i].uv;\r\n\t\t\t\tlet am = voxel_ao(bounces[i].voxel_position + nrm, nrm.zxy, nrm.yzx);\r\n\t\t\t\tao = mix(mix(am.z, am.w, uv.x), mix(am.y, am.x, uv.x), uv.y);\r\n\t\t\t\t// return vec3<f32>(uv.x / 10 + interp_ao, uv.y / 10 + interp_ao, interp_ao) / 2;\r\n\t\t\t\t// return vec3<f32>(interp_ao);\r\n\t\t\t\t// let interp_ao = \r\n\t\t\t\t// ao = get_point_ao_lambert(bounces[0].position, bounces[0].normal);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tfor (var l: i32 = 0; l < i32(scene.light_count); l++){\r\n\t\t\t\tlet light = lights.data[l];\r\n\t\t\t\tif i32(light.emitter_type) == 0 {\r\n\t\t\t\t\tlet light_voxel = get_voxel(vec3<i32>(light.location));\r\n\t\t\t\t\tlet light_voxel_location = light.location * voxel_size + boundary_min;\r\n\t\t\t\t\tlet light_voxel_location_top = light_voxel_location + voxel_size;\r\n\t\t\t\t\tlet light_voxel_location_mid = (light_voxel_location + light_voxel_location_top) / 2;\r\n\t\t\t\t\tlet lray_dir = light_voxel_location_mid - bounces[i].position;\r\n\t\t\t\t\tlet lray = Ray(bounces[i].position, lray_dir, 1 / lray_dir);\r\n\t\t\t\t\tvar lhit: RayHit;\r\n\t\t\t\t\tif (voxel_ray_any(lray, 0.001, &lhit) && all(lhit.voxel_position == vec3<i32>(light.location))){\r\n\t\t\t\t\t\tlet dist = distance(light_voxel_location_mid, bounces[i].position);\r\n\t\t\t\t\t\tlet intensity = 1 / pow(dist, 2) * lhit.voxel.lightness;\r\n\t\t\t\t\t\tcolor += light_voxel.color * vec3<f32>(intensity) * bounces[i].voxel.color;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// let vox = bounces[i].voxel_position;\r\n\t\t\t// let gi_vox = vox + vec3<i32>(bounces[i].normal);\r\n\t\t\t// color += get_meta_voxel(gi_vox).gi / 5;\r\n\t\t}\r\n\t\tpenetrations[p] = penetration(color, ao, first_hit);\r\n\t\tpenetration_count++;\r\n\t\tcurr_ray = Ray(first_hit.exit_position, ray.direction, ray.inv_direction);\r\n\t\tif (first_hit.voxel.opacity > 0.99){\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\r\n\tif (penetration_count == 0){\r\n\t\treturn scene.background_color;\r\n\t\t// return TraceResult(scene.background_color, 0);\r\n\t}\r\n\r\n\tvar color = penetrations[penetration_count - 1].color;\r\n\tvar ao = penetrations[penetration_count - 1].ao;\r\n\tfor (var i: i32 = penetration_count - 2; i >= 0; i--){\r\n\t\t// if (i > 0 && all(penetrations[i].voxel_color == penetrations[i - 1].voxel_color)) { continue;}\r\n\t\tlet pvoxel = penetrations[i].hit.voxel;\r\n\t\tlet phit = penetrations[i].hit;\r\n\t\tlet pcolor = penetrations[i].color;\r\n\t\tlet pao = penetrations[i].ao;\r\n\t\tlet t = pvoxel.opacity;\r\n\t\tif (i > 0 && all(penetrations[i - 1].hit.voxel.color == pvoxel.color)) { continue; }\r\n\t\tcolor = pcolor * t + (1 - t) * color;\r\n\t\tao = pao * t + (1 - t) * ao;\r\n\t\t// let t = distance(phit.position, phit.exit_position) / voxel_size;\r\n\t\t// color += pvoxel.color * t / f32(penetration_count);\r\n\t\t// color = pvoxel.color * t + color * (1 - t);\r\n\t\t// color = penetrations[i].color * pvoxel.opacity + color * (1 - pvoxel.opacity);\r\n\t\t// ao = penetrations[i].ao * pvoxel.opacity + ao * (1 - pvoxel.opacity);\r\n\t}\r\n\r\n\treturn color * ao;\r\n\t// return TraceResult(color, ao);\r\n\t// return vec3<f32>(ao);\r\n}\r\n\r\nfn illumination(p: vec3<f32>) -> f32 {\r\n\tvar hit: RayHit;\r\n\tif (!voxel_ray_any(Ray(p, scene.direct_light, 1 / scene.direct_light), 0.001, &hit)){\r\n\t\treturn max(scene.direct_light_brightness, scene.ambient_light);\r\n\t}\r\n\treturn scene.ambient_light;\r\n}\r\n\r\nfn voxel_ray_any(ray: Ray, start_tolerance: f32, hit: ptr<function, RayHit>) -> bool {\r\n\tvar tmin: f32 = 0.0;\r\n\tvar tmax: f32 = 300000000;\r\n\tfor (var d: i32 = 0; d < 3; d++) {\r\n\t\tlet t1 = (boundary_min[d] - ray.origin[d]) * ray.inv_direction[d];\r\n\t\tlet t2 = (boundary_max[d] - ray.origin[d]) * ray.inv_direction[d];\r\n\r\n\t\ttmin = min(max(t1, tmin), max(t2, tmin));\r\n\t\ttmax = max(min(t1, tmax), min(t2, tmax));\r\n\t}\r\n\t// Hier ist noch ein Fehler drin, tritt nur von ausserhalb des grid auf, das kommt ja vielleicht eh noch weg\r\n\tif tmin > tmax { return false; }\r\n    \tlet ray_entry = ray.origin + ray.direction * tmin;\r\n\tlet ray_exit = ray.origin + ray.direction * tmax;\r\n\r\n\tvar voxel: vec3<i32> = max(vec3<i32>(0), min(vec3<i32>(voxel_count - 1), vec3<i32>((ray_entry - boundary_min) / f32(voxel_size))));\r\n\t//var end_voxel: vec3<i32> = max(vec3<i32>(0), min(vec3<i32>(voxel_count - 1), vec3<i32>((ray_exit - boundary_min - ray.direction * 0.000001) / f32(voxel_size))));\r\n\r\n\tlet direction_zeros: vec3<bool> = ray.direction == vec3<f32>(0);\r\n\tlet vstep: vec3<i32> = vec3<i32>(sign(ray.direction));\r\n\tlet tdelta: vec3<f32> = select(voxel_size / abs(ray.direction), vec3<f32>(tmax), direction_zeros);\r\n\tlet voxel_boundary: vec3<f32> = vec3<f32>(voxel + max(vec3<i32>(0), vstep)) * voxel_size;\r\n\tvar tmax_comp: vec3<f32> = select(tmin + (boundary_min + voxel_boundary - ray_entry) / ray.direction, vec3<f32>(tmax), direction_zeros);\r\n\tvar thit: f32 = tmin;\r\n\tvar hit_normal: vec3<f32> = vec3<f32>(0, 0, 0);\r\n\tvar mask: vec3<f32>;\r\n\r\n\twhile(all(voxel >= vec3<i32>(0)) && all(voxel < vec3<i32>(voxel_count))) {\r\n\t\tlet hit_voxel = get_voxel(voxel);\r\n\t\tif (hit_voxel.opacity > 0.01 && all(tmax_comp > vec3<f32>(start_tolerance))){\r\n\t\t\t(*hit).position = ray.origin + ray.direction * thit;\r\n\t\t\t(*hit).voxel = hit_voxel;\r\n\t\t\t(*hit).voxel_position = voxel;\r\n\t\t\t(*hit).depth = 1 - (thit - depth_clip_min) / (depth_clip_max - depth_clip_min);\r\n\t\t\t(*hit).normal = hit_normal;\r\n\t\t\t(*hit).ray_direction = ray.direction;\r\n\t\t\t// let v_diff = (*hit).position - (vec3<f32>(voxel) * voxel_size - boundary_min);\r\n\t\t\tlet uv = (((*hit).position - boundary_min) - (vec3<f32>(voxel) * voxel_size)) / voxel_size;\r\n\t\t\tlet uvx = select(vec3<f32>(1) * mask - mask * uv.yzx, mask * uv.yzx, sign(ray.direction) < vec3<f32>(0));\r\n\t\t\tlet uvy = select(vec3<f32>(1) * mask - mask * uv.zxy, mask * uv.zxy, sign(ray.direction) < vec3<f32>(0));\r\n\t\t\t// let uvy = mask * uv.zxy;\r\n\t\t\t(*hit).uv = vec2<f32>(\r\n\t\t\t\tmax(uvx.x, max(uvx.y, uvx.z)),\r\n\t\t\t\tmax(uvy.x, max(uvy.y, uvy.z)),\r\n\t\t\t\t// dot(mask * v_diff.zxy, vec3<f32>(voxel_size)) / voxel_size,\r\n\t\t\t);\r\n\t\t\tlet next_mask = step(tmax_comp.xyz, tmax_comp.yzx) * step(tmax_comp.xyz, tmax_comp.zxy);\r\n\t\t\tlet tmax_masked = vec3<f32>(next_mask) * tmax_comp;\r\n\t\t\t(*hit).exit_position = ray.origin + ray.direction * max(tmax_masked.x, max(tmax_masked.y, tmax_masked.z));\r\n\r\n\t\t\t\t\t\t// if (tmax_comp.x < tmax_comp.y && tmax_comp.x < tmax_comp.z) {\r\n\t\t\t// \t(*hit).exit_position = ray.origin + ray.direction * tmax_comp.x;\r\n\t\t\t// } else if (tmax_comp.y < tmax_comp.z){\r\n\t\t\t// \t(*hit).exit_position = ray.origin + ray.direction * tmax_comp.y;\r\n\t\t\t// } else {\r\n\t\t\t// \t(*hit).exit_position = ray.origin + ray.direction * tmax_comp.z;\r\n\t\t\t// }\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\tmask = step(tmax_comp.xyz, tmax_comp.yzx) * step(tmax_comp.xyz, tmax_comp.zxy);\r\n\t\tvoxel += vstep * vec3<i32>(mask);\r\n\t\tlet tmax_masked = vec3<f32>(mask) * tmax_comp;\r\n\t\tthit = max(tmax_masked.x, max(tmax_masked.y, tmax_masked.z));\r\n\t\thit_normal = -(vec3<f32>(vstep) * mask);\r\n\t\ttmax_comp += mask * tdelta;\r\n\t}\r\n\r\n\treturn false;\r\n}\r\n\r\nfn voxel_ao(pos: vec3<i32>, d1: vec3<i32>, d2: vec3<i32>) -> vec4<f32> {\r\n\tif (get_voxel(pos).opacity > 0) { return vec4<f32>(1); }\r\n\tlet side = vec4<f32>(get_voxel(pos + d1).opacity, get_voxel(pos + d2).opacity, get_voxel(pos - d1).opacity, get_voxel(pos - d2).opacity);\r\n\tlet corner = vec4<f32>(get_voxel(pos + d1 + d2).opacity, get_voxel(pos - d1 + d2).opacity, get_voxel(pos - d1 - d2).opacity, get_voxel(pos + d1 - d2).opacity);\r\n\tlet ao = vec4<f32>(\r\n\t\tvertex_ao(side.xy, corner.x),\r\n\t\tvertex_ao(side.yz, corner.y),\r\n\t\tvertex_ao(side.zw, corner.z),\r\n\t\tvertex_ao(side.wx, corner.w),\r\n\t);\r\n\treturn 1.0 - ao * scene.ao_strength;\r\n}\r\n\r\nfn vertex_ao(side: vec2<f32>, corner: f32) -> f32 {\r\n\t// return (side.x + side.y) / 2.0;\r\n\treturn max(side.x + side.y, max(corner, side.x * side.y)) / 2;\r\n\treturn (side.x + side.y + max(corner, side.x * side.y)) / 3.0;\r\n}")}),constants:{grid_size:this.scene.grid_size,voxel_count:this.scene.voxel_count}}});const h=null===(s=this.device)||void 0===s?void 0:s.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.FRAGMENT,sampler:{}},{binding:1,visibility:GPUShaderStage.FRAGMENT,texture:{}},{binding:2,visibility:GPUShaderStage.FRAGMENT,texture:{}}]});this.screen_bind_group=null===(a=this.device)||void 0===a?void 0:a.createBindGroup({layout:h,entries:[{binding:0,resource:this.sampler},{binding:1,resource:this.color_buffer_view},{binding:2,resource:this.secondary_buffer_view}]});const _=null===(c=this.device)||void 0===c?void 0:c.createPipelineLayout({bindGroupLayouts:[h]});this.screen_pipeline=null===(l=this.device)||void 0===l?void 0:l.createRenderPipeline({layout:_,vertex:{module:this.device.createShaderModule({code:t}),entryPoint:"vert_main"},fragment:{module:this.device.createShaderModule({code:t}),entryPoint:"frag_main",targets:[{format:"bgra8unorm"}]},primitive:{topology:"triangle-list",cullMode:"back",frontFace:"cw"}})}))}}(ot,ct,lt.camera);ct.initialize_default_grid(),ut.initialize(!1);let ht=new class{constructor(t,e){this.background=[0,0,0],this.canvas=t,this.axis="z",this.slice=0,this.scene=e,this.context=t.getContext("2d");const r=document.getElementById("slice-input");r.addEventListener("change",(t=>{const e=Math.floor(parseInt(r.value)/100*this.scene.voxel_count);this.set_slice(e>this.scene.voxel_count-1?this.scene.voxel_count-1:e),console.log(e)}))}set_background(t){this.background=t,this.update()}set_axis(t){this.axis=t,this.update()}set_slice(t){this.slice=t,this.update()}update(){const t=this.canvas.width,e=this.canvas.height,r=t/this.scene.voxel_count,n=e/this.scene.voxel_count;this.context.clearRect(0,0,t,e);for(let t=0;t<this.scene.voxel_count;t++)for(let e=0;e<this.scene.voxel_count;e++){const i="x"===this.axis?[this.slice,t,e]:"y"===this.axis?[t,this.slice,e]:[t,e,this.slice],o=this.scene.get_voxel(i);Z.floor(Z.scale(o.color,255)),this.context.fillStyle=this.color_to_string(o.color,o.opacity),this.context.fillRect(t*r,e*n,r,n)}}color_to_string(t,e){const r=Z.floor(Z.scale(t,255));return"#"+r[0].toString(16)+r[1].toString(16)+r[2].toString(16)+(255*e).toString(16)}}(at,ct);ht.slice=6,ht.background=[30/255,30/255,46/255],ht.update();let _t=performance.now(),dt=!1;addEventListener("scroll",(()=>{let t=Math.min(2,window.scrollY/window.innerHeight);document.documentElement.style.setProperty("--canv-offset",t.toString())})),requestAnimationFrame((function t(){ut.render();const e=performance.now()-_t;lt.tick(e/1e3),_t=performance.now(),st.innerText=Math.round(1/e*1e3).toString()+" fps",requestAnimationFrame(t)})),addEventListener("mousedown",(t=>{2==t.button&&(dt=!0)}));let vt="mocha";const mt=document.getElementById("menu_switch_theme");null==mt||mt.addEventListener("click",(t=>{"mocha"===vt?(vt="latte",function(){const t=document.querySelector(":root");document.documentElement.dataset.theme="latte",t.style.setProperty("--ctp-crust","#dce0e8"),t.style.setProperty("--ctp-mantle","#e6e9ef"),t.style.setProperty("--ctp-base","#eff1f5"),t.style.setProperty("--ctp-surface0","#ccd0da"),t.style.setProperty("--ctp-surface1","#bcc0cc"),t.style.setProperty("--ctp-surface2","#acb0be"),t.style.setProperty("--ctp-overlay0","#9ca0b0"),t.style.setProperty("--ctp-overlay1","#8c8fa1"),t.style.setProperty("--ctp-overlay2","#7c7f93"),t.style.setProperty("--ctp-subtext0","#6c6f85"),t.style.setProperty("--ctp-subtext1","#5c5f77"),t.style.setProperty("--ctp-text","#4c4f69"),t.style.setProperty("--ctp-lavender","#7287fd"),t.style.setProperty("--ctp-blue","#1e66f5"),t.style.setProperty("--ctp-sapphire","#209fb5"),t.style.setProperty("--ctp-sky","#04a5e5"),t.style.setProperty("--ctp-teal","#179299"),t.style.setProperty("--ctp-green","#40a02b"),t.style.setProperty("--ctp-yellow","#df8e1d"),t.style.setProperty("--ctp-peach","#fe640b"),t.style.setProperty("--ctp-maroon","#e64553"),t.style.setProperty("--ctp-red","#d20f39"),t.style.setProperty("--ctp-mauve","#8839ef"),t.style.setProperty("--ctp-pink","#ea76cb"),t.style.setProperty("--ctp-flamingo","#dd7878"),t.style.setProperty("--ctp-rosewater","#dc8a78")}(),ct.background_color=[.8,208/255,218/255],ht.set_background([.8,208/255,218/255])):(vt="mocha",function(){const t=document.querySelector(":root");document.documentElement.dataset.theme="mocha",t.style.setProperty("--ctp-crust","#11111b"),t.style.setProperty("--ctp-mantle","#181825"),t.style.setProperty("--ctp-base","#1e1e2e"),t.style.setProperty("--ctp-surface0","#313244"),t.style.setProperty("--ctp-surface1","#45475a"),t.style.setProperty("--ctp-surface2","#585b70"),t.style.setProperty("--ctp-overlay0","#6c7086"),t.style.setProperty("--ctp-overlay1","#7f849c"),t.style.setProperty("--ctp-overlay2","#9399b2"),t.style.setProperty("--ctp-subtext0","#a6adc8"),t.style.setProperty("--ctp-subtext1","#bac2de"),t.style.setProperty("--ctp-text","#cdd6f4"),t.style.setProperty("--ctp-lavender","#b4befe"),t.style.setProperty("--ctp-blue","#89b4fa"),t.style.setProperty("--ctp-sapphire","#74c7ec"),t.style.setProperty("--ctp-sky","#89dceb"),t.style.setProperty("--ctp-teal","#94e2d5"),t.style.setProperty("--ctp-green","#a6e3a1"),t.style.setProperty("--ctp-yellow","#f9e2af"),t.style.setProperty("--ctp-peach","#fab387"),t.style.setProperty("--ctp-maroon","#eba0ac"),t.style.setProperty("--ctp-red","#f38ba8"),t.style.setProperty("--ctp-mauve","#cba6f7"),t.style.setProperty("--ctp-pink","#f5c2e7"),t.style.setProperty("--ctp-flamingo","#f2cdcd"),t.style.setProperty("--ctp-rosewater","#f5e0dc")}(),ct.background_color=[30/255,30/255,46/255],ht.set_background([30/255,30/255,46/255]))})),ct.background_color=[30/255,30/255,46/255];const ft=document.getElementById("menu_rescale_canvas");function pt(){const t=document.querySelector(":root"),e=.8*Math.min(window.innerWidth,window.innerHeight);t.style.setProperty("--canv-x",e.toString()+"px"),t.style.setProperty("--canv-y",e.toString()+"px"),ot.height=e,ot.width=e,ut.shutdown(),ut.initialize(ut.pathtracing)}null==ft||ft.addEventListener("click",(t=>{pt()})),pt();const xt=document.getElementById("menu_save_scene");null==xt||xt.addEventListener("click",(t=>{!function(){const t=new Blob([ct.serialize_scene()],{type:"text/json"}),e=document.createElement("a");e.href=URL.createObjectURL(t),e.download="scene.json",e.click(),URL.revokeObjectURL(e.href)}()}));const gt=document.getElementById("menu_load_scene");null==gt||gt.addEventListener("click",(t=>{!function(){const t=document.createElement("input");t.type="file",t.addEventListener("change",(e=>{const r=(null==t?void 0:t.files)[0],n=new FileReader;n.readAsText(r,"UTF-8"),n.addEventListener("load",(t=>{var e;const r=null===(e=t.target)||void 0===e?void 0:e.result;ct.deserialize_scene(r),ut.shutdown(),ut.initialize(ut.pathtracing)}))})),t.click()}()})),addEventListener("contextmenu",(t=>(t.preventDefault(),!1)))})();
//# sourceMappingURL=main.js.map