(()=>{"use strict";const t="@group(0) @binding(0) var screen_sampler : sampler;\r\n@group(0) @binding(1) var color_buffer : texture_2d<f32>;\r\n@group(0) @binding(2) var secondary_buffer : texture_2d<f32>;\r\n\r\nstruct VertexOutput {\r\n        @builtin(position) Position : vec4<f32>,\r\n            @location(0) TexCoord : vec2<f32>,\r\n}\r\n\r\n@vertex\r\nfn vert_main(@builtin(vertex_index) VertexIndex : u32) -> VertexOutput {\r\n    var positions = array<vec2<f32>, 6>(\r\n        vec2<f32>( 1.0,  1.0),\r\n        vec2<f32>( 1.0, -1.0),\r\n        vec2<f32>(-1.0, -1.0),\r\n        vec2<f32>( 1.0,  1.0),\r\n        vec2<f32>(-1.0, -1.0),\r\n        vec2<f32>(-1.0,  1.0)\r\n    );\r\n\r\n    var texCoords = array<vec2<f32>, 6>(\r\n        vec2<f32>(1.0, 0.0),\r\n        vec2<f32>(1.0, 1.0),\r\n        vec2<f32>(0.0, 1.0),\r\n        vec2<f32>(1.0, 0.0),\r\n        vec2<f32>(0.0, 1.0),\r\n        vec2<f32>(0.0, 0.0)\r\n    );\r\n\r\n    var output : VertexOutput;\r\n    output.Position = vec4<f32>(positions[VertexIndex], 0.0, 1.0);\r\n    output.TexCoord = texCoords[VertexIndex];\r\n    return output;\r\n}\r\n\r\nconst ao_blur_steps = 9;\r\nconst ao_blur_radius = 0.01f / f32(ao_blur_steps);\r\n\r\n@fragment\r\nfn frag_main(@location(0) TexCoord : vec2<f32>) -> @location(0) vec4<f32> {\r\n\tvar acc = 0f;\r\n\tlet blur_offset = (ao_blur_radius * f32(ao_blur_steps)) / 2;\r\n\tfor (var x = 0; x < ao_blur_steps; x++){\r\n\t\tfor (var y = 0; y < ao_blur_steps; y++){\r\n\t\t\tacc += textureSample(secondary_buffer, screen_sampler, vec2<f32>(TexCoord.x - blur_offset + ao_blur_radius * f32(x), TexCoord.y - blur_offset + ao_blur_radius * f32(y))).x;\r\n\t\t}\r\n\t}\r\n\tacc /= f32(ao_blur_steps) * f32(ao_blur_steps);\r\n\r\n    //return vec4<f32>(acc, acc, acc, 1.0);\r\n    return textureSample(color_buffer, screen_sampler, TexCoord) * (1 - acc);\r\n}\r\n";var e=function(t,e,r,n){return new(r||(r=Promise))((function(i,o){function a(t){try{s(n.next(t))}catch(t){o(t)}}function c(t){try{s(n.throw(t))}catch(t){o(t)}}function s(t){var e;t.done?i(t.value):(e=t.value,e instanceof r?e:new r((function(t){t(e)}))).then(a,c)}s((n=n.apply(t,e||[])).next())}))};let r=1e-6,n=Float32Array;function i(t=0,e=0){const r=new n(2);return void 0!==t&&(r[0]=t,void 0!==e&&(r[1]=e)),r}const o=i;function a(t,e,r){return(r=r||new n(2))[0]=t[0]-e[0],r[1]=t[1]-e[1],r}const c=a;function s(t,e,r){return(r=r||new n(2))[0]=t[0]*e,r[1]=t[1]*e,r}const l=s;function u(t,e){return(e=e||new n(2))[0]=1/t[0],e[1]=1/t[1],e}const h=u;function d(t,e){return t[0]*e[0]+t[1]*e[1]}function _(t){const e=t[0],r=t[1];return Math.sqrt(e*e+r*r)}const v=_;function f(t){const e=t[0],r=t[1];return e*e+r*r}const m=f;function p(t,e){const r=t[0]-e[0],n=t[1]-e[1];return Math.sqrt(r*r+n*n)}const y=p;function x(t,e){const r=t[0]-e[0],n=t[1]-e[1];return r*r+n*n}const g=x;function b(t,e){return(e=e||new n(2))[0]=t[0],e[1]=t[1],e}const w=b;function M(t,e,r){return(r=r||new n(2))[0]=t[0]*e[0],r[1]=t[1]*e[1],r}const z=M;function P(t,e,r){return(r=r||new n(2))[0]=t[0]/e[0],r[1]=t[1]/e[1],r}const S=P;var I=Object.freeze({__proto__:null,add:function(t,e,r){return(r=r||new n(2))[0]=t[0]+e[0],r[1]=t[1]+e[1],r},addScaled:function(t,e,r,i){return(i=i||new n(2))[0]=t[0]+e[0]*r,i[1]=t[1]+e[1]*r,i},angle:function(t,e){const r=t[0],n=t[1],i=t[0],o=t[1],a=Math.sqrt(r*r+n*n)*Math.sqrt(i*i+o*o),c=a&&d(t,e)/a;return Math.acos(c)},ceil:function(t,e){return(e=e||new n(2))[0]=Math.ceil(t[0]),e[1]=Math.ceil(t[1]),e},clamp:function(t,e=0,r=1,i){return(i=i||new n(2))[0]=Math.min(r,Math.max(e,t[0])),i[1]=Math.min(r,Math.max(e,t[1])),i},clone:w,copy:b,create:i,cross:function(t,e,r){r=r||new n(3);const i=t[0]*e[1]-t[1]*e[0];return r[0]=0,r[1]=0,r[2]=i,r},dist:y,distSq:g,distance:p,distanceSq:x,div:S,divScalar:function(t,e,r){return(r=r||new n(2))[0]=t[0]/e,r[1]=t[1]/e,r},divide:P,dot:d,equals:function(t,e){return t[0]===e[0]&&t[1]===e[1]},equalsApproximately:function(t,e){return Math.abs(t[0]-e[0])<r&&Math.abs(t[1]-e[1])<r},floor:function(t,e){return(e=e||new n(2))[0]=Math.floor(t[0]),e[1]=Math.floor(t[1]),e},fromValues:o,inverse:u,invert:h,len:v,lenSq:m,length:_,lengthSq:f,lerp:function(t,e,r,i){return(i=i||new n(2))[0]=t[0]+r*(e[0]-t[0]),i[1]=t[1]+r*(e[1]-t[1]),i},lerpV:function(t,e,r,i){return(i=i||new n(2))[0]=t[0]+r[0]*(e[0]-t[0]),i[1]=t[1]+r[1]*(e[1]-t[1]),i},max:function(t,e,r){return(r=r||new n(2))[0]=Math.max(t[0],e[0]),r[1]=Math.max(t[1],e[1]),r},min:function(t,e,r){return(r=r||new n(2))[0]=Math.min(t[0],e[0]),r[1]=Math.min(t[1],e[1]),r},mul:z,mulScalar:s,multiply:M,negate:function(t,e){return(e=e||new n(2))[0]=-t[0],e[1]=-t[1],e},normalize:function(t,e){e=e||new n(2);const r=t[0],i=t[1],o=Math.sqrt(r*r+i*i);return o>1e-5?(e[0]=r/o,e[1]=i/o):(e[0]=0,e[1]=0),e},random:function(t=1,e){e=e||new n(2);const r=2*Math.random()*Math.PI;return e[0]=Math.cos(r)*t,e[1]=Math.sin(r)*t,e},round:function(t,e){return(e=e||new n(2))[0]=Math.round(t[0]),e[1]=Math.round(t[1]),e},scale:l,setDefaultType:function(t){const e=n;return n=t,e},sub:c,subtract:a,transformMat3:function(t,e,r){r=r||new n(2);const i=t[0],o=t[1];return r[0]=e[0]*i+e[4]*o+e[8],r[1]=e[1]*i+e[5]*o+e[9],r},transformMat4:function(t,e,r){r=r||new n(2);const i=t[0],o=t[1];return r[0]=i*e[0]+o*e[4]+e[12],r[1]=i*e[1]+o*e[5]+e[13],r},zero:function(t){return(t=t||new n(2))[0]=0,t[1]=0,t}});Float32Array;new Map([[Float32Array,()=>new Float32Array(12)],[Float64Array,()=>new Float64Array(12)],[Array,()=>new Array(12).fill(0)]]).get(Float32Array);let G=Float32Array;function R(t,e,r){const n=new G(3);return void 0!==t&&(n[0]=t,void 0!==e&&(n[1]=e,void 0!==r&&(n[2]=r))),n}const E=R;function T(t,e,r){return(r=r||new G(3))[0]=t[0]-e[0],r[1]=t[1]-e[1],r[2]=t[2]-e[2],r}const D=T;function U(t,e,r){return(r=r||new G(3))[0]=t[0]*e,r[1]=t[1]*e,r[2]=t[2]*e,r}const q=U;function k(t,e){return(e=e||new G(3))[0]=1/t[0],e[1]=1/t[1],e[2]=1/t[2],e}const A=k;function B(t,e){return t[0]*e[0]+t[1]*e[1]+t[2]*e[2]}function L(t){const e=t[0],r=t[1],n=t[2];return Math.sqrt(e*e+r*r+n*n)}const F=L;function C(t){const e=t[0],r=t[1],n=t[2];return e*e+r*r+n*n}const O=C;function V(t,e){const r=t[0]-e[0],n=t[1]-e[1],i=t[2]-e[2];return Math.sqrt(r*r+n*n+i*i)}const H=V;function N(t,e){const r=t[0]-e[0],n=t[1]-e[1],i=t[2]-e[2];return r*r+n*n+i*i}const Y=N;function j(t,e){return(e=e||new G(3))[0]=t[0],e[1]=t[1],e[2]=t[2],e}const X=j;function W(t,e,r){return(r=r||new G(3))[0]=t[0]*e[0],r[1]=t[1]*e[1],r[2]=t[2]*e[2],r}const J=W;function K(t,e,r){return(r=r||new G(3))[0]=t[0]/e[0],r[1]=t[1]/e[1],r[2]=t[2]/e[2],r}const Q=K;var Z=Object.freeze({__proto__:null,add:function(t,e,r){return(r=r||new G(3))[0]=t[0]+e[0],r[1]=t[1]+e[1],r[2]=t[2]+e[2],r},addScaled:function(t,e,r,n){return(n=n||new G(3))[0]=t[0]+e[0]*r,n[1]=t[1]+e[1]*r,n[2]=t[2]+e[2]*r,n},angle:function(t,e){const r=t[0],n=t[1],i=t[2],o=t[0],a=t[1],c=t[2],s=Math.sqrt(r*r+n*n+i*i)*Math.sqrt(o*o+a*a+c*c),l=s&&B(t,e)/s;return Math.acos(l)},ceil:function(t,e){return(e=e||new G(3))[0]=Math.ceil(t[0]),e[1]=Math.ceil(t[1]),e[2]=Math.ceil(t[2]),e},clamp:function(t,e=0,r=1,n){return(n=n||new G(3))[0]=Math.min(r,Math.max(e,t[0])),n[1]=Math.min(r,Math.max(e,t[1])),n[2]=Math.min(r,Math.max(e,t[2])),n},clone:X,copy:j,create:R,cross:function(t,e,r){r=r||new G(3);const n=t[2]*e[0]-t[0]*e[2],i=t[0]*e[1]-t[1]*e[0];return r[0]=t[1]*e[2]-t[2]*e[1],r[1]=n,r[2]=i,r},dist:H,distSq:Y,distance:V,distanceSq:N,div:Q,divScalar:function(t,e,r){return(r=r||new G(3))[0]=t[0]/e,r[1]=t[1]/e,r[2]=t[2]/e,r},divide:K,dot:B,equals:function(t,e){return t[0]===e[0]&&t[1]===e[1]&&t[2]===e[2]},equalsApproximately:function(t,e){return Math.abs(t[0]-e[0])<r&&Math.abs(t[1]-e[1])<r&&Math.abs(t[2]-e[2])<r},floor:function(t,e){return(e=e||new G(3))[0]=Math.floor(t[0]),e[1]=Math.floor(t[1]),e[2]=Math.floor(t[2]),e},fromValues:E,getAxis:function(t,e,r){const n=4*e;return(r=r||new G(3))[0]=t[n+0],r[1]=t[n+1],r[2]=t[n+2],r},getScaling:function(t,e){e=e||new G(3);const r=t[0],n=t[1],i=t[2],o=t[4],a=t[5],c=t[6],s=t[8],l=t[9],u=t[10];return e[0]=Math.sqrt(r*r+n*n+i*i),e[1]=Math.sqrt(o*o+a*a+c*c),e[2]=Math.sqrt(s*s+l*l+u*u),e},getTranslation:function(t,e){return(e=e||new G(3))[0]=t[12],e[1]=t[13],e[2]=t[14],e},inverse:k,invert:A,len:F,lenSq:O,length:L,lengthSq:C,lerp:function(t,e,r,n){return(n=n||new G(3))[0]=t[0]+r*(e[0]-t[0]),n[1]=t[1]+r*(e[1]-t[1]),n[2]=t[2]+r*(e[2]-t[2]),n},lerpV:function(t,e,r,n){return(n=n||new G(3))[0]=t[0]+r[0]*(e[0]-t[0]),n[1]=t[1]+r[1]*(e[1]-t[1]),n[2]=t[2]+r[2]*(e[2]-t[2]),n},max:function(t,e,r){return(r=r||new G(3))[0]=Math.max(t[0],e[0]),r[1]=Math.max(t[1],e[1]),r[2]=Math.max(t[2],e[2]),r},min:function(t,e,r){return(r=r||new G(3))[0]=Math.min(t[0],e[0]),r[1]=Math.min(t[1],e[1]),r[2]=Math.min(t[2],e[2]),r},mul:J,mulScalar:U,multiply:W,negate:function(t,e){return(e=e||new G(3))[0]=-t[0],e[1]=-t[1],e[2]=-t[2],e},normalize:function(t,e){e=e||new G(3);const r=t[0],n=t[1],i=t[2],o=Math.sqrt(r*r+n*n+i*i);return o>1e-5?(e[0]=r/o,e[1]=n/o,e[2]=i/o):(e[0]=0,e[1]=0,e[2]=0),e},random:function(t=1,e){e=e||new G(3);const r=2*Math.random()*Math.PI,n=2*Math.random()-1,i=Math.sqrt(1-n*n)*t;return e[0]=Math.cos(r)*i,e[1]=Math.sin(r)*i,e[2]=n*t,e},round:function(t,e){return(e=e||new G(3))[0]=Math.round(t[0]),e[1]=Math.round(t[1]),e[2]=Math.round(t[2]),e},scale:q,setDefaultType:function(t){const e=G;return G=t,e},sub:D,subtract:T,transformMat3:function(t,e,r){r=r||new G(3);const n=t[0],i=t[1],o=t[2];return r[0]=n*e[0]+i*e[4]+o*e[8],r[1]=n*e[1]+i*e[5]+o*e[9],r[2]=n*e[2]+i*e[6]+o*e[10],r},transformMat4:function(t,e,r){r=r||new G(3);const n=t[0],i=t[1],o=t[2],a=e[3]*n+e[7]*i+e[11]*o+e[15]||1;return r[0]=(e[0]*n+e[4]*i+e[8]*o+e[12])/a,r[1]=(e[1]*n+e[5]*i+e[9]*o+e[13])/a,r[2]=(e[2]*n+e[6]*i+e[10]*o+e[14])/a,r},transformMat4Upper3x3:function(t,e,r){r=r||new G(3);const n=t[0],i=t[1],o=t[2];return r[0]=n*e[0]+i*e[4]+o*e[8],r[1]=n*e[1]+i*e[5]+o*e[9],r[2]=n*e[2]+i*e[6]+o*e[10],r},zero:function(t){return(t=t||new G(3))[0]=0,t[1]=0,t[2]=0,t}});Float32Array,Float32Array,Float32Array;class ${constructor(t,e){this.origin=t,this.direction=Z.normalize(e),this.inv_direction=[1,1,1],Z.div(this.inv_direction,e,this.inv_direction)}}class tt{constructor(t,e,r,n){this.position=t,this.voxel_position=e,this.voxel=r,this.normal=n}}class et{constructor(){this.color=Z.create(),this.opacity=0,this.roughness=1,this.lightness=0}}function rt(t){return t*Math.PI/180}class nt{constructor(t,e,r){this.dragged=!1,this.velocity=[0,0],this.distance=8,this.forward=Z.create(),this.right=Z.create(),this.up=Z.create(),this.position=Z.create(),this.eulers=[0,r,e],this.distance=t}update(){this.eulers[1]=Math.min(80,Math.max(-80,this.eulers[1])),this.eulers[2]=this.eulers[2]%360,this.forward=[Math.cos(rt(this.eulers[2]))*Math.cos(rt(this.eulers[1])),Math.sin(rt(this.eulers[2]))*Math.cos(rt(this.eulers[1])),Math.sin(rt(this.eulers[1]))],Z.normalize(Z.cross(this.forward,[0,0,1],this.right),this.right),Z.normalize(Z.cross(this.right,this.forward,this.up),this.up),Z.scale(this.forward,-this.distance,this.position)}tick(t){this.dragged||(this.eulers[1]-=this.velocity[1],this.eulers[2]-=this.velocity[0]),I.scale(this.velocity,.96*(1-t),this.velocity),this.update()}screen_to_ray(t,e,r,n){const i=(t-r/2)/r,o=(e-n/2)/-n;let a=Z.create();return Z.add(a,this.forward,a),Z.add(a,Z.scale(this.right,i),a),Z.add(a,Z.scale(this.up,o),a),new $(this.position,a)}}const it=document.getElementById("canv"),ot=document.getElementById("fps"),at=(document.getElementById("kloppenheim_02"),new class{constructor(){this.grid_size=8,this.voxel_count=32,this.grid=new Array(this.grid_size*this.grid_size*this.grid_size),this.boundary_min=[-this.grid_size/2,-this.grid_size/2,-this.grid_size/2],this.boundary_max=[this.grid_size/2,this.grid_size/2,this.grid_size/2],this.voxel_size=this.grid_size/this.voxel_count,this.initialize_grid(),this.direct_light=Z.normalize([1.5,.6,3]),this.direct_light_brightness=1,this.background_color=[0,0,0]}initialize_grid(){this.grid=new Array(this.voxel_count**3);for(let t=0;t<this.voxel_count;t++)for(let e=0;e<this.voxel_count;e++)for(let r=0;r<this.voxel_count;r++){let n=new et;n.color=[0,0,0],n.opacity=0,this.grid[r*this.voxel_count*this.voxel_count+e*this.voxel_count+t]=n}}initialize_default_grid(){for(let t=0;t<this.voxel_count;t++)for(let e=0;e<this.voxel_count;e++)for(let r=0;r<this.voxel_count;r++){let n=new et;r<3&&(n.color=[t/this.voxel_count,e/this.voxel_count,r/this.voxel_count],Z.scale(n.color,2,n.color),n.opacity=1,n.lightness=0,n.roughness=1),Z.dist([t,e,r],[this.voxel_count/2,this.voxel_count/2,this.voxel_count/2])<5&&(n.opacity=1,n.color=[.2,e/this.voxel_count+.3,r/this.voxel_count+.3],Z.scale(n.color,2,n.color),n.lightness=0,n.roughness=1),(t==this.voxel_count-2||e<2)&&(n.color=[t/this.voxel_count,e/this.voxel_count,r/this.voxel_count],n.opacity=1,n.roughness=.3),n.color[0]=Math.min(1,n.color[0]),n.color[1]=Math.min(1,n.color[1]),n.color[2]=Math.min(1,n.color[2]),this.set_voxel_comp(n,t,e,r)}}ray_any(t){let e=0,r=1/0;for(let n=0;n<3;n++){let i=(this.boundary_min[n]-t.origin[n])*t.inv_direction[n],o=(this.boundary_max[n]-t.origin[n])*t.inv_direction[n];e=Math.min(Math.max(i,e),Math.max(o,e)),r=Math.max(Math.min(i,r),Math.min(o,r))}if(e>r)return;const n=Z.add(t.origin,Z.scale(t.direction,e)),i=Z.add(t.origin,Z.scale(t.direction,r));let o=[Math.max(0,Math.min(this.voxel_count-1,Math.floor((n[0]-this.boundary_min[0])/this.voxel_size))),Math.max(0,Math.min(this.voxel_count-1,Math.floor((n[1]-this.boundary_min[1])/this.voxel_size))),Math.max(0,Math.min(this.voxel_count-1,Math.floor((n[2]-this.boundary_min[2])/this.voxel_size)))],a=[o[0]+1,o[1]+1,o[2]+1],c=[0,0,0],s=[0,0,0],l=[0,0,0],u=[0,0,0],h=e,d=[0,0,0];for(let h=0;h<3;h++)u[h]=Math.max(0,Math.min(this.voxel_count-1,Math.floor((i[h]-this.boundary_min[h])/this.voxel_size))),t.direction[h]>0?(c[h]=1,l[h]=this.voxel_size/t.direction[h],s[h]=e+(this.boundary_min[h]+a[h]*this.voxel_size-n[h])/t.direction[h]):t.direction[h]<0?(c[h]=-1,l[h]=this.voxel_size/-t.direction[h],s[h]=e+(this.boundary_min[h]+o[h]*this.voxel_size-n[h])/t.direction[h]):(c[h]=0,l[h]=r,s[h]=r);for(;o[0]<this.voxel_count&&o[0]>=0&&o[1]<this.voxel_count&&o[1]>=0&&o[2]<this.voxel_count&&o[2]>=0;){if(this.get_voxel(o).opacity>.01){const e=Z.add(t.origin,Z.scale(t.direction,h));return new tt(e,o,this.get_voxel(o),d)}s[0]<s[1]&&s[0]<s[2]?(o[0]+=c[0],h=s[0],s[0]+=l[0],d=[-c[0],0,0]):s[1]<s[2]?(o[1]+=c[1],h=s[1],s[1]+=l[1],d=[0,-c[1],0]):(o[2]+=c[2],h=s[2],s[2]+=l[2],d=[0,0,-c[2]])}}get_voxel_id_comp(t,e,r){return r*this.voxel_count*this.voxel_count+e*this.voxel_count+t}get_voxel_id(t){return t[2]*this.voxel_count*this.voxel_count+t[1]*this.voxel_count+t[0]}get_voxel_comp(t,e,r){return this.grid[r*this.voxel_count*this.voxel_count+e*this.voxel_count+t]}get_voxel(t){return this.grid[t[2]*this.voxel_count*this.voxel_count+t[1]*this.voxel_count+t[0]]}set_voxel(t,e){e[0]>0&&e[0]<this.voxel_count-1&&e[1]>0&&e[1]<this.voxel_count-1&&e[2]>0&&e[2]<this.voxel_count-1&&(this.grid[e[2]*this.voxel_count*this.voxel_count+e[1]*this.voxel_count+e[0]]=t)}set_voxel_comp(t,e,r,n){e>0&&e<this.voxel_count-1&&r>0&&r<this.voxel_count-1&&n>0&&n<this.voxel_count-1&&(this.grid[n*this.voxel_count*this.voxel_count+r*this.voxel_count+e]=t)}});let ct=new class{constructor(t,e,r,n,i){this.mouse_down=!1,this.mouse_dragged=!1,this.last_move=0,this.velocity=[0,0],this.selected_color=[0,0,0],this.selected_roughness=1,this.selected_opacity=1,this.selected_lightness=0,this.camera=new nt(r,n,i),this.setup(),this.last_move=performance.now(),this.last_movement=[0,0],this.scene=t,this.canvas=e,this.selected_tool="place"}tick(t){this.camera.tick(t)}setup(){var t,e,r,n,i,o,a;addEventListener("mousedown",(t=>{0==t.button&&(this.mouse_down=!0,this.mouse_dragged=!1,this.camera.dragged=!0,this.last_move=performance.now())})),addEventListener("mouseup",(t=>{if(0==t.button&&(this.mouse_down=!1,this.camera.dragged=!1,this.camera.velocity=[...this.velocity],!this.mouse_dragged)){const e=this.canvas.getBoundingClientRect(),r=t.clientX-e.left,n=t.clientY-e.top;let i=this.scene.ray_any(this.camera.screen_to_ray(r,n,e.width,e.height));if(i)switch(this.selected_tool){case"place":let t=new et;t.color=this.selected_color,t.roughness=this.selected_roughness,t.lightness=this.selected_lightness,t.opacity=this.selected_opacity,this.scene.set_voxel(t,i.voxel_position.map(((t,e)=>t+i.normal[e])));break;case"replace":let e=new et;e.color=this.selected_color,e.roughness=this.selected_roughness,e.lightness=this.selected_lightness,e.opacity=this.selected_opacity,this.scene.set_voxel(e,i.voxel_position);break;case"remove":let r=new et;r.opacity=0,this.scene.set_voxel(r,i.voxel_position)}}})),addEventListener("mousemove",(t=>{this.last_movement=I.scale([t.movementX,t.movementY],.2),this.mouse_down&&this.mouse_drag(t),this.calculate_velocity(),this.last_move=performance.now()})),null===(t=document.getElementById("color_value"))||void 0===t||t.addEventListener("input",(t=>{var e;const r=t.target.value;this.selected_color=Z.scale(null===(e=r.match(/\w\w/g))||void 0===e?void 0:e.map((t=>parseInt(t,16))),1/255)})),null===(e=document.getElementById("roughness_value"))||void 0===e||e.addEventListener("input",(t=>{this.selected_roughness=1-parseInt(t.target.value)/100})),null===(r=document.getElementById("lightness_value"))||void 0===r||r.addEventListener("input",(t=>{this.selected_lightness=parseInt(t.target.value)/100})),null===(n=document.getElementById("opacity_value"))||void 0===n||n.addEventListener("input",(t=>{this.selected_opacity=parseInt(t.target.value)/100})),null===(i=document.getElementById("tool-place-button"))||void 0===i||i.addEventListener("change",(t=>{this.selected_tool="place"})),null===(o=document.getElementById("tool-replace-button"))||void 0===o||o.addEventListener("change",(t=>{this.selected_tool="replace"})),null===(a=document.getElementById("tool-remove-button"))||void 0===a||a.addEventListener("change",(t=>{this.selected_tool="remove"}))}calculate_velocity(){const t=performance.now()-this.last_move;I.scale(this.last_movement,1/t,this.velocity)}mouse_drag(t){this.camera.eulers[1]=this.camera.eulers[1]-this.last_movement[1],this.camera.eulers[2]=this.camera.eulers[2]-this.last_movement[0],this.mouse_dragged=!0}}(at,it,12,0,0),st=new class{constructor(t,e,r){this.initialized=!1,this.render=()=>{var t,e,r,n,i,o;if(!this.initialized)return;let a=[];for(let t=0;t<this.scene.voxel_count;t++)for(let e=0;e<this.scene.voxel_count;e++)for(let r=0;r<this.scene.voxel_count;r++)this.scene.get_voxel([t,e,r]).lightness>0&&a.push([t,e,r]);null===(t=this.device)||void 0===t||t.queue.writeBuffer(this.sceneParameters,0,new Float32Array([this.camera.position[0],this.camera.position[1],this.camera.position[2],(new Date).getMilliseconds(),this.camera.forward[0],this.camera.forward[1],this.camera.forward[2],a.length,this.camera.right[0],this.camera.right[1],this.camera.right[2],0,this.camera.up[0],this.camera.up[1],this.camera.up[2],0,this.scene.direct_light[0],this.scene.direct_light[1],this.scene.direct_light[2],this.scene.direct_light_brightness,this.scene.background_color[0],this.scene.background_color[1],this.scene.background_color[2],0]),0,24);const c=new Float32Array(4*a.length);for(let t=0;t<a.length;++t)c[4*t]=a[t][0],c[4*t+1]=a[t][1],c[4*t+2]=a[t][2],c[4*t+3]=0;null===(e=this.device)||void 0===e||e.queue.writeBuffer(this.lightData,0,c,0,4*a.length);const s=new Float32Array(8*this.scene.grid.length);for(let t=0;t<this.scene.grid.length;++t)s[8*t]=this.scene.grid[t].color[0],s[8*t+1]=this.scene.grid[t].color[1],s[8*t+2]=this.scene.grid[t].color[2],s[8*t+3]=this.scene.grid[t].opacity,s[8*t+4]=this.scene.grid[t].roughness,s[8*t+5]=this.scene.grid[t].lightness,s[8*t+6]=0,s[8*t+7]=0;null===(r=this.device)||void 0===r||r.queue.writeBuffer(this.sceneData,0,s,0,8*this.scene.grid.length);const l=null===(n=this.device)||void 0===n?void 0:n.createCommandEncoder(),u=null==l?void 0:l.beginComputePass();null==u||u.setPipeline(this.ray_tracing_pipeline),null==u||u.setBindGroup(0,this.ray_tracing_bind_group),null==u||u.dispatchWorkgroups(this.canvas.width/16,this.canvas.height/16,1),null==u||u.end();const h=null===(i=this.context)||void 0===i?void 0:i.getCurrentTexture().createView(),d=null==l?void 0:l.beginRenderPass({colorAttachments:[{view:h,clearValue:{r:.5,g:0,b:.25,a:1},loadOp:"clear",storeOp:"store"}]});null==d||d.setPipeline(this.screen_pipeline),null==d||d.setBindGroup(0,this.screen_bind_group),null==d||d.draw(6,1,0,0),null==d||d.end(),null===(o=this.device)||void 0===o||o.queue.submit([null==l?void 0:l.finish()])},this.canvas=t,this.scene=e,this.pathtracing=!1,this.camera=r}initialize(t){return e(this,void 0,void 0,(function*(){this.pathtracing=t,yield this.setupDevice(),yield this.createAssets(),yield this.setupPipeline(),this.initialized=!0}))}set_hdr(t){}shutdown(){var t,e,r;this.initialized=!1,null===(t=this.device)||void 0===t||t.destroy(),null===(e=this.color_buffer)||void 0===e||e.destroy(),null===(r=this.secondary_buffer)||void 0===r||r.destroy()}setupDevice(){var t,r;return e(this,void 0,void 0,(function*(){this.adapter=yield null===(t=navigator.gpu)||void 0===t?void 0:t.requestAdapter(),this.device=yield null===(r=this.adapter)||void 0===r?void 0:r.requestDevice(),this.context=this.canvas.getContext("webgpu"),this.format="bgra8unorm",this.context.configure({device:this.device,format:this.format,alphaMode:"opaque"})}))}createAssets(){var t,r,n,i,o,a,c,s;return e(this,void 0,void 0,(function*(){this.color_buffer=null===(t=this.device)||void 0===t?void 0:t.createTexture({size:{width:this.canvas.width,height:this.canvas.height},format:"rgba8unorm",usage:GPUTextureUsage.COPY_DST|GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.TEXTURE_BINDING}),this.secondary_buffer=null===(r=this.device)||void 0===r?void 0:r.createTexture({size:{width:this.canvas.width,height:this.canvas.height},format:"rgba8unorm",usage:GPUTextureUsage.COPY_DST|GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.TEXTURE_BINDING}),this.color_buffer_view=null===(n=this.color_buffer)||void 0===n?void 0:n.createView(),this.secondary_buffer_view=null===(i=this.secondary_buffer)||void 0===i?void 0:i.createView(),this.sampler=null===(o=this.device)||void 0===o?void 0:o.createSampler({addressModeU:"repeat",addressModeV:"repeat",magFilter:"linear",minFilter:"nearest",mipmapFilter:"nearest",maxAnisotropy:1}),this.sceneParameters=null===(a=this.device)||void 0===a?void 0:a.createBuffer({size:96,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST});const e=this.scene.voxel_count*this.scene.voxel_count*this.scene.voxel_count;this.sceneData=null===(c=this.device)||void 0===c?void 0:c.createBuffer({size:8*e*4,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),this.lightData=null===(s=this.device)||void 0===s?void 0:s.createBuffer({size:512,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST})}))}setupPipeline(){var r,n,i,o,a,c,s,l;return e(this,void 0,void 0,(function*(){const e=null===(r=this.device)||void 0===r?void 0:r.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,storageTexture:{access:"write-only",format:"rgba8unorm",viewDimension:"2d"}},{binding:1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},{binding:2,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:3,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:4,visibility:GPUShaderStage.COMPUTE,storageTexture:{access:"write-only",format:"rgba8unorm",viewDimension:"2d"}}]});this.ray_tracing_bind_group=null===(n=this.device)||void 0===n?void 0:n.createBindGroup({layout:e,label:"Ray tracing bind group",entries:[{binding:0,resource:this.color_buffer_view},{binding:1,resource:{buffer:this.sceneParameters}},{binding:2,resource:{buffer:this.sceneData}},{binding:3,resource:{buffer:this.lightData}},{binding:4,resource:this.secondary_buffer_view}]});const u=null===(i=this.device)||void 0===i?void 0:i.createPipelineLayout({bindGroupLayouts:[e]});this.ray_tracing_pipeline=null===(o=this.device)||void 0===o?void 0:o.createComputePipeline({label:"Ray tracing pipeline",layout:u,compute:{entryPoint:"main",module:this.device.createShaderModule({code:"@group(0) @binding(0) var color_buffer: texture_storage_2d<rgba8unorm, write>;\r\n@group(0) @binding(1) var<uniform> scene: SceneParameter;\r\n@group(0) @binding(2) var<storage, read> scene_data: SceneData;\r\n// @group(0) @binding(3) var hdr_tex: texture_2d<f32>;\r\n// @group(0) @binding(4) var hdr_sampler: sampler;\r\n@group(0) @binding(3) var<storage, read> lights: LightData;\r\n@group(0) @binding(4) var secondary_buffer: texture_storage_2d<rgba8unorm, write>;\r\n\r\noverride grid_size: f32 = 2f;\r\noverride voxel_count: i32 = 4;\r\nvar<private> voxel_size: f32 = grid_size / f32(voxel_count);\r\nvar<private> boundary_min: vec3<f32> = vec3<f32>(f32(-grid_size) / 2, f32(-grid_size) / 2, f32(-grid_size) / 2);\r\nvar<private> boundary_max: vec3<f32> = vec3<f32>(f32(grid_size) / 2, f32(grid_size) / 2, f32(grid_size) / 2);\r\nvar<private> depth_clip_min: f32 = 1f;\r\nvar<private> depth_clip_max: f32 = 10f;\r\n\r\nvar<private> rng_seed: u32;\r\nvar<private> rng_seed_steady: u32;\r\n\r\nconst samples: i32 = 1;\r\nconst light_bounces: i32 = 6;\r\nconst max_penetrations: i32 = 5;\r\nconst reflection_bounces: i32 = 5;\r\nconst scatter: i32 = 5;\r\nconst ambient_light: f32 = 0.03;\r\nconst pi = 3.14159265359;\r\n\r\n// const background: vec3<f32> = vec3<f32>(24f / 255f, 24f / 255f, 37f / 255f);\r\n\r\nstruct SceneParameter {\r\n    camera_pos: vec3<f32>,\r\n    rng_start: f32,\r\n    camera_forward: vec3<f32>,\r\n    light_count: f32,\r\n    camera_right: vec3<f32>,\r\n    camera_up: vec3<f32>,\r\n    direct_light: vec3<f32>,\r\n    direct_light_brightness: f32,\r\n\tbackground_color: vec3<f32>,\r\n}\r\n\r\nstruct Voxel {\r\n\tcolor: vec3<f32>,\r\n\topacity: f32,\r\n\troughness: f32,\r\n\tlightness: f32,\r\n}\r\n\r\nstruct SceneData {\r\n\tdata: array<Voxel>,\r\n}\r\n\r\nstruct LightData {\r\n\tdata: array<Light>,\r\n}\r\n\r\nstruct Light {\r\n\tlocation: vec3<f32>,\r\n\temitter_type: f32,\r\n}\r\n\r\nstruct Ray {\r\n    origin: vec3<f32>,\r\n    direction: vec3<f32>,\r\n    inv_direction: vec3<f32>,\r\n}\r\n\r\nstruct RayHit {\r\n\tposition: vec3<f32>,\r\n\tdepth: f32,\r\n\tvoxel_position: vec3<i32>,\r\n\tvoxel: Voxel,\r\n\tnormal: vec3<f32>,\r\n\tray_direction: vec3<f32>,\r\n\texit_position: vec3<f32>,\r\n}\r\n\r\nstruct TraceResult {\r\n\tcolor: vec3<f32>,\r\n\tao: f32,\r\n}\r\n\r\n@compute @workgroup_size(16,16,1)\r\nfn main(@builtin(global_invocation_id) GlobalInvocationID : vec3<u32>) {\r\n    let screen_size: vec2<u32> = textureDimensions(color_buffer);\r\n    let screen_pos : vec2<i32> = vec2<i32>(i32(GlobalInvocationID.x), i32(GlobalInvocationID.y));\r\n    rng_seed = GlobalInvocationID.x + 50 + (GlobalInvocationID.y + 50) * (GlobalInvocationID.x + 100) * 1000 * u32(scene.rng_start);\r\n    // rng_seed = GlobalInvocationID.x + 50 + (GlobalInvocationID.y + 50) * (GlobalInvocationID.x + 100) * 1000;\r\n    rng_seed_steady = GlobalInvocationID.x + 150 + (GlobalInvocationID.y + 75) * (GlobalInvocationID.x + 350) * 1000;\r\n\r\n    var pixel_color: vec3<f32>;\r\n    var pixel_ao: f32;\r\n    for (var i = 0; i < samples; i++){\r\n\r\n\t    let rng_offset: vec2<f32> = select(vec2<f32>(0), vec2<f32>(rng() - 0.5, rng() - 0.5), samples > 1);\r\n\t    let horizontal_coefficient: f32 = (f32(screen_pos.x) + rng_offset.x - f32(screen_size.x) / 2) / f32(screen_size.x);\r\n\t    let vertical_coefficient: f32 = (f32(screen_pos.y) + rng_offset.y - f32(screen_size.y) / 2) / -f32(screen_size.y);\r\n\r\n\t    let ray_direction = normalize(scene.camera_forward\r\n\t\t\t    + horizontal_coefficient * scene.camera_right\r\n\t\t\t    + vertical_coefficient * scene.camera_up);\r\n\t    let ray: Ray = Ray(scene.camera_pos, ray_direction, 1 / ray_direction);\r\n\t    let trace_result = trace(ray, light_bounces);\r\n\t    // pixel_color += trace(ray, light_bounces);\r\n\t    pixel_color += trace_result.color;\r\n\t    pixel_ao += trace_result.ao;\r\n    }\r\n\r\n    // let correction = 1.0 / f32(samples);\r\n    // pixel_color = sqrt(correction * pixel_color);\r\n\r\n\tpixel_color /= f32(samples);\r\n\tpixel_ao /= f32(samples);\r\n\r\n    /* pixel_color = textureSampleLevel(hdr_tex, hdr_sampler, vec2<f32>(f32(GlobalInvocationID.x) / f32(screen_size.x), f32(GlobalInvocationID.y) / f32(screen_size.y) * 2), 0.0).rgb; */\r\n\r\n    textureStore(color_buffer, screen_pos, vec4<f32>(pixel_color, 1.0));\r\n    textureStore(secondary_buffer, screen_pos, vec4<f32>(pixel_ao, 0, 0, 1.0));\r\n}\r\n\r\nfn rng_hash(seed: u32) -> u32 {\r\n\tvar x = ( seed << 10u );\r\n\tx ^= ( x >>  6u );\r\n\tx += ( x <<  3u );\r\n\tx ^= ( x >> 11u );\r\n\tx += ( x << 15u );\r\n\treturn x;\r\n}\r\n\r\nfn rng() -> f32 {\r\n\trng_seed++;\r\n\treturn bitcast<f32>((rng_hash(rng_seed) >> 9) | 0x3f800000 ) - 1.0;\r\n}\r\n\r\nfn rng_steady() -> f32 {\r\n\trng_seed_steady++;\r\n\treturn bitcast<f32>((rng_hash(rng_seed_steady) >> 9) | 0x3f800000 ) - 1.0;\r\n}\r\n\r\nfn ray_reflect(ray: Ray, position: vec3<f32>, normal: vec3<f32>) -> Ray {\r\n\tlet reflect = ray.direction - 2 * dot(ray.direction, normal) * normal;\r\n\treturn Ray(position, reflect, 1 / reflect);\r\n}\r\n\r\nfn get_voxel_id(v: vec3<i32>) -> i32 {\r\n\treturn v.z * voxel_count * voxel_count + v.y * voxel_count + v.x;\r\n}\r\n\r\nfn get_voxel(v: vec3<i32>) -> Voxel {\r\n\treturn scene_data.data[v.z * voxel_count * voxel_count + v.y * voxel_count + v.x];\r\n}\r\n\r\nfn get_voxel_by_position(v: vec3<f32>) -> Voxel {\r\n\treturn get_voxel(vec3<i32>((v - boundary_min) / f32(voxel_size)));\r\n}\r\n\r\nfn sample_spherical_map(v: vec3<f32>) -> vec2<f32> {\r\n\tlet theta = atan2(v.x, v.y);\r\n\tlet phi = acos(v.z);\r\n\tlet raw_u = theta / (2 * pi);\r\n\tlet uv = vec2<f32>(\r\n\t\t1 - (raw_u + 0.5),\r\n\t\tphi / pi\r\n\t);\r\n\treturn uv;\r\n}\r\n\r\nfn random_unit_vector() -> vec3<f32> {\r\n\tlet phi = rng() * pi * 2;\r\n\tlet costheta = rng() * 2 - 1;\r\n\t\tlet theta = acos(costheta);\r\n\tlet x = sin(theta) * cos(phi);\r\n\tlet y = sin(theta) * sin(phi);\r\n\tlet z = cos(theta);\r\n\treturn vec3<f32>(x, y, z);\r\n}\r\n"+(this.pathtracing?"const light_scatter_samples: i32 = 2;\r\n\r\nfn gamma_correct(color: vec3<f32>) -> vec3<f32> {\r\n    let correction = 1.0 / f32(samples);\r\n    return sqrt(correction * color);\r\n}\r\n\r\nfn trace(ray: Ray, depth: i32) -> vec3<f32> {\r\n\tif (depth <= 0) {\r\n\t\treturn vec3<f32>(0);\r\n\t}\r\n\t\tvar accum: vec3<f32> = vec3<f32>(0.0);\r\n\t\tvar mask: vec3<f32> = vec3<f32>(1.0);\r\n\t\tvar curr_ray: Ray = ray;\r\n\t\tvar curr_hit: RayHit;\r\n\t\tvar refl: f32 = 1.0;\r\n\t\tvar hits: i32 = 0;\r\n\r\n\t\tvar bounce_results: array<RayHit, light_bounces>;\r\n\r\n\t\tfor (; hits < light_bounces;){\r\n\t\t\tif (voxel_ray_any(curr_ray, 0.0001, &curr_hit)) {\r\n\t\t\t\tlet bounce_direction = random_unit_vector() + curr_hit.normal;\r\n\t\t\t\tif (all(bounce_direction == vec3<f32>(0))){\r\n\t\t\t\t\tcurr_ray = Ray(curr_hit.position, curr_hit.normal, 1 / curr_hit.normal);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tlet normalized = normalize(bounce_direction);\r\n\t\t\t\t\tcurr_ray = Ray(curr_hit.position, normalized, 1 / normalized);\r\n\t\t\t\t}\r\n\t\t\t\tbounce_results[hits] = curr_hit;\r\n\t\t\t\thits++;\r\n\t\t\t} else {\r\n\t\t\t\t// accum = pow(textureSampleLevel(hdr_tex, hdr_sampler, sample_spherical_map(curr_ray.direction), 0.0).rgb, vec3<f32>(2)) * 5;\r\n\t\t\t\taccum = vec3<f32>(pow(max(0, dot(curr_ray.direction, scene.direct_light) - 0.98) * 40, 1));\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (hits == 0){\r\n\t\t\t// return textureSampleLevel(hdr_tex, hdr_sampler, sample_spherical_map(ray.direction), 0.0).rgb;\r\n\t\t\treturn vec3<f32>(pow(max(0, dot(ray.direction, scene.direct_light) - 0.95) * 20, 1));\r\n\t\t}\r\n\t\tif (hits == light_bounces){\r\n\t\t\taccum = vec3<f32>(0, 0, 0);\r\n\t\t} else {\r\n\t\t\t// accum = textureSampleLevel(hdr_tex, hdr_sampler, sample_spherical_map(bounce_results[hits - 1].ray_direction), 0.0).rgb;\r\n\t\t\t/* accum = vec3<f32>(max(0, dot(bounce_results[hits - 1].ray_direction, scene.direct_light))); */\r\n\t\t\t// accum = vec3<f32>(0);\r\n\t\t}\r\n\t\tfor (var i: i32 = hits - 1; i >= 0; i--){\r\n\t\t\tlet bounce = bounce_results[i];\r\n\t\t\t/* accum = min(vec3<f32>(1), accum) * min(vec3<f32>(1), bounce.voxel.color); */\r\n\t\t\taccum = accum * bounce.voxel.color\r\n\t\t\t\t+ bounce_results[i].voxel.lightness * bounce_results[i].voxel.color;\r\n\t\t\t// if (all(bounce.normal == vec3<f32>(0)) && all(bounce.ray_direction == vec3<f32>(0))){\r\n\t\t\t// \t// accum = textureSampleLevel(hdr_tex, hdr_sampler, sample_spherical_map(bounce_results[i].ray_direction), 0.0).rgb;\r\n\t\t\t// \taccum = vec3<f32>(0.5);\r\n\t\t\t// \tcontinue;\r\n\t\t\t// }\r\n\t\t\t// accum = accum * bounce.voxel.color;\r\n\t\t\t// accum = accum * bounce.voxel.color;\r\n\t\t}\r\n\treturn accum; // / f32(light_scatter_samples);\r\n}\r\n\r\nfn direct_illumination(orig_hit: RayHit, refl: ptr<function, f32>) -> vec3<f32> {\r\n\tvar hit: RayHit;\r\n\tif (!voxel_ray_any(Ray(orig_hit.position, scene.direct_light, 1 / scene.direct_light), 0.00001, &hit)){\r\n\t\treturn scene.direct_light_brightness * orig_hit.voxel.color;\r\n\t} else {\r\n\t\treturn 0.2 * orig_hit.voxel.color;\r\n\t}\r\n}\r\n\r\nfn voxel_ray_any(ray: Ray, start_tolerance: f32, hit: ptr<function, RayHit>) -> bool {\r\n\tvar tmin: f32 = 0.0;\r\n\tvar tmax: f32 = 300000000;\r\n\tfor (var d: i32 = 0; d < 3; d++) {\r\n\t\tlet t1 = (boundary_min[d] - ray.origin[d]) * ray.inv_direction[d];\r\n\t\tlet t2 = (boundary_max[d] - ray.origin[d]) * ray.inv_direction[d];\r\n\r\n\t\ttmin = min(max(t1, tmin), max(t2, tmin));\r\n\t\ttmax = max(min(t1, tmax), min(t2, tmax));\r\n\t}\r\n\t// Hier ist noch ein Fehler drin, tritt nur von ausserhalb des grid auf, das kommt ja vielleicht eh noch weg\r\n\tif tmin > tmax { return false; }\r\n    \tlet ray_entry = ray.origin + ray.direction * tmin;\r\n\tlet ray_exit = ray.origin + ray.direction * tmax;\r\n\r\n\tvar voxel: vec3<i32> = max(vec3<i32>(0), min(vec3<i32>(voxel_count - 1), vec3<i32>((ray_entry - boundary_min) / f32(voxel_size))));\r\n\t//var end_voxel: vec3<i32> = max(vec3<i32>(0), min(vec3<i32>(voxel_count - 1), vec3<i32>((ray_exit - boundary_min - ray.direction * 0.000001) / f32(voxel_size))));\r\n\r\n\tlet direction_zeros: vec3<bool> = ray.direction == vec3<f32>(0);\r\n\tlet step: vec3<i32> = vec3<i32>(sign(ray.direction));\r\n\tlet tdelta: vec3<f32> = select(voxel_size / abs(ray.direction), vec3<f32>(tmax), direction_zeros);\r\n\tlet voxel_boundary: vec3<f32> = vec3<f32>(voxel + max(vec3<i32>(0), step)) * voxel_size;\r\n\tvar tmax_comp: vec3<f32> = select(tmin + (boundary_min + voxel_boundary - ray_entry) / ray.direction, vec3<f32>(tmax), direction_zeros);\r\n\tvar thit: f32 = tmin;\r\n\tvar hit_normal: vec3<f32> = vec3<f32>(0, 0, 0);\r\n\r\n\twhile(all(voxel >= vec3<i32>(0)) && all(voxel < vec3<i32>(voxel_count))) {\r\n\t\tlet hit_voxel = get_voxel(voxel);\r\n\t\tif (hit_voxel.opacity > 0.01 && all(tmax_comp > vec3<f32>(start_tolerance))){\r\n\t\t\t(*hit).position = ray.origin + ray.direction * thit;\r\n\t\t\t(*hit).voxel = hit_voxel;\r\n\t\t\t(*hit).voxel_position = voxel;\r\n\t\t\t(*hit).depth = 1 - (thit - depth_clip_min) / (depth_clip_max - depth_clip_min);\r\n\t\t\t(*hit).normal = hit_normal;\r\n\t\t\t(*hit).ray_direction = ray.direction;\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\tif (tmax_comp.x < tmax_comp.y && tmax_comp.x < tmax_comp.z) {\r\n\t\t\tvoxel.x += step.x;\r\n\t\t\tthit = tmax_comp.x;\r\n\t\t\ttmax_comp.x += tdelta.x;\r\n\t\t\thit_normal = vec3<f32>(f32(-step.x), 0, 0);\r\n\t\t} else if (tmax_comp.y < tmax_comp.z){\r\n\t\t\tvoxel.y += step.y;\r\n\t\t\tthit = tmax_comp.y;\r\n\t\t\ttmax_comp.y += tdelta.y;\r\n\t\t\thit_normal = vec3<f32>(0, f32(-step.y), 0);\r\n\t\t} else {\r\n\t\t\tvoxel.z += step.z;\r\n\t\t\tthit = tmax_comp.z;\r\n\t\t\ttmax_comp.z += tdelta.z;\r\n\t\t\thit_normal = vec3<f32>(0, 0, f32(-step.z));\r\n\t\t}\r\n\t}\r\n\r\n\treturn false;\r\n}\r\n":"const ao_samples: i32 = 15;\r\nconst ao_range: f32 = 0.5;\r\n\r\nstruct penetration {\r\n\tcolor: vec3<f32>,\r\n\tao: f32,\r\n\topacity: f32,\r\n}\r\n\r\nfn gamma_correct(color: vec3<f32>) -> vec3<f32> {\r\n    return color / f32(samples);\r\n}\r\n\r\nfn trace(ray: Ray, depth: i32) -> TraceResult {\r\n\tvar hit: RayHit;\r\n\tvar bounces: array<RayHit, reflection_bounces>;\r\n\tvar curr_ray = ray;\r\n\tvar hits: i32 = 0;\r\n\tvar has_next_ray = true;\r\n\tvar penetrations: array<penetration, max_penetrations>;\r\n\tvar penetration_count = 0;\r\n\r\n\tfor (var p = 0; p < max_penetrations; p++){\r\n\t\tvar color = vec3<f32>(0.0);\r\n\t\tvar ao = 0f;\r\n\t\tvar first_hit: RayHit;\r\n\t\tfor (var i = 0; i < reflection_bounces; i++){\r\n\t\t\tif(voxel_ray_any(curr_ray, 0.001, &hit)){\r\n\t\t\t\tbounces[i] = hit;\r\n\t\t\t\tcurr_ray = ray_reflect(curr_ray, hit.position, hit.normal);\r\n\t\t\t\thits++;\r\n\t\t\t\tif (i == 0){\r\n\t\t\t\t\tfirst_hit = hit;\r\n\t\t\t\t}\r\n\t\t\t\tif (hit.voxel.roughness > 0.99){\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tcolor = scene.background_color;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (hits == 0){\r\n\t\t\tbreak;\r\n\t\t\t// return background;\r\n\t\t\t// return ray.direction;\r\n\t\t}\r\n\r\n\t\tfor (var i: i32 = hits; i >= 0; i--){\r\n\t\t\tlet t = bounces[i].voxel.roughness;\r\n\t\t\tcolor = color * (1 - t) + t * bounces[i].voxel.color * illumination(bounces[i].position);\r\n\t\t\t// color *= (1 - get_point_ao(bounces[i].position));\r\n\t\t\tif (i == 0){\r\n\t\t\t\tao = get_point_ao(bounces[0].position);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tfor (var l: i32 = 0; l < i32(scene.light_count); l++){\r\n\t\t\t\tlet light = lights.data[l];\r\n\t\t\t\tif i32(light.emitter_type) == 0 {\r\n\t\t\t\t\tlet light_voxel = get_voxel(vec3<i32>(light.location));\r\n\t\t\t\t\tlet light_voxel_location = light.location * voxel_size + boundary_min;\r\n\t\t\t\t\tlet light_voxel_location_top = light_voxel_location + voxel_size;\r\n\t\t\t\t\tlet light_voxel_location_mid = (light_voxel_location + light_voxel_location_top) / 2;\r\n\t\t\t\t\tlet lray_dir = light_voxel_location_mid - bounces[i].position;\r\n\t\t\t\t\tlet lray = Ray(bounces[i].position, lray_dir, 1 / lray_dir);\r\n\t\t\t\t\tvar lhit: RayHit;\r\n\t\t\t\t\tif (voxel_ray_any(lray, 0.001, &lhit) && all(lhit.voxel_position == vec3<i32>(light.location))){\r\n\t\t\t\t\t\tlet dist = distance(light_voxel_location_mid, bounces[i].position);\r\n\t\t\t\t\t\tlet intensity = 1 / pow(dist, 2) * lhit.voxel.lightness;\r\n\t\t\t\t\t\tcolor += light_voxel.color * vec3<f32>(intensity) * bounces[i].voxel.color;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tpenetrations[p] = penetration(color, ao, first_hit.voxel.opacity);\r\n\t\tpenetration_count++;\r\n\t\tcurr_ray = Ray(first_hit.exit_position, ray.direction, ray.inv_direction);\r\n\t\tif (first_hit.voxel.opacity > 0.99){\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\r\n\tif (penetration_count == 0){\r\n\t\treturn TraceResult(scene.background_color, 0);\r\n\t}\r\n\r\n\tvar color = penetrations[penetration_count].color;\r\n\tvar ao = penetrations[penetration_count].ao;\r\n\tfor (var i: i32 = penetration_count - 1; i >= 0; i--){\r\n\t\tcolor = penetrations[i].color * penetrations[i].opacity + color * (1 - penetrations[i].opacity);\r\n\t\tao = penetrations[i].ao * penetrations[i].opacity + ao * (1 - penetrations[i].opacity);\r\n\t}\r\n\r\n\treturn TraceResult(color, ao);\r\n\t// return color;\r\n}\r\n\r\nfn illumination(p: vec3<f32>) -> f32 {\r\n\tvar hit: RayHit;\r\n\tif (!voxel_ray_any(Ray(p, scene.direct_light, 1 / scene.direct_light), 0.001, &hit)){\r\n\t\treturn scene.direct_light_brightness;\r\n\t}\r\n\treturn 0.2;\r\n}\r\n\r\nfn voxel_ray_any(ray: Ray, start_tolerance: f32, hit: ptr<function, RayHit>) -> bool {\r\n\tvar tmin: f32 = 0.0;\r\n\tvar tmax: f32 = 300000000;\r\n\tfor (var d: i32 = 0; d < 3; d++) {\r\n\t\tlet t1 = (boundary_min[d] - ray.origin[d]) * ray.inv_direction[d];\r\n\t\tlet t2 = (boundary_max[d] - ray.origin[d]) * ray.inv_direction[d];\r\n\r\n\t\ttmin = min(max(t1, tmin), max(t2, tmin));\r\n\t\ttmax = max(min(t1, tmax), min(t2, tmax));\r\n\t}\r\n\t// Hier ist noch ein Fehler drin, tritt nur von ausserhalb des grid auf, das kommt ja vielleicht eh noch weg\r\n\tif tmin > tmax { return false; }\r\n    \tlet ray_entry = ray.origin + ray.direction * tmin;\r\n\tlet ray_exit = ray.origin + ray.direction * tmax;\r\n\r\n\tvar voxel: vec3<i32> = max(vec3<i32>(0), min(vec3<i32>(voxel_count - 1), vec3<i32>((ray_entry - boundary_min) / f32(voxel_size))));\r\n\t//var end_voxel: vec3<i32> = max(vec3<i32>(0), min(vec3<i32>(voxel_count - 1), vec3<i32>((ray_exit - boundary_min - ray.direction * 0.000001) / f32(voxel_size))));\r\n\r\n\tlet direction_zeros: vec3<bool> = ray.direction == vec3<f32>(0);\r\n\tlet step: vec3<i32> = vec3<i32>(sign(ray.direction));\r\n\tlet tdelta: vec3<f32> = select(voxel_size / abs(ray.direction), vec3<f32>(tmax), direction_zeros);\r\n\tlet voxel_boundary: vec3<f32> = vec3<f32>(voxel + max(vec3<i32>(0), step)) * voxel_size;\r\n\tvar tmax_comp: vec3<f32> = select(tmin + (boundary_min + voxel_boundary - ray_entry) / ray.direction, vec3<f32>(tmax), direction_zeros);\r\n\tvar thit: f32 = tmin;\r\n\tvar hit_normal: vec3<f32> = vec3<f32>(0, 0, 0);\r\n\r\n\twhile(all(voxel >= vec3<i32>(0)) && all(voxel < vec3<i32>(voxel_count))) {\r\n\t\tlet hit_voxel = get_voxel(voxel);\r\n\t\tif (hit_voxel.opacity > 0.01 && all(tmax_comp > vec3<f32>(start_tolerance))){\r\n\t\t\t(*hit).position = ray.origin + ray.direction * thit;\r\n\t\t\t(*hit).voxel = hit_voxel;\r\n\t\t\t(*hit).voxel_position = voxel;\r\n\t\t\t(*hit).depth = 1 - (thit - depth_clip_min) / (depth_clip_max - depth_clip_min);\r\n\t\t\t(*hit).normal = hit_normal;\r\n\t\t\t(*hit).ray_direction = ray.direction;\r\n\t\t\tif (tmax_comp.x < tmax_comp.y && tmax_comp.x < tmax_comp.z) {\r\n\t\t\t\t(*hit).exit_position = ray.origin + ray.direction * tmax_comp.x;\r\n\t\t\t} else if (tmax_comp.y < tmax_comp.z){\r\n\t\t\t\t(*hit).exit_position = ray.origin + ray.direction * tmax_comp.y;\r\n\t\t\t} else {\r\n\t\t\t\t(*hit).exit_position = ray.origin + ray.direction * tmax_comp.z;\r\n\t\t\t}\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\tif (tmax_comp.x < tmax_comp.y && tmax_comp.x < tmax_comp.z) {\r\n\t\t\tvoxel.x += step.x;\r\n\t\t\tthit = tmax_comp.x;\r\n\t\t\ttmax_comp.x += tdelta.x;\r\n\t\t\thit_normal = vec3<f32>(f32(-step.x), 0, 0);\r\n\t\t} else if (tmax_comp.y < tmax_comp.z){\r\n\t\t\tvoxel.y += step.y;\r\n\t\t\tthit = tmax_comp.y;\r\n\t\t\ttmax_comp.y += tdelta.y;\r\n\t\t\thit_normal = vec3<f32>(0, f32(-step.y), 0);\r\n\t\t} else {\r\n\t\t\tvoxel.z += step.z;\r\n\t\t\tthit = tmax_comp.z;\r\n\t\t\ttmax_comp.z += tdelta.z;\r\n\t\t\thit_normal = vec3<f32>(0, 0, f32(-step.z));\r\n\t\t}\r\n\t}\r\n\r\n\treturn false;\r\n}\r\n\r\nfn get_point_ao(point: vec3<f32>) -> f32 {\r\n\tvar ao: f32 = 0.0;\r\n\tfor (var i = 0; i < ao_samples; i++) {\r\n\t\tlet sample_point = random_unit_vector() * rng() * ao_range + point;\r\n\t\tao += get_voxel_by_position(sample_point).opacity;\r\n\t}\r\n\treturn max(0, ao / f32(ao_samples) - 0.5);\r\n}\r\n")}),constants:{grid_size:this.scene.grid_size,voxel_count:this.scene.voxel_count}}});const h=null===(a=this.device)||void 0===a?void 0:a.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.FRAGMENT,sampler:{}},{binding:1,visibility:GPUShaderStage.FRAGMENT,texture:{}},{binding:2,visibility:GPUShaderStage.FRAGMENT,texture:{}}]});this.screen_bind_group=null===(c=this.device)||void 0===c?void 0:c.createBindGroup({layout:h,entries:[{binding:0,resource:this.sampler},{binding:1,resource:this.color_buffer_view},{binding:2,resource:this.secondary_buffer_view}]});const d=null===(s=this.device)||void 0===s?void 0:s.createPipelineLayout({bindGroupLayouts:[h]});this.screen_pipeline=null===(l=this.device)||void 0===l?void 0:l.createRenderPipeline({layout:d,vertex:{module:this.device.createShaderModule({code:t}),entryPoint:"vert_main"},fragment:{module:this.device.createShaderModule({code:t}),entryPoint:"frag_main",targets:[{format:"bgra8unorm"}]},primitive:{topology:"triangle-list",cullMode:"back",frontFace:"cw"}})}))}}(it,at,ct.camera);at.initialize_default_grid(),st.initialize(!1);let lt=performance.now(),ut=!1;addEventListener("scroll",(()=>{document.documentElement.dataset.scroll=window.scrollY.toString()})),requestAnimationFrame((function t(){st.render();const e=performance.now()-lt;ct.tick(e/1e3),lt=performance.now(),ot.innerText=Math.round(1/e*1e3).toString()+" fps",requestAnimationFrame(t)})),addEventListener("mousedown",(t=>{2==t.button&&(ut=!0)}));let ht="mocha";const dt=document.getElementById("menu_switch_theme");null==dt||dt.addEventListener("click",(t=>{"mocha"===ht?(ht="latte",function(){const t=document.querySelector(":root");document.documentElement.dataset.theme="latte",t.style.setProperty("--ctp-crust","#dce0e8"),t.style.setProperty("--ctp-mantle","#e6e9ef"),t.style.setProperty("--ctp-base","#eff1f5"),t.style.setProperty("--ctp-surface0","#ccd0da"),t.style.setProperty("--ctp-surface1","#bcc0cc"),t.style.setProperty("--ctp-surface2","#acb0be"),t.style.setProperty("--ctp-overlay0","#9ca0b0"),t.style.setProperty("--ctp-overlay1","#8c8fa1"),t.style.setProperty("--ctp-overlay2","#7c7f93"),t.style.setProperty("--ctp-subtext0","#6c6f85"),t.style.setProperty("--ctp-subtext1","#5c5f77"),t.style.setProperty("--ctp-text","#4c4f69"),t.style.setProperty("--ctp-lavender","#7287fd"),t.style.setProperty("--ctp-blue","#1e66f5"),t.style.setProperty("--ctp-sapphire","#209fb5"),t.style.setProperty("--ctp-sky","#04a5e5"),t.style.setProperty("--ctp-teal","#179299"),t.style.setProperty("--ctp-green","#40a02b"),t.style.setProperty("--ctp-yellow","#df8e1d"),t.style.setProperty("--ctp-peach","#fe640b"),t.style.setProperty("--ctp-maroon","#e64553"),t.style.setProperty("--ctp-red","#d20f39"),t.style.setProperty("--ctp-mauve","#8839ef"),t.style.setProperty("--ctp-pink","#ea76cb"),t.style.setProperty("--ctp-flamingo","#dd7878"),t.style.setProperty("--ctp-rosewater","#dc8a78")}(),at.background_color=[239/255,241/255,245/255]):(ht="mocha",function(){const t=document.querySelector(":root");document.documentElement.dataset.theme="mocha",t.style.setProperty("--ctp-crust","#11111b"),t.style.setProperty("--ctp-mantle","#181825"),t.style.setProperty("--ctp-base","#1e1e2e"),t.style.setProperty("--ctp-surface0","#313244"),t.style.setProperty("--ctp-surface1","#45475a"),t.style.setProperty("--ctp-surface2","#585b70"),t.style.setProperty("--ctp-overlay0","#6c7086"),t.style.setProperty("--ctp-overlay1","#7f849c"),t.style.setProperty("--ctp-overlay2","#9399b2"),t.style.setProperty("--ctp-subtext0","#a6adc8"),t.style.setProperty("--ctp-subtext1","#bac2de"),t.style.setProperty("--ctp-text","#cdd6f4"),t.style.setProperty("--ctp-lavender","#b4befe"),t.style.setProperty("--ctp-blue","#89b4fa"),t.style.setProperty("--ctp-sapphire","#74c7ec"),t.style.setProperty("--ctp-sky","#89dceb"),t.style.setProperty("--ctp-teal","#94e2d5"),t.style.setProperty("--ctp-green","#a6e3a1"),t.style.setProperty("--ctp-yellow","#f9e2af"),t.style.setProperty("--ctp-peach","#fab387"),t.style.setProperty("--ctp-maroon","#eba0ac"),t.style.setProperty("--ctp-red","#f38ba8"),t.style.setProperty("--ctp-mauve","#cba6f7"),t.style.setProperty("--ctp-pink","#f5c2e7"),t.style.setProperty("--ctp-flamingo","#f2cdcd"),t.style.setProperty("--ctp-rosewater","#f5e0dc")}(),at.background_color=[30/255,30/255,46/255])})),at.background_color=[30/255,30/255,46/255];const _t=document.getElementById("menu_rescale_canvas");null==_t||_t.addEventListener("click",(t=>{document.querySelector(":root");const e=.8*Math.min(window.innerWidth,window.innerHeight);it.height=e,it.width=e,st.shutdown(),st.initialize(st.pathtracing)})),addEventListener("contextmenu",(t=>(t.preventDefault(),!1)))})();
//# sourceMappingURL=main.js.map