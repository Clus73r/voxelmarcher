{"version":3,"file":"main.js","mappings":"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","sources":["webpack://voxelraymarcher/./src/shaders/common.wgsl","webpack://voxelraymarcher/./src/shaders/screen_shader.wgsl","webpack://voxelraymarcher/./src/renderer.ts","webpack://voxelraymarcher/./node_modules/wgpu-matrix/dist/2.x/wgpu-matrix.module.js","webpack://voxelraymarcher/./src/scene.ts","webpack://voxelraymarcher/./src/math_util.ts","webpack://voxelraymarcher/./src/orbit_camera.ts","webpack://voxelraymarcher/./src/main.ts","webpack://voxelraymarcher/./src/controller.ts","webpack://voxelraymarcher/./src/shaders/path_trace_kernel.wgsl","webpack://voxelraymarcher/./src/shaders/ray_trace_kernel.wgsl","webpack://voxelraymarcher/./src/slice_renderer.ts","webpack://voxelraymarcher/./src/theme_switch.ts"],"sourcesContent":["export default \"@group(0) @binding(0) var color_buffer: texture_storage_2d<rgba8unorm, write>;\\r\\n@group(0) @binding(1) var<uniform> scene: SceneParameter;\\r\\n@group(0) @binding(2) var<storage, read> scene_data: SceneData;\\r\\n// @group(0) @binding(3) var hdr_tex: texture_2d<f32>;\\r\\n// @group(0) @binding(4) var hdr_sampler: sampler;\\r\\n@group(0) @binding(3) var<storage, read> lights: LightData;\\r\\n@group(0) @binding(4) var secondary_buffer: texture_storage_2d<rgba8unorm, write>;\\r\\n\\r\\noverride grid_size: f32 = 2f;\\r\\noverride voxel_count: i32 = 4;\\r\\nvar<private> voxel_size: f32 = grid_size / f32(voxel_count);\\r\\nvar<private> boundary_min: vec3<f32> = vec3<f32>(f32(-grid_size) / 2, f32(-grid_size) / 2, f32(-grid_size) / 2);\\r\\nvar<private> boundary_max: vec3<f32> = vec3<f32>(f32(grid_size) / 2, f32(grid_size) / 2, f32(grid_size) / 2);\\r\\nvar<private> depth_clip_min: f32 = 1f;\\r\\nvar<private> depth_clip_max: f32 = 10f;\\r\\n\\r\\nvar<private> rng_seed: u32;\\r\\nvar<private> rng_seed_steady: u32;\\r\\n\\r\\nconst samples: i32 = 1;\\r\\nconst light_bounces: i32 = 6;\\r\\nconst max_penetrations: i32 = 5;\\r\\nconst reflection_bounces: i32 = 5;\\r\\nconst scatter: i32 = 5;\\r\\nconst ambient_light: f32 = 0.03;\\r\\nconst pi = 3.14159265359;\\r\\n\\r\\n// const background: vec3<f32> = vec3<f32>(24f / 255f, 24f / 255f, 37f / 255f);\\r\\n\\r\\nstruct SceneParameter {\\r\\n    camera_pos: vec3<f32>,\\r\\n    rng_start: f32,\\r\\n    camera_forward: vec3<f32>,\\r\\n    light_count: f32,\\r\\n    camera_right: vec3<f32>,\\r\\n    camera_up: vec3<f32>,\\r\\n    direct_light: vec3<f32>,\\r\\n    direct_light_brightness: f32,\\r\\n\\tbackground_color: vec3<f32>,\\r\\n}\\r\\n\\r\\nstruct Voxel {\\r\\n\\tcolor: vec3<f32>,\\r\\n\\topacity: f32,\\r\\n\\troughness: f32,\\r\\n\\tlightness: f32,\\r\\n}\\r\\n\\r\\nstruct SceneData {\\r\\n\\tdata: array<Voxel>,\\r\\n}\\r\\n\\r\\nstruct LightData {\\r\\n\\tdata: array<Light>,\\r\\n}\\r\\n\\r\\nstruct Light {\\r\\n\\tlocation: vec3<f32>,\\r\\n\\temitter_type: f32,\\r\\n}\\r\\n\\r\\nstruct Ray {\\r\\n    origin: vec3<f32>,\\r\\n    direction: vec3<f32>,\\r\\n    inv_direction: vec3<f32>,\\r\\n}\\r\\n\\r\\nstruct RayHit {\\r\\n\\tposition: vec3<f32>,\\r\\n\\tdepth: f32,\\r\\n\\tvoxel_position: vec3<i32>,\\r\\n\\tvoxel: Voxel,\\r\\n\\tnormal: vec3<f32>,\\r\\n\\tray_direction: vec3<f32>,\\r\\n\\texit_position: vec3<f32>,\\r\\n}\\r\\n\\r\\nstruct TraceResult {\\r\\n\\tcolor: vec3<f32>,\\r\\n\\tao: f32,\\r\\n}\\r\\n\\r\\n@compute @workgroup_size(16,16,1)\\r\\nfn main(@builtin(global_invocation_id) GlobalInvocationID : vec3<u32>) {\\r\\n    let screen_size: vec2<u32> = textureDimensions(color_buffer);\\r\\n    let screen_pos : vec2<i32> = vec2<i32>(i32(GlobalInvocationID.x), i32(GlobalInvocationID.y));\\r\\n    // rng_seed = GlobalInvocationID.x + 50 + (GlobalInvocationID.y + 50) * (GlobalInvocationID.x + 100) * 1000 * u32(scene.rng_start);\\r\\n    rng_seed = GlobalInvocationID.x + 50 + (GlobalInvocationID.y + 50) * (GlobalInvocationID.x + 100) * 1000;\\r\\n    rng_seed_steady = GlobalInvocationID.x + 150 + (GlobalInvocationID.y + 75) * (GlobalInvocationID.x + 350) * 1000;\\r\\n\\r\\n    var pixel_color: vec3<f32>;\\r\\n    var pixel_ao: f32;\\r\\n    for (var i = 0; i < samples; i++){\\r\\n\\r\\n\\t    let rng_offset: vec2<f32> = select(vec2<f32>(0), vec2<f32>(rng() - 0.5, rng() - 0.5), samples > 1);\\r\\n\\t    let horizontal_coefficient: f32 = (f32(screen_pos.x) + rng_offset.x - f32(screen_size.x) / 2) / f32(screen_size.x);\\r\\n\\t    let vertical_coefficient: f32 = (f32(screen_pos.y) + rng_offset.y - f32(screen_size.y) / 2) / -f32(screen_size.y);\\r\\n\\r\\n\\t    let ray_direction = normalize(scene.camera_forward\\r\\n\\t\\t\\t    + horizontal_coefficient * scene.camera_right\\r\\n\\t\\t\\t    + vertical_coefficient * scene.camera_up);\\r\\n\\t    let ray: Ray = Ray(scene.camera_pos, ray_direction, 1 / ray_direction);\\r\\n\\t    let trace_result = trace(ray, light_bounces);\\r\\n\\t    // pixel_color += trace(ray, light_bounces);\\r\\n\\t    pixel_color += trace_result.color;\\r\\n\\t    pixel_ao += trace_result.ao;\\r\\n    }\\r\\n\\r\\n    // let correction = 1.0 / f32(samples);\\r\\n    // pixel_color = sqrt(correction * pixel_color);\\r\\n\\r\\n\\tpixel_color /= f32(samples);\\r\\n\\tpixel_ao /= f32(samples);\\r\\n\\r\\n    /* pixel_color = textureSampleLevel(hdr_tex, hdr_sampler, vec2<f32>(f32(GlobalInvocationID.x) / f32(screen_size.x), f32(GlobalInvocationID.y) / f32(screen_size.y) * 2), 0.0).rgb; */\\r\\n\\r\\n    textureStore(color_buffer, screen_pos, vec4<f32>(pixel_color, 1.0));\\r\\n    textureStore(secondary_buffer, screen_pos, vec4<f32>(pixel_ao, 0, 0, 1.0));\\r\\n}\\r\\n\\r\\nfn rng_hash(seed: u32) -> u32 {\\r\\n\\tvar x = ( seed << 10u );\\r\\n\\tx ^= ( x >>  6u );\\r\\n\\tx += ( x <<  3u );\\r\\n\\tx ^= ( x >> 11u );\\r\\n\\tx += ( x << 15u );\\r\\n\\treturn x;\\r\\n}\\r\\n\\r\\nfn rng() -> f32 {\\r\\n\\trng_seed++;\\r\\n\\treturn bitcast<f32>((rng_hash(rng_seed) >> 9) | 0x3f800000 ) - 1.0;\\r\\n}\\r\\n\\r\\nfn rng_steady() -> f32 {\\r\\n\\trng_seed_steady++;\\r\\n\\treturn bitcast<f32>((rng_hash(rng_seed_steady) >> 9) | 0x3f800000 ) - 1.0;\\r\\n}\\r\\n\\r\\nfn ray_reflect(ray: Ray, position: vec3<f32>, normal: vec3<f32>) -> Ray {\\r\\n\\tlet reflect = ray.direction - 2 * dot(ray.direction, normal) * normal;\\r\\n\\treturn Ray(position, reflect, 1 / reflect);\\r\\n}\\r\\n\\r\\nfn get_voxel_id(v: vec3<i32>) -> i32 {\\r\\n\\treturn v.z * voxel_count * voxel_count + v.y * voxel_count + v.x;\\r\\n}\\r\\n\\r\\nfn get_voxel(v: vec3<i32>) -> Voxel {\\r\\n\\treturn scene_data.data[v.z * voxel_count * voxel_count + v.y * voxel_count + v.x];\\r\\n}\\r\\n\\r\\nfn get_voxel_by_position(v: vec3<f32>) -> Voxel {\\r\\n\\treturn get_voxel(vec3<i32>((v - boundary_min) / f32(voxel_size)));\\r\\n}\\r\\n\\r\\nfn sample_spherical_map(v: vec3<f32>) -> vec2<f32> {\\r\\n\\tlet theta = atan2(v.x, v.y);\\r\\n\\tlet phi = acos(v.z);\\r\\n\\tlet raw_u = theta / (2 * pi);\\r\\n\\tlet uv = vec2<f32>(\\r\\n\\t\\t1 - (raw_u + 0.5),\\r\\n\\t\\tphi / pi\\r\\n\\t);\\r\\n\\treturn uv;\\r\\n}\\r\\n\\r\\nfn random_unit_vector() -> vec3<f32> {\\r\\n\\tlet phi = rng() * pi * 2;\\r\\n\\tlet costheta = rng() * 2 - 1;\\r\\n\\t\\tlet theta = acos(costheta);\\r\\n\\tlet x = sin(theta) * cos(phi);\\r\\n\\tlet y = sin(theta) * sin(phi);\\r\\n\\tlet z = cos(theta);\\r\\n\\treturn vec3<f32>(x, y, z);\\r\\n}\\r\\n\"","export default \"@group(0) @binding(0) var screen_sampler : sampler;\\r\\n@group(0) @binding(1) var color_buffer : texture_2d<f32>;\\r\\n@group(0) @binding(2) var secondary_buffer : texture_2d<f32>;\\r\\n\\r\\nstruct VertexOutput {\\r\\n        @builtin(position) Position : vec4<f32>,\\r\\n            @location(0) TexCoord : vec2<f32>,\\r\\n}\\r\\n\\r\\n@vertex\\r\\nfn vert_main(@builtin(vertex_index) VertexIndex : u32) -> VertexOutput {\\r\\n    var positions = array<vec2<f32>, 6>(\\r\\n        vec2<f32>( 1.0,  1.0),\\r\\n        vec2<f32>( 1.0, -1.0),\\r\\n        vec2<f32>(-1.0, -1.0),\\r\\n        vec2<f32>( 1.0,  1.0),\\r\\n        vec2<f32>(-1.0, -1.0),\\r\\n        vec2<f32>(-1.0,  1.0)\\r\\n    );\\r\\n\\r\\n    var texCoords = array<vec2<f32>, 6>(\\r\\n        vec2<f32>(1.0, 0.0),\\r\\n        vec2<f32>(1.0, 1.0),\\r\\n        vec2<f32>(0.0, 1.0),\\r\\n        vec2<f32>(1.0, 0.0),\\r\\n        vec2<f32>(0.0, 1.0),\\r\\n        vec2<f32>(0.0, 0.0)\\r\\n    );\\r\\n\\r\\n    var output : VertexOutput;\\r\\n    output.Position = vec4<f32>(positions[VertexIndex], 0.0, 1.0);\\r\\n    output.TexCoord = texCoords[VertexIndex];\\r\\n    return output;\\r\\n}\\r\\n\\r\\nconst ao_blur_steps = 7;\\r\\nconst ao_blur_radius = 0.00f / f32(ao_blur_steps);\\r\\nconst ao_strength = 1;\\r\\n\\r\\n@fragment\\r\\nfn frag_main(@location(0) TexCoord : vec2<f32>) -> @location(0) vec4<f32> {\\r\\n\\tvar acc = 0f;\\r\\n\\tlet blur_offset = (ao_blur_radius * f32(ao_blur_steps)) / 2;\\r\\n\\tfor (var x = 0; x < ao_blur_steps; x++){\\r\\n\\t\\tfor (var y = 0; y < ao_blur_steps; y++){\\r\\n\\t\\t\\tacc += textureSample(secondary_buffer, screen_sampler, vec2<f32>(TexCoord.x - blur_offset + ao_blur_radius * f32(x), TexCoord.y - blur_offset + ao_blur_radius * f32(y))).x;\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\tacc /= f32(ao_blur_steps) * f32(ao_blur_steps);\\r\\n\\r\\n    // return vec4<f32>(acc, acc, acc, 1.0);\\r\\n    return textureSample(color_buffer, screen_sampler, TexCoord) * (1 - acc * ao_strength);\\r\\n}\\r\\n\"","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport common from \"./shaders/common.wgsl\";\nimport ray_trace_kernel from \"./shaders/ray_trace_kernel.wgsl\";\nimport path_trace_kernel from \"./shaders/path_trace_kernel.wgsl\";\nimport screen_shader from \"./shaders/screen_shader.wgsl\";\nexport class Renderer {\n    constructor(canvas, scene, camera) {\n        // hdrtexture: HDRTexture;\n        this.initialized = false;\n        this.render = () => {\n            var _a, _b, _c, _d, _e, _f;\n            if (!this.initialized)\n                return;\n            let lights = [];\n            for (let x = 0; x < this.scene.voxel_count; x++) {\n                for (let y = 0; y < this.scene.voxel_count; y++) {\n                    for (let z = 0; z < this.scene.voxel_count; z++) {\n                        if (this.scene.get_voxel([x, y, z]).lightness > 0) {\n                            lights.push([x, y, z]);\n                        }\n                    }\n                }\n            }\n            (_a = this.device) === null || _a === void 0 ? void 0 : _a.queue.writeBuffer(this.sceneParameters, 0, new Float32Array([\n                this.camera.position[0],\n                this.camera.position[1],\n                this.camera.position[2],\n                new Date().getMilliseconds(),\n                this.camera.forward[0],\n                this.camera.forward[1],\n                this.camera.forward[2],\n                lights.length,\n                this.camera.right[0],\n                this.camera.right[1],\n                this.camera.right[2],\n                0.0,\n                this.camera.up[0],\n                this.camera.up[1],\n                this.camera.up[2],\n                0.0,\n                this.scene.direct_light[0],\n                this.scene.direct_light[1],\n                this.scene.direct_light[2],\n                this.scene.direct_light_brightness,\n                this.scene.background_color[0],\n                this.scene.background_color[1],\n                this.scene.background_color[2],\n                0.0,\n            ]), 0, 24);\n            const light_data = new Float32Array(4 * lights.length);\n            for (let i = 0; i < lights.length; ++i) {\n                light_data[4 * i] = lights[i][0];\n                light_data[4 * i + 1] = lights[i][1];\n                light_data[4 * i + 2] = lights[i][2];\n                light_data[4 * i + 3] = 0;\n            }\n            (_b = this.device) === null || _b === void 0 ? void 0 : _b.queue.writeBuffer(this.lightData, 0, light_data, 0, lights.length * 4);\n            const scene_data = new Float32Array(8 * this.scene.grid.length);\n            for (let i = 0; i < this.scene.grid.length; ++i) {\n                scene_data[8 * i] = this.scene.grid[i].color[0];\n                scene_data[8 * i + 1] = this.scene.grid[i].color[1];\n                scene_data[8 * i + 2] = this.scene.grid[i].color[2];\n                scene_data[8 * i + 3] = this.scene.grid[i].opacity;\n                scene_data[8 * i + 4] = this.scene.grid[i].roughness;\n                scene_data[8 * i + 5] = this.scene.grid[i].lightness;\n                scene_data[8 * i + 6] = 0;\n                scene_data[8 * i + 7] = 0;\n            }\n            (_c = this.device) === null || _c === void 0 ? void 0 : _c.queue.writeBuffer(this.sceneData, 0, scene_data, 0, this.scene.grid.length * 8);\n            const commandEncoder = (_d = this.device) === null || _d === void 0 ? void 0 : _d.createCommandEncoder();\n            const ray_trace_pass = commandEncoder === null || commandEncoder === void 0 ? void 0 : commandEncoder.beginComputePass();\n            ray_trace_pass === null || ray_trace_pass === void 0 ? void 0 : ray_trace_pass.setPipeline(this.ray_tracing_pipeline);\n            ray_trace_pass === null || ray_trace_pass === void 0 ? void 0 : ray_trace_pass.setBindGroup(0, this.ray_tracing_bind_group);\n            ray_trace_pass === null || ray_trace_pass === void 0 ? void 0 : ray_trace_pass.dispatchWorkgroups(this.canvas.width / 16, this.canvas.height / 16, 1);\n            ray_trace_pass === null || ray_trace_pass === void 0 ? void 0 : ray_trace_pass.end();\n            const textureView = (_e = this.context) === null || _e === void 0 ? void 0 : _e.getCurrentTexture().createView();\n            const renderPass = commandEncoder === null || commandEncoder === void 0 ? void 0 : commandEncoder.beginRenderPass({\n                colorAttachments: [\n                    {\n                        view: textureView,\n                        clearValue: { r: 0.5, g: 0.0, b: 0.25, a: 1.0 },\n                        loadOp: \"clear\",\n                        storeOp: \"store\",\n                    },\n                ],\n            });\n            renderPass === null || renderPass === void 0 ? void 0 : renderPass.setPipeline(this.screen_pipeline);\n            renderPass === null || renderPass === void 0 ? void 0 : renderPass.setBindGroup(0, this.screen_bind_group);\n            renderPass === null || renderPass === void 0 ? void 0 : renderPass.draw(6, 1, 0, 0);\n            renderPass === null || renderPass === void 0 ? void 0 : renderPass.end();\n            (_f = this.device) === null || _f === void 0 ? void 0 : _f.queue.submit([commandEncoder === null || commandEncoder === void 0 ? void 0 : commandEncoder.finish()]);\n        };\n        this.canvas = canvas;\n        this.scene = scene;\n        this.pathtracing = false;\n        this.camera = camera;\n        // this.hdrtexture = new HDRTexture();\n    }\n    initialize(pathtracing) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.pathtracing = pathtracing;\n            yield this.setupDevice();\n            yield this.createAssets();\n            yield this.setupPipeline();\n            this.initialized = true;\n        });\n    }\n    set_hdr(hdr) { }\n    shutdown() {\n        var _a, _b, _c;\n        this.initialized = false;\n        (_a = this.device) === null || _a === void 0 ? void 0 : _a.destroy();\n        (_b = this.color_buffer) === null || _b === void 0 ? void 0 : _b.destroy();\n        (_c = this.secondary_buffer) === null || _c === void 0 ? void 0 : _c.destroy();\n    }\n    setupDevice() {\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function* () {\n            this.adapter = (yield ((_a = navigator.gpu) === null || _a === void 0 ? void 0 : _a.requestAdapter()));\n            this.device = yield ((_b = this.adapter) === null || _b === void 0 ? void 0 : _b.requestDevice());\n            this.context = this.canvas.getContext(\"webgpu\");\n            this.format = \"bgra8unorm\";\n            this.context.configure({\n                device: this.device,\n                format: this.format,\n                alphaMode: \"opaque\",\n            });\n        });\n    }\n    createAssets() {\n        var _a, _b, _c, _d, _e, _f, _g, _h;\n        return __awaiter(this, void 0, void 0, function* () {\n            this.color_buffer = (_a = this.device) === null || _a === void 0 ? void 0 : _a.createTexture({\n                size: { width: this.canvas.width, height: this.canvas.height },\n                format: \"rgba8unorm\",\n                usage: GPUTextureUsage.COPY_DST |\n                    GPUTextureUsage.STORAGE_BINDING |\n                    GPUTextureUsage.TEXTURE_BINDING,\n            });\n            this.secondary_buffer = (_b = this.device) === null || _b === void 0 ? void 0 : _b.createTexture({\n                size: { width: this.canvas.width, height: this.canvas.height },\n                format: \"rgba8unorm\",\n                usage: GPUTextureUsage.COPY_DST |\n                    GPUTextureUsage.STORAGE_BINDING |\n                    GPUTextureUsage.TEXTURE_BINDING,\n            });\n            this.color_buffer_view = (_c = this.color_buffer) === null || _c === void 0 ? void 0 : _c.createView();\n            this.secondary_buffer_view = (_d = this.secondary_buffer) === null || _d === void 0 ? void 0 : _d.createView();\n            this.sampler = (_e = this.device) === null || _e === void 0 ? void 0 : _e.createSampler({\n                addressModeU: \"repeat\",\n                addressModeV: \"repeat\",\n                magFilter: \"linear\",\n                minFilter: \"nearest\",\n                mipmapFilter: \"nearest\",\n                maxAnisotropy: 1,\n            });\n            this.sceneParameters = (_f = this.device) === null || _f === void 0 ? void 0 : _f.createBuffer({\n                size: 96,\n                usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\n            });\n            const scene_size = this.scene.voxel_count * this.scene.voxel_count * this.scene.voxel_count;\n            this.sceneData = (_g = this.device) === null || _g === void 0 ? void 0 : _g.createBuffer({\n                size: scene_size * 8 * 4,\n                usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\n            });\n            this.lightData = (_h = this.device) === null || _h === void 0 ? void 0 : _h.createBuffer({\n                size: 128 * 4,\n                usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\n            });\n        });\n    }\n    setupPipeline() {\n        var _a, _b, _c, _d, _e, _f, _g, _h;\n        return __awaiter(this, void 0, void 0, function* () {\n            const ray_tracing_bind_group = ((_a = this.device) === null || _a === void 0 ? void 0 : _a.createBindGroupLayout({\n                entries: [\n                    {\n                        binding: 0,\n                        visibility: GPUShaderStage.COMPUTE,\n                        storageTexture: {\n                            access: \"write-only\",\n                            format: \"rgba8unorm\",\n                            viewDimension: \"2d\",\n                        },\n                    },\n                    {\n                        binding: 1,\n                        visibility: GPUShaderStage.COMPUTE,\n                        buffer: {\n                            type: \"uniform\",\n                        },\n                    },\n                    {\n                        binding: 2,\n                        visibility: GPUShaderStage.COMPUTE,\n                        buffer: {\n                            type: \"read-only-storage\",\n                        },\n                    },\n                    // {\n                    //   binding: 3,\n                    //   visibility: GPUShaderStage.COMPUTE,\n                    //   texture: {},\n                    // },\n                    // {\n                    //   binding: 4,\n                    //   visibility: GPUShaderStage.COMPUTE,\n                    //   sampler: {},\n                    // },\n                    {\n                        binding: 3,\n                        visibility: GPUShaderStage.COMPUTE,\n                        buffer: {\n                            type: \"read-only-storage\",\n                        },\n                    },\n                    {\n                        binding: 4,\n                        visibility: GPUShaderStage.COMPUTE,\n                        storageTexture: {\n                            access: \"write-only\",\n                            format: \"rgba8unorm\",\n                            viewDimension: \"2d\",\n                        },\n                    },\n                ],\n            }));\n            this.ray_tracing_bind_group = (_b = this.device) === null || _b === void 0 ? void 0 : _b.createBindGroup({\n                layout: ray_tracing_bind_group,\n                label: \"Ray tracing bind group\",\n                entries: [\n                    { binding: 0, resource: this.color_buffer_view },\n                    {\n                        binding: 1,\n                        resource: { buffer: this.sceneParameters },\n                    },\n                    { binding: 2, resource: { buffer: this.sceneData } },\n                    // {\n                    //   binding: 3,\n                    //   resource: <GPUTextureView>this.hdrtexture.view,\n                    // },\n                    // {\n                    //   binding: 4,\n                    //   resource: <GPUSampler>this.hdrtexture.sampler,\n                    // },\n                    {\n                        binding: 3,\n                        resource: { buffer: this.lightData },\n                    },\n                    {\n                        binding: 4,\n                        resource: this.secondary_buffer_view,\n                    },\n                ],\n            });\n            const ray_tracing_pipline_layout = ((_c = this.device) === null || _c === void 0 ? void 0 : _c.createPipelineLayout({\n                bindGroupLayouts: [ray_tracing_bind_group],\n            }));\n            this.ray_tracing_pipeline = ((_d = this.device) === null || _d === void 0 ? void 0 : _d.createComputePipeline({\n                label: \"Ray tracing pipeline\",\n                layout: ray_tracing_pipline_layout,\n                compute: {\n                    entryPoint: \"main\",\n                    module: this.device.createShaderModule({\n                        code: common +\n                            (!this.pathtracing ? ray_trace_kernel : path_trace_kernel),\n                    }),\n                    constants: {\n                        grid_size: this.scene.grid_size,\n                        voxel_count: this.scene.voxel_count,\n                    },\n                },\n            }));\n            const screen_bind_group_layout = ((_e = this.device) === null || _e === void 0 ? void 0 : _e.createBindGroupLayout({\n                entries: [\n                    { binding: 0, visibility: GPUShaderStage.FRAGMENT, sampler: {} },\n                    { binding: 1, visibility: GPUShaderStage.FRAGMENT, texture: {} },\n                    { binding: 2, visibility: GPUShaderStage.FRAGMENT, texture: {} },\n                ],\n            }));\n            this.screen_bind_group = (_f = this.device) === null || _f === void 0 ? void 0 : _f.createBindGroup({\n                layout: screen_bind_group_layout,\n                entries: [\n                    { binding: 0, resource: this.sampler },\n                    { binding: 1, resource: this.color_buffer_view },\n                    {\n                        binding: 2,\n                        resource: this.secondary_buffer_view,\n                    },\n                ],\n            });\n            const screen_pipeline_layout = ((_g = this.device) === null || _g === void 0 ? void 0 : _g.createPipelineLayout({\n                bindGroupLayouts: [screen_bind_group_layout],\n            }));\n            this.screen_pipeline = (_h = this.device) === null || _h === void 0 ? void 0 : _h.createRenderPipeline({\n                layout: screen_pipeline_layout,\n                vertex: {\n                    module: this.device.createShaderModule({ code: screen_shader }),\n                    entryPoint: \"vert_main\",\n                },\n                fragment: {\n                    module: this.device.createShaderModule({ code: screen_shader }),\n                    entryPoint: \"frag_main\",\n                    targets: [{ format: \"bgra8unorm\" }],\n                },\n                primitive: {\n                    topology: \"triangle-list\",\n                    cullMode: \"back\",\n                    frontFace: \"cw\",\n                },\n            });\n        });\n    }\n}\n","/* wgpu-matrix@2.2.2, license MIT */\nvar arrayLike = /*#__PURE__*/Object.freeze({\n    __proto__: null\n});\n\n/*\n * Copyright 2022 Gregg Tavares\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\nlet EPSILON = 0.000001;\n/**\n * Set the value for EPSILON for various checks\n * @param v - Value to use for EPSILON.\n * @returns previous value of EPSILON;\n */\nfunction setEpsilon(v) {\n    const old = EPSILON;\n    EPSILON = v;\n    return old;\n}\n/**\n * Convert degrees to radians\n * @param degrees - Angle in degrees\n * @returns angle converted to radians\n */\nfunction degToRad(degrees) {\n    return degrees * Math.PI / 180;\n}\n/**\n * Convert radians to degrees\n * @param radians - Angle in radians\n * @returns angle converted to degrees\n */\nfunction radToDeg(radians) {\n    return radians * 180 / Math.PI;\n}\n/**\n * Lerps between a and b via t\n * @param a - starting value\n * @param b - ending value\n * @param t - value where 0 = a and 1 = b\n * @returns a + (b - a) * t\n */\nfunction lerp$4(a, b, t) {\n    return a + (b - a) * t;\n}\n/**\n * Compute the opposite of lerp. Given a and b and a value between\n * a and b returns a value between 0 and 1. 0 if a, 1 if b.\n * Note: no clamping is done.\n * @param a - start value\n * @param b - end value\n * @param v - value between a and b\n * @returns (v - a) / (b - a)\n */\nfunction inverseLerp(a, b, v) {\n    const d = b - a;\n    return (Math.abs(b - a) < EPSILON)\n        ? a\n        : (v - a) / d;\n}\n/**\n * Compute the euclidean modulo\n *\n * ```\n * // table for n / 3\n * -5, -4, -3, -2, -1,  0,  1,  2,  3,  4,  5   <- n\n * ------------------------------------\n * -2  -1  -0  -2  -1   0,  1,  2,  0,  1,  2   <- n % 3\n *  1   2   0   1   2   0,  1,  2,  0,  1,  2   <- euclideanModule(n, 3)\n * ```\n *\n * @param n - dividend\n * @param m - divisor\n * @returns the euclidean modulo of n / m\n */\nfunction euclideanModulo(n, m) {\n    return ((n % m) + m) % m;\n}\n\nvar utils = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    get EPSILON () { return EPSILON; },\n    degToRad: degToRad,\n    euclideanModulo: euclideanModulo,\n    inverseLerp: inverseLerp,\n    lerp: lerp$4,\n    radToDeg: radToDeg,\n    setEpsilon: setEpsilon\n});\n\n/**\n *\n * Vec2 math functions.\n *\n * Almost all functions take an optional `dst` argument. If it is not passed in the\n * functions will create a new Vec2. In other words you can do this\n *\n *     const v = vec2.cross(v1, v2);  // Creates a new Vec2 with the cross product of v1 x v2.\n *\n * or\n *\n *     const v = vec2.create();\n *     vec2.cross(v1, v2, v);  // Puts the cross product of v1 x v2 in v\n *\n * The first style is often easier but depending on where it's used it generates garbage where\n * as there is almost never allocation with the second style.\n *\n * It is always safe to pass any vector as the destination. So for example\n *\n *     vec2.cross(v1, v2, v1);  // Puts the cross product of v1 x v2 in v1\n *\n */\nlet VecType$2 = Float32Array;\n/**\n * Sets the type this library creates for a Vec2\n * @param ctor - the constructor for the type. Either `Float32Array`, `Float64Array`, or `Array`\n * @returns previous constructor for Vec2\n */\nfunction setDefaultType$6(ctor) {\n    const oldType = VecType$2;\n    VecType$2 = ctor;\n    return oldType;\n}\n/**\n * Creates a Vec2; may be called with x, y, z to set initial values.\n *\n * Note: Since passing in a raw JavaScript array\n * is valid in all circumstances, if you want to\n * force a JavaScript array into a Vec2's specified type\n * it would be faster to use\n *\n * ```\n * const v = vec2.clone(someJSArray);\n * ```\n *\n * Note: a consequence of the implementation is if your Vec2Type = `Array`\n * instead of `Float32Array` or `Float64Array` then any values you\n * don't pass in will be undefined. Usually this is not an issue since\n * (a) using `Array` is rare and (b) using `vec2.create` is usually used\n * to create a Vec2 to be filled out as in\n *\n * ```\n * const sum = vec2.create();\n * vec2.add(v1, v2, sum);\n * ```\n *\n * @param x - Initial x value.\n * @param y - Initial y value.\n * @returns the created vector\n */\nfunction create$5(x = 0, y = 0) {\n    const dst = new VecType$2(2);\n    if (x !== undefined) {\n        dst[0] = x;\n        if (y !== undefined) {\n            dst[1] = y;\n        }\n    }\n    return dst;\n}\n\n/*\n * Copyright 2022 Gregg Tavares\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n/**\n * Creates a Vec2; may be called with x, y, z to set initial values. (same as create)\n * @param x - Initial x value.\n * @param y - Initial y value.\n * @returns the created vector\n */\nconst fromValues$3 = create$5;\n/**\n * Applies Math.ceil to each element of vector\n * @param v - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that is the ceil of each element of v.\n */\nfunction ceil$2(v, dst) {\n    dst = dst || new VecType$2(2);\n    dst[0] = Math.ceil(v[0]);\n    dst[1] = Math.ceil(v[1]);\n    return dst;\n}\n/**\n * Applies Math.floor to each element of vector\n * @param v - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that is the floor of each element of v.\n */\nfunction floor$2(v, dst) {\n    dst = dst || new VecType$2(2);\n    dst[0] = Math.floor(v[0]);\n    dst[1] = Math.floor(v[1]);\n    return dst;\n}\n/**\n * Applies Math.round to each element of vector\n * @param v - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that is the round of each element of v.\n */\nfunction round$2(v, dst) {\n    dst = dst || new VecType$2(2);\n    dst[0] = Math.round(v[0]);\n    dst[1] = Math.round(v[1]);\n    return dst;\n}\n/**\n * Clamp each element of vector between min and max\n * @param v - Operand vector.\n * @param max - Min value, default 0\n * @param min - Max value, default 1\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that the clamped value of each element of v.\n */\nfunction clamp$2(v, min = 0, max = 1, dst) {\n    dst = dst || new VecType$2(2);\n    dst[0] = Math.min(max, Math.max(min, v[0]));\n    dst[1] = Math.min(max, Math.max(min, v[1]));\n    return dst;\n}\n/**\n * Adds two vectors; assumes a and b have the same dimension.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that is the sum of a and b.\n */\nfunction add$3(a, b, dst) {\n    dst = dst || new VecType$2(2);\n    dst[0] = a[0] + b[0];\n    dst[1] = a[1] + b[1];\n    return dst;\n}\n/**\n * Adds two vectors, scaling the 2nd; assumes a and b have the same dimension.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param scale - Amount to scale b\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that is the sum of a + b * scale.\n */\nfunction addScaled$2(a, b, scale, dst) {\n    dst = dst || new VecType$2(2);\n    dst[0] = a[0] + b[0] * scale;\n    dst[1] = a[1] + b[1] * scale;\n    return dst;\n}\n/**\n * Returns the angle in radians between two vectors.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @returns The angle in radians between the 2 vectors.\n */\nfunction angle$2(a, b) {\n    const ax = a[0];\n    const ay = a[1];\n    const bx = a[0];\n    const by = a[1];\n    const mag1 = Math.sqrt(ax * ax + ay * ay);\n    const mag2 = Math.sqrt(bx * bx + by * by);\n    const mag = mag1 * mag2;\n    const cosine = mag && dot$3(a, b) / mag;\n    return Math.acos(cosine);\n}\n/**\n * Subtracts two vectors.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that is the difference of a and b.\n */\nfunction subtract$3(a, b, dst) {\n    dst = dst || new VecType$2(2);\n    dst[0] = a[0] - b[0];\n    dst[1] = a[1] - b[1];\n    return dst;\n}\n/**\n * Subtracts two vectors.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that is the difference of a and b.\n */\nconst sub$3 = subtract$3;\n/**\n * Check if 2 vectors are approximately equal\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @returns true if vectors are approximately equal\n */\nfunction equalsApproximately$5(a, b) {\n    return Math.abs(a[0] - b[0]) < EPSILON &&\n        Math.abs(a[1] - b[1]) < EPSILON;\n}\n/**\n * Check if 2 vectors are exactly equal\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @returns true if vectors are exactly equal\n */\nfunction equals$5(a, b) {\n    return a[0] === b[0] && a[1] === b[1];\n}\n/**\n * Performs linear interpolation on two vectors.\n * Given vectors a and b and interpolation coefficient t, returns\n * a + t * (b - a).\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param t - Interpolation coefficient.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The linear interpolated result.\n */\nfunction lerp$3(a, b, t, dst) {\n    dst = dst || new VecType$2(2);\n    dst[0] = a[0] + t * (b[0] - a[0]);\n    dst[1] = a[1] + t * (b[1] - a[1]);\n    return dst;\n}\n/**\n * Performs linear interpolation on two vectors.\n * Given vectors a and b and interpolation coefficient vector t, returns\n * a + t * (b - a).\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param t - Interpolation coefficients vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns the linear interpolated result.\n */\nfunction lerpV$2(a, b, t, dst) {\n    dst = dst || new VecType$2(2);\n    dst[0] = a[0] + t[0] * (b[0] - a[0]);\n    dst[1] = a[1] + t[1] * (b[1] - a[1]);\n    return dst;\n}\n/**\n * Return max values of two vectors.\n * Given vectors a and b returns\n * [max(a[0], b[0]), max(a[1], b[1]), max(a[2], b[2])].\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The max components vector.\n */\nfunction max$2(a, b, dst) {\n    dst = dst || new VecType$2(2);\n    dst[0] = Math.max(a[0], b[0]);\n    dst[1] = Math.max(a[1], b[1]);\n    return dst;\n}\n/**\n * Return min values of two vectors.\n * Given vectors a and b returns\n * [min(a[0], b[0]), min(a[1], b[1]), min(a[2], b[2])].\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The min components vector.\n */\nfunction min$2(a, b, dst) {\n    dst = dst || new VecType$2(2);\n    dst[0] = Math.min(a[0], b[0]);\n    dst[1] = Math.min(a[1], b[1]);\n    return dst;\n}\n/**\n * Multiplies a vector by a scalar.\n * @param v - The vector.\n * @param k - The scalar.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The scaled vector.\n */\nfunction mulScalar$3(v, k, dst) {\n    dst = dst || new VecType$2(2);\n    dst[0] = v[0] * k;\n    dst[1] = v[1] * k;\n    return dst;\n}\n/**\n * Multiplies a vector by a scalar. (same as mulScalar)\n * @param v - The vector.\n * @param k - The scalar.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The scaled vector.\n */\nconst scale$5 = mulScalar$3;\n/**\n * Divides a vector by a scalar.\n * @param v - The vector.\n * @param k - The scalar.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The scaled vector.\n */\nfunction divScalar$3(v, k, dst) {\n    dst = dst || new VecType$2(2);\n    dst[0] = v[0] / k;\n    dst[1] = v[1] / k;\n    return dst;\n}\n/**\n * Inverse a vector.\n * @param v - The vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The inverted vector.\n */\nfunction inverse$5(v, dst) {\n    dst = dst || new VecType$2(2);\n    dst[0] = 1 / v[0];\n    dst[1] = 1 / v[1];\n    return dst;\n}\n/**\n * Invert a vector. (same as inverse)\n * @param v - The vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The inverted vector.\n */\nconst invert$4 = inverse$5;\n/**\n * Computes the cross product of two vectors; assumes both vectors have\n * three entries.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The vector of a cross b.\n */\nfunction cross$1(a, b, dst) {\n    dst = dst || new VecType$2(3);\n    const z = a[0] * b[1] - a[1] * b[0];\n    dst[0] = 0;\n    dst[1] = 0;\n    dst[2] = z;\n    return dst;\n}\n/**\n * Computes the dot product of two vectors; assumes both vectors have\n * three entries.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @returns dot product\n */\nfunction dot$3(a, b) {\n    return a[0] * b[0] + a[1] * b[1];\n}\n/**\n * Computes the length of vector\n * @param v - vector.\n * @returns length of vector.\n */\nfunction length$3(v) {\n    const v0 = v[0];\n    const v1 = v[1];\n    return Math.sqrt(v0 * v0 + v1 * v1);\n}\n/**\n * Computes the length of vector (same as length)\n * @param v - vector.\n * @returns length of vector.\n */\nconst len$3 = length$3;\n/**\n * Computes the square of the length of vector\n * @param v - vector.\n * @returns square of the length of vector.\n */\nfunction lengthSq$3(v) {\n    const v0 = v[0];\n    const v1 = v[1];\n    return v0 * v0 + v1 * v1;\n}\n/**\n * Computes the square of the length of vector (same as lengthSq)\n * @param v - vector.\n * @returns square of the length of vector.\n */\nconst lenSq$3 = lengthSq$3;\n/**\n * Computes the distance between 2 points\n * @param a - vector.\n * @param b - vector.\n * @returns distance between a and b\n */\nfunction distance$2(a, b) {\n    const dx = a[0] - b[0];\n    const dy = a[1] - b[1];\n    return Math.sqrt(dx * dx + dy * dy);\n}\n/**\n * Computes the distance between 2 points (same as distance)\n * @param a - vector.\n * @param b - vector.\n * @returns distance between a and b\n */\nconst dist$2 = distance$2;\n/**\n * Computes the square of the distance between 2 points\n * @param a - vector.\n * @param b - vector.\n * @returns square of the distance between a and b\n */\nfunction distanceSq$2(a, b) {\n    const dx = a[0] - b[0];\n    const dy = a[1] - b[1];\n    return dx * dx + dy * dy;\n}\n/**\n * Computes the square of the distance between 2 points (same as distanceSq)\n * @param a - vector.\n * @param b - vector.\n * @returns square of the distance between a and b\n */\nconst distSq$2 = distanceSq$2;\n/**\n * Divides a vector by its Euclidean length and returns the quotient.\n * @param v - The vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The normalized vector.\n */\nfunction normalize$3(v, dst) {\n    dst = dst || new VecType$2(2);\n    const v0 = v[0];\n    const v1 = v[1];\n    const len = Math.sqrt(v0 * v0 + v1 * v1);\n    if (len > 0.00001) {\n        dst[0] = v0 / len;\n        dst[1] = v1 / len;\n    }\n    else {\n        dst[0] = 0;\n        dst[1] = 0;\n    }\n    return dst;\n}\n/**\n * Negates a vector.\n * @param v - The vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns -v.\n */\nfunction negate$4(v, dst) {\n    dst = dst || new VecType$2(2);\n    dst[0] = -v[0];\n    dst[1] = -v[1];\n    return dst;\n}\n/**\n * Copies a vector. (same as clone)\n * @param v - The vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A copy of v.\n */\nfunction copy$5(v, dst) {\n    dst = dst || new VecType$2(2);\n    dst[0] = v[0];\n    dst[1] = v[1];\n    return dst;\n}\n/**\n * Clones a vector. (same as copy)\n * @param v - The vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A copy of v.\n */\nconst clone$5 = copy$5;\n/**\n * Multiplies a vector by another vector (component-wise); assumes a and\n * b have the same length.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The vector of products of entries of a and b.\n */\nfunction multiply$5(a, b, dst) {\n    dst = dst || new VecType$2(2);\n    dst[0] = a[0] * b[0];\n    dst[1] = a[1] * b[1];\n    return dst;\n}\n/**\n * Multiplies a vector by another vector (component-wise); assumes a and\n * b have the same length. (same as mul)\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The vector of products of entries of a and b.\n */\nconst mul$5 = multiply$5;\n/**\n * Divides a vector by another vector (component-wise); assumes a and\n * b have the same length.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The vector of quotients of entries of a and b.\n */\nfunction divide$2(a, b, dst) {\n    dst = dst || new VecType$2(2);\n    dst[0] = a[0] / b[0];\n    dst[1] = a[1] / b[1];\n    return dst;\n}\n/**\n * Divides a vector by another vector (component-wise); assumes a and\n * b have the same length. (same as divide)\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The vector of quotients of entries of a and b.\n */\nconst div$2 = divide$2;\n/**\n * Creates a random unit vector * scale\n * @param scale - Default 1\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The random vector.\n */\nfunction random$1(scale = 1, dst) {\n    dst = dst || new VecType$2(2);\n    const angle = Math.random() * 2 * Math.PI;\n    dst[0] = Math.cos(angle) * scale;\n    dst[1] = Math.sin(angle) * scale;\n    return dst;\n}\n/**\n * Zero's a vector\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The zeroed vector.\n */\nfunction zero$2(dst) {\n    dst = dst || new VecType$2(2);\n    dst[0] = 0;\n    dst[1] = 0;\n    return dst;\n}\n/**\n * transform Vec2 by 4x4 matrix\n * @param v - the vector\n * @param m - The matrix.\n * @param dst - optional Vec2 to store result. If not passed a new one is created.\n * @returns the transformed vector\n */\nfunction transformMat4$2(v, m, dst) {\n    dst = dst || new VecType$2(2);\n    const x = v[0];\n    const y = v[1];\n    dst[0] = x * m[0] + y * m[4] + m[12];\n    dst[1] = x * m[1] + y * m[5] + m[13];\n    return dst;\n}\n/**\n * Transforms vec4 by 3x3 matrix\n *\n * @param v - the vector\n * @param m - The matrix.\n * @param dst - optional Vec2 to store result. If not passed a new one is created.\n * @returns the transformed vector\n */\nfunction transformMat3$1(v, m, dst) {\n    dst = dst || new VecType$2(2);\n    const x = v[0];\n    const y = v[1];\n    dst[0] = m[0] * x + m[4] * y + m[8];\n    dst[1] = m[1] * x + m[5] * y + m[9];\n    return dst;\n}\n\nvar vec2Impl = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    add: add$3,\n    addScaled: addScaled$2,\n    angle: angle$2,\n    ceil: ceil$2,\n    clamp: clamp$2,\n    clone: clone$5,\n    copy: copy$5,\n    create: create$5,\n    cross: cross$1,\n    dist: dist$2,\n    distSq: distSq$2,\n    distance: distance$2,\n    distanceSq: distanceSq$2,\n    div: div$2,\n    divScalar: divScalar$3,\n    divide: divide$2,\n    dot: dot$3,\n    equals: equals$5,\n    equalsApproximately: equalsApproximately$5,\n    floor: floor$2,\n    fromValues: fromValues$3,\n    inverse: inverse$5,\n    invert: invert$4,\n    len: len$3,\n    lenSq: lenSq$3,\n    length: length$3,\n    lengthSq: lengthSq$3,\n    lerp: lerp$3,\n    lerpV: lerpV$2,\n    max: max$2,\n    min: min$2,\n    mul: mul$5,\n    mulScalar: mulScalar$3,\n    multiply: multiply$5,\n    negate: negate$4,\n    normalize: normalize$3,\n    random: random$1,\n    round: round$2,\n    scale: scale$5,\n    setDefaultType: setDefaultType$6,\n    sub: sub$3,\n    subtract: subtract$3,\n    transformMat3: transformMat3$1,\n    transformMat4: transformMat4$2,\n    zero: zero$2\n});\n\n/*\n * Copyright 2022 Gregg Tavares\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n/**\n * 3x3 Matrix math math functions.\n *\n * Almost all functions take an optional `dst` argument. If it is not passed in the\n * functions will create a new matrix. In other words you can do this\n *\n *     const mat = mat3.translation([1, 2, 3]);  // Creates a new translation matrix\n *\n * or\n *\n *     const mat = mat3.create();\n *     mat3.translation([1, 2, 3], mat);  // Puts translation matrix in mat.\n *\n * The first style is often easier but depending on where it's used it generates garbage where\n * as there is almost never allocation with the second style.\n *\n * It is always save to pass any matrix as the destination. So for example\n *\n *     const mat = mat3.identity();\n *     const trans = mat3.translation([1, 2, 3]);\n *     mat3.multiply(mat, trans, mat);  // Multiplies mat * trans and puts result in mat.\n *\n */\nlet MatType$1 = Float32Array;\n// This mess is because with Mat3 we have 3 unused elements.\n// For Float32Array and Float64Array that's not an issue\n// but for Array it's troublesome\nconst ctorMap = new Map([\n    [Float32Array, () => new Float32Array(12)],\n    [Float64Array, () => new Float64Array(12)],\n    [Array, () => new Array(12).fill(0)],\n]);\nlet newMat3 = ctorMap.get(Float32Array);\n/**\n * Sets the type this library creates for a Mat3\n * @param ctor - the constructor for the type. Either `Float32Array`, `Float64Array`, or `Array`\n * @returns previous constructor for Mat3\n */\nfunction setDefaultType$5(ctor) {\n    const oldType = MatType$1;\n    MatType$1 = ctor;\n    newMat3 = ctorMap.get(ctor);\n    return oldType;\n}\n/**\n * Create a Mat3 from values\n *\n * Note: Since passing in a raw JavaScript array\n * is valid in all circumstances, if you want to\n * force a JavaScript array into a Mat3's specified type\n * it would be faster to use\n *\n * ```\n * const m = mat3.clone(someJSArray);\n * ```\n *\n * Note: a consequence of the implementation is if your Mat3Type = `Array`\n * instead of `Float32Array` or `Float64Array` then any values you\n * don't pass in will be undefined. Usually this is not an issue since\n * (a) using `Array` is rare and (b) using `mat3.create` is usually used\n * to create a Mat3 to be filled out as in\n *\n * ```\n * const m = mat3.create();\n * mat3.perspective(fov, aspect, near, far, m);\n * ```\n *\n * @param v0 - value for element 0\n * @param v1 - value for element 1\n * @param v2 - value for element 2\n * @param v3 - value for element 3\n * @param v4 - value for element 4\n * @param v5 - value for element 5\n * @param v6 - value for element 6\n * @param v7 - value for element 7\n * @param v8 - value for element 8\n * @returns matrix created from values.\n */\nfunction create$4(v0, v1, v2, v3, v4, v5, v6, v7, v8) {\n    const dst = newMat3();\n    // to make the array homogenous\n    dst[3] = 0;\n    dst[7] = 0;\n    dst[11] = 0;\n    if (v0 !== undefined) {\n        dst[0] = v0;\n        if (v1 !== undefined) {\n            dst[1] = v1;\n            if (v2 !== undefined) {\n                dst[2] = v2;\n                if (v3 !== undefined) {\n                    dst[4] = v3;\n                    if (v4 !== undefined) {\n                        dst[5] = v4;\n                        if (v5 !== undefined) {\n                            dst[6] = v5;\n                            if (v6 !== undefined) {\n                                dst[8] = v6;\n                                if (v7 !== undefined) {\n                                    dst[9] = v7;\n                                    if (v8 !== undefined) {\n                                        dst[10] = v8;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return dst;\n}\n/**\n * Creates a Mat3 from the upper left 3x3 part of a Mat4\n * @param m4 - source matrix\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns Mat3 made from m4\n */\nfunction fromMat4(m4, dst) {\n    dst = dst || newMat3();\n    dst[0] = m4[0];\n    dst[1] = m4[1];\n    dst[2] = m4[2];\n    dst[3] = 0;\n    dst[4] = m4[4];\n    dst[5] = m4[5];\n    dst[6] = m4[6];\n    dst[7] = 0;\n    dst[8] = m4[8];\n    dst[9] = m4[9];\n    dst[10] = m4[10];\n    dst[11] = 0;\n    return dst;\n}\n/**\n * Creates a Mat3 rotation matrix from a quaternion\n * @param q - quaternion to create matrix from\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns Mat3 made from q\n */\nfunction fromQuat$1(q, dst) {\n    dst = dst || newMat3();\n    const x = q[0];\n    const y = q[1];\n    const z = q[2];\n    const w = q[3];\n    const x2 = x + x;\n    const y2 = y + y;\n    const z2 = z + z;\n    const xx = x * x2;\n    const yx = y * x2;\n    const yy = y * y2;\n    const zx = z * x2;\n    const zy = z * y2;\n    const zz = z * z2;\n    const wx = w * x2;\n    const wy = w * y2;\n    const wz = w * z2;\n    dst[0] = 1 - yy - zz;\n    dst[1] = yx + wz;\n    dst[2] = zx - wy;\n    dst[3] = 0;\n    dst[4] = yx - wz;\n    dst[5] = 1 - xx - zz;\n    dst[6] = zy + wx;\n    dst[7] = 0;\n    dst[8] = zx + wy;\n    dst[9] = zy - wx;\n    dst[10] = 1 - xx - yy;\n    dst[11] = 0;\n    return dst;\n}\n/**\n * Negates a matrix.\n * @param m - The matrix.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns -m.\n */\nfunction negate$3(m, dst) {\n    dst = dst || newMat3();\n    dst[0] = -m[0];\n    dst[1] = -m[1];\n    dst[2] = -m[2];\n    dst[4] = -m[4];\n    dst[5] = -m[5];\n    dst[6] = -m[6];\n    dst[8] = -m[8];\n    dst[9] = -m[9];\n    dst[10] = -m[10];\n    return dst;\n}\n/**\n * Copies a matrix.\n * @param m - The matrix.\n * @param dst - The matrix. If not passed a new one is created.\n * @returns A copy of m.\n */\nfunction copy$4(m, dst) {\n    dst = dst || newMat3();\n    dst[0] = m[0];\n    dst[1] = m[1];\n    dst[2] = m[2];\n    dst[4] = m[4];\n    dst[5] = m[5];\n    dst[6] = m[6];\n    dst[8] = m[8];\n    dst[9] = m[9];\n    dst[10] = m[10];\n    return dst;\n}\n/**\n * Copies a matrix (same as copy)\n * @param m - The matrix.\n * @param dst - The matrix. If not passed a new one is created.\n * @returns A copy of m.\n */\nconst clone$4 = copy$4;\n/**\n * Check if 2 matrices are approximately equal\n * @param a Operand matrix.\n * @param b Operand matrix.\n * @returns true if matrices are approximately equal\n */\nfunction equalsApproximately$4(a, b) {\n    return Math.abs(a[0] - b[0]) < EPSILON &&\n        Math.abs(a[1] - b[1]) < EPSILON &&\n        Math.abs(a[2] - b[2]) < EPSILON &&\n        Math.abs(a[4] - b[4]) < EPSILON &&\n        Math.abs(a[5] - b[5]) < EPSILON &&\n        Math.abs(a[6] - b[6]) < EPSILON &&\n        Math.abs(a[8] - b[8]) < EPSILON &&\n        Math.abs(a[9] - b[9]) < EPSILON &&\n        Math.abs(a[10] - b[10]) < EPSILON;\n}\n/**\n * Check if 2 matrices are exactly equal\n * @param a Operand matrix.\n * @param b Operand matrix.\n * @returns true if matrices are exactly equal\n */\nfunction equals$4(a, b) {\n    return a[0] === b[0] &&\n        a[1] === b[1] &&\n        a[2] === b[2] &&\n        a[4] === b[4] &&\n        a[5] === b[5] &&\n        a[6] === b[6] &&\n        a[8] === b[8] &&\n        a[9] === b[9] &&\n        a[10] === b[10];\n}\n/**\n * Creates a 3-by-3 identity matrix.\n *\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns A 3-by-3 identity matrix.\n */\nfunction identity$2(dst) {\n    dst = dst || newMat3();\n    dst[0] = 1;\n    dst[1] = 0;\n    dst[2] = 0;\n    dst[4] = 0;\n    dst[5] = 1;\n    dst[6] = 0;\n    dst[8] = 0;\n    dst[9] = 0;\n    dst[10] = 1;\n    return dst;\n}\n/**\n * Takes the transpose of a matrix.\n * @param m - The matrix.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The transpose of m.\n */\nfunction transpose$1(m, dst) {\n    dst = dst || newMat3();\n    if (dst === m) {\n        let t;\n        // 0 1 2\n        // 4 5 6\n        // 8 9 10\n        t = m[1];\n        m[1] = m[4];\n        m[4] = t;\n        t = m[2];\n        m[2] = m[8];\n        m[8] = t;\n        t = m[6];\n        m[6] = m[9];\n        m[9] = t;\n        return dst;\n    }\n    const m00 = m[0 * 4 + 0];\n    const m01 = m[0 * 4 + 1];\n    const m02 = m[0 * 4 + 2];\n    const m10 = m[1 * 4 + 0];\n    const m11 = m[1 * 4 + 1];\n    const m12 = m[1 * 4 + 2];\n    const m20 = m[2 * 4 + 0];\n    const m21 = m[2 * 4 + 1];\n    const m22 = m[2 * 4 + 2];\n    dst[0] = m00;\n    dst[1] = m10;\n    dst[2] = m20;\n    dst[4] = m01;\n    dst[5] = m11;\n    dst[6] = m21;\n    dst[8] = m02;\n    dst[9] = m12;\n    dst[10] = m22;\n    return dst;\n}\n/**\n * Computes the inverse of a 3-by-3 matrix.\n * @param m - The matrix.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The inverse of m.\n */\nfunction inverse$4(m, dst) {\n    dst = dst || newMat3();\n    const m00 = m[0 * 4 + 0];\n    const m01 = m[0 * 4 + 1];\n    const m02 = m[0 * 4 + 2];\n    const m10 = m[1 * 4 + 0];\n    const m11 = m[1 * 4 + 1];\n    const m12 = m[1 * 4 + 2];\n    const m20 = m[2 * 4 + 0];\n    const m21 = m[2 * 4 + 1];\n    const m22 = m[2 * 4 + 2];\n    const m11_x_m22 = m11 * m22;\n    const m21_x_m12 = m21 * m12;\n    const m01_x_m22 = m01 * m22;\n    const m21_x_m02 = m21 * m02;\n    const m01_x_m12 = m01 * m12;\n    const m11_x_m02 = m11 * m02;\n    const invDet = 1 / (m00 * (m11_x_m22 - m21_x_m12) -\n        m10 * (m01_x_m22 - m21_x_m02) +\n        m20 * (m01_x_m12 - m11_x_m02));\n    dst[0] = +(m11_x_m22 - m21_x_m12) * invDet;\n    dst[1] = -(m10 * m22 - m20 * m12) * invDet;\n    dst[2] = +(m10 * m21 - m20 * m11) * invDet;\n    dst[4] = -(m01_x_m22 - m21_x_m02) * invDet;\n    dst[5] = +(m00 * m22 - m20 * m02) * invDet;\n    dst[6] = -(m00 * m21 - m20 * m01) * invDet;\n    dst[8] = +(m01_x_m12 - m11_x_m02) * invDet;\n    dst[9] = -(m00 * m12 - m10 * m02) * invDet;\n    dst[10] = +(m00 * m11 - m10 * m01) * invDet;\n    return dst;\n}\n/**\n * Compute the determinant of a matrix\n * @param m - the matrix\n * @returns the determinant\n */\nfunction determinant$1(m) {\n    const m00 = m[0 * 4 + 0];\n    const m01 = m[0 * 4 + 1];\n    const m02 = m[0 * 4 + 2];\n    const m10 = m[1 * 4 + 0];\n    const m11 = m[1 * 4 + 1];\n    const m12 = m[1 * 4 + 2];\n    const m20 = m[2 * 4 + 0];\n    const m21 = m[2 * 4 + 1];\n    const m22 = m[2 * 4 + 2];\n    return m00 * (m11 * m22 - m21 * m12) -\n        m10 * (m01 * m22 - m21 * m02) +\n        m20 * (m01 * m12 - m11 * m02);\n}\n/**\n * Computes the inverse of a 3-by-3 matrix. (same as inverse)\n * @param m - The matrix.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The inverse of m.\n */\nconst invert$3 = inverse$4;\n/**\n * Multiplies two 3-by-3 matrices with a on the left and b on the right\n * @param a - The matrix on the left.\n * @param b - The matrix on the right.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The matrix product of a and b.\n */\nfunction multiply$4(a, b, dst) {\n    dst = dst || newMat3();\n    const a00 = a[0];\n    const a01 = a[1];\n    const a02 = a[2];\n    const a10 = a[4 + 0];\n    const a11 = a[4 + 1];\n    const a12 = a[4 + 2];\n    const a20 = a[8 + 0];\n    const a21 = a[8 + 1];\n    const a22 = a[8 + 2];\n    const b00 = b[0];\n    const b01 = b[1];\n    const b02 = b[2];\n    const b10 = b[4 + 0];\n    const b11 = b[4 + 1];\n    const b12 = b[4 + 2];\n    const b20 = b[8 + 0];\n    const b21 = b[8 + 1];\n    const b22 = b[8 + 2];\n    dst[0] = a00 * b00 + a10 * b01 + a20 * b02;\n    dst[1] = a01 * b00 + a11 * b01 + a21 * b02;\n    dst[2] = a02 * b00 + a12 * b01 + a22 * b02;\n    dst[4] = a00 * b10 + a10 * b11 + a20 * b12;\n    dst[5] = a01 * b10 + a11 * b11 + a21 * b12;\n    dst[6] = a02 * b10 + a12 * b11 + a22 * b12;\n    dst[8] = a00 * b20 + a10 * b21 + a20 * b22;\n    dst[9] = a01 * b20 + a11 * b21 + a21 * b22;\n    dst[10] = a02 * b20 + a12 * b21 + a22 * b22;\n    return dst;\n}\n/**\n * Multiplies two 3-by-3 matrices with a on the left and b on the right (same as multiply)\n * @param a - The matrix on the left.\n * @param b - The matrix on the right.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The matrix product of a and b.\n */\nconst mul$4 = multiply$4;\n/**\n * Sets the translation component of a 3-by-3 matrix to the given\n * vector.\n * @param a - The matrix.\n * @param v - The vector.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The matrix with translation set.\n */\nfunction setTranslation$1(a, v, dst) {\n    dst = dst || identity$2();\n    if (a !== dst) {\n        dst[0] = a[0];\n        dst[1] = a[1];\n        dst[2] = a[2];\n        dst[4] = a[4];\n        dst[5] = a[5];\n        dst[6] = a[6];\n    }\n    dst[8] = v[0];\n    dst[9] = v[1];\n    dst[10] = 1;\n    return dst;\n}\n/**\n * Returns the translation component of a 3-by-3 matrix as a vector with 3\n * entries.\n * @param m - The matrix.\n * @param dst - vector to hold result. If not passed a new one is created.\n * @returns The translation component of m.\n */\nfunction getTranslation$2(m, dst) {\n    dst = dst || create$5();\n    dst[0] = m[8];\n    dst[1] = m[9];\n    return dst;\n}\n/**\n * Returns an axis of a 3x3 matrix as a vector with 2 entries\n * @param m - The matrix.\n * @param axis - The axis 0 = x, 1 = y,\n * @returns The axis component of m.\n */\nfunction getAxis$2(m, axis, dst) {\n    dst = dst || create$5();\n    const off = axis * 4;\n    dst[0] = m[off + 0];\n    dst[1] = m[off + 1];\n    return dst;\n}\n/**\n * Sets an axis of a 3x3 matrix as a vector with 2 entries\n * @param m - The matrix.\n * @param v - the axis vector\n * @param axis - The axis  0 = x, 1 = y;\n * @param dst - The matrix to set. If not passed a new one is created.\n * @returns The matrix with axis set.\n */\nfunction setAxis$1(m, v, axis, dst) {\n    if (dst !== m) {\n        dst = copy$4(m, dst);\n    }\n    const off = axis * 4;\n    dst[off + 0] = v[0];\n    dst[off + 1] = v[1];\n    return dst;\n}\n/**\n * Returns the scaling component of the matrix\n * @param m - The Matrix\n * @param dst - The vector to set. If not passed a new one is created.\n */\nfunction getScaling$2(m, dst) {\n    dst = dst || create$5();\n    const xx = m[0];\n    const xy = m[1];\n    const yx = m[4];\n    const yy = m[5];\n    dst[0] = Math.sqrt(xx * xx + xy * xy);\n    dst[1] = Math.sqrt(yx * yx + yy * yy);\n    return dst;\n}\n/**\n * Creates a 3-by-3 matrix which translates by the given vector v.\n * @param v - The vector by which to translate.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The translation matrix.\n */\nfunction translation$1(v, dst) {\n    dst = dst || newMat3();\n    dst[0] = 1;\n    dst[1] = 0;\n    dst[2] = 0;\n    dst[4] = 0;\n    dst[5] = 1;\n    dst[6] = 0;\n    dst[8] = v[0];\n    dst[9] = v[1];\n    dst[10] = 1;\n    return dst;\n}\n/**\n * Translates the given 3-by-3 matrix by the given vector v.\n * @param m - The matrix.\n * @param v - The vector by which to translate.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The translated matrix.\n */\nfunction translate$1(m, v, dst) {\n    dst = dst || newMat3();\n    const v0 = v[0];\n    const v1 = v[1];\n    const m00 = m[0];\n    const m01 = m[1];\n    const m02 = m[2];\n    const m10 = m[1 * 4 + 0];\n    const m11 = m[1 * 4 + 1];\n    const m12 = m[1 * 4 + 2];\n    const m20 = m[2 * 4 + 0];\n    const m21 = m[2 * 4 + 1];\n    const m22 = m[2 * 4 + 2];\n    if (m !== dst) {\n        dst[0] = m00;\n        dst[1] = m01;\n        dst[2] = m02;\n        dst[4] = m10;\n        dst[5] = m11;\n        dst[6] = m12;\n    }\n    dst[8] = m00 * v0 + m10 * v1 + m20;\n    dst[9] = m01 * v0 + m11 * v1 + m21;\n    dst[10] = m02 * v0 + m12 * v1 + m22;\n    return dst;\n}\n/**\n * Creates a 3-by-3 matrix which rotates  by the given angle.\n * @param angleInRadians - The angle by which to rotate (in radians).\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The rotation matrix.\n */\nfunction rotation$1(angleInRadians, dst) {\n    dst = dst || newMat3();\n    const c = Math.cos(angleInRadians);\n    const s = Math.sin(angleInRadians);\n    dst[0] = c;\n    dst[1] = s;\n    dst[2] = 0;\n    dst[4] = -s;\n    dst[5] = c;\n    dst[6] = 0;\n    dst[8] = 0;\n    dst[9] = 0;\n    dst[10] = 1;\n    return dst;\n}\n/**\n * Rotates the given 3-by-3 matrix  by the given angle.\n * @param m - The matrix.\n * @param angleInRadians - The angle by which to rotate (in radians).\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The rotated matrix.\n */\nfunction rotate$1(m, angleInRadians, dst) {\n    dst = dst || newMat3();\n    const m00 = m[0 * 4 + 0];\n    const m01 = m[0 * 4 + 1];\n    const m02 = m[0 * 4 + 2];\n    const m10 = m[1 * 4 + 0];\n    const m11 = m[1 * 4 + 1];\n    const m12 = m[1 * 4 + 2];\n    const c = Math.cos(angleInRadians);\n    const s = Math.sin(angleInRadians);\n    dst[0] = c * m00 + s * m10;\n    dst[1] = c * m01 + s * m11;\n    dst[2] = c * m02 + s * m12;\n    dst[4] = c * m10 - s * m00;\n    dst[5] = c * m11 - s * m01;\n    dst[6] = c * m12 - s * m02;\n    if (m !== dst) {\n        dst[8] = m[8];\n        dst[9] = m[9];\n        dst[10] = m[10];\n    }\n    return dst;\n}\n/**\n * Creates a 3-by-3 matrix which scales in each dimension by an amount given by\n * the corresponding entry in the given vector; assumes the vector has three\n * entries.\n * @param v - A vector of\n *     2 entries specifying the factor by which to scale in each dimension.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The scaling matrix.\n */\nfunction scaling$1(v, dst) {\n    dst = dst || newMat3();\n    dst[0] = v[0];\n    dst[1] = 0;\n    dst[2] = 0;\n    dst[4] = 0;\n    dst[5] = v[1];\n    dst[6] = 0;\n    dst[8] = 0;\n    dst[9] = 0;\n    dst[10] = 1;\n    return dst;\n}\n/**\n * Scales the given 3-by-3 matrix in each dimension by an amount\n * given by the corresponding entry in the given vector; assumes the vector has\n * three entries.\n * @param m - The matrix to be modified.\n * @param v - A vector of 2 entries specifying the\n *     factor by which to scale in each dimension.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The scaled matrix.\n */\nfunction scale$4(m, v, dst) {\n    dst = dst || newMat3();\n    const v0 = v[0];\n    const v1 = v[1];\n    dst[0] = v0 * m[0 * 4 + 0];\n    dst[1] = v0 * m[0 * 4 + 1];\n    dst[2] = v0 * m[0 * 4 + 2];\n    dst[4] = v1 * m[1 * 4 + 0];\n    dst[5] = v1 * m[1 * 4 + 1];\n    dst[6] = v1 * m[1 * 4 + 2];\n    if (m !== dst) {\n        dst[8] = m[8];\n        dst[9] = m[9];\n        dst[10] = m[10];\n    }\n    return dst;\n}\n\nvar mat3Impl = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    clone: clone$4,\n    copy: copy$4,\n    create: create$4,\n    determinant: determinant$1,\n    equals: equals$4,\n    equalsApproximately: equalsApproximately$4,\n    fromMat4: fromMat4,\n    fromQuat: fromQuat$1,\n    getAxis: getAxis$2,\n    getScaling: getScaling$2,\n    getTranslation: getTranslation$2,\n    identity: identity$2,\n    inverse: inverse$4,\n    invert: invert$3,\n    mul: mul$4,\n    multiply: multiply$4,\n    negate: negate$3,\n    rotate: rotate$1,\n    rotation: rotation$1,\n    scale: scale$4,\n    scaling: scaling$1,\n    setAxis: setAxis$1,\n    setDefaultType: setDefaultType$5,\n    setTranslation: setTranslation$1,\n    translate: translate$1,\n    translation: translation$1,\n    transpose: transpose$1\n});\n\n/**\n *\n * Vec3 math functions.\n *\n * Almost all functions take an optional `dst` argument. If it is not passed in the\n * functions will create a new `Vec3`. In other words you can do this\n *\n *     const v = vec3.cross(v1, v2);  // Creates a new Vec3 with the cross product of v1 x v2.\n *\n * or\n *\n *     const v = vec3.create();\n *     vec3.cross(v1, v2, v);  // Puts the cross product of v1 x v2 in v\n *\n * The first style is often easier but depending on where it's used it generates garbage where\n * as there is almost never allocation with the second style.\n *\n * It is always safe to pass any vector as the destination. So for example\n *\n *     vec3.cross(v1, v2, v1);  // Puts the cross product of v1 x v2 in v1\n *\n */\nlet VecType$1 = Float32Array;\n/**\n * Sets the type this library creates for a Vec3\n * @param ctor - the constructor for the type. Either `Float32Array`, `Float64Array`, or `Array`\n * @returns previous constructor for Vec3\n */\nfunction setDefaultType$4(ctor) {\n    const oldType = VecType$1;\n    VecType$1 = ctor;\n    return oldType;\n}\n/**\n * Creates a vec3; may be called with x, y, z to set initial values.\n * @param x - Initial x value.\n * @param y - Initial y value.\n * @param z - Initial z value.\n * @returns the created vector\n */\nfunction create$3(x, y, z) {\n    const dst = new VecType$1(3);\n    if (x !== undefined) {\n        dst[0] = x;\n        if (y !== undefined) {\n            dst[1] = y;\n            if (z !== undefined) {\n                dst[2] = z;\n            }\n        }\n    }\n    return dst;\n}\n\n/*\n * Copyright 2022 Gregg Tavares\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n/**\n * Creates a vec3; may be called with x, y, z to set initial values. (same as create)\n * @param x - Initial x value.\n * @param y - Initial y value.\n * @param z - Initial z value.\n * @returns the created vector\n */\nconst fromValues$2 = create$3;\n/**\n * Applies Math.ceil to each element of vector\n * @param v - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that is the ceil of each element of v.\n */\nfunction ceil$1(v, dst) {\n    dst = dst || new VecType$1(3);\n    dst[0] = Math.ceil(v[0]);\n    dst[1] = Math.ceil(v[1]);\n    dst[2] = Math.ceil(v[2]);\n    return dst;\n}\n/**\n * Applies Math.floor to each element of vector\n * @param v - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that is the floor of each element of v.\n */\nfunction floor$1(v, dst) {\n    dst = dst || new VecType$1(3);\n    dst[0] = Math.floor(v[0]);\n    dst[1] = Math.floor(v[1]);\n    dst[2] = Math.floor(v[2]);\n    return dst;\n}\n/**\n * Applies Math.round to each element of vector\n * @param v - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that is the round of each element of v.\n */\nfunction round$1(v, dst) {\n    dst = dst || new VecType$1(3);\n    dst[0] = Math.round(v[0]);\n    dst[1] = Math.round(v[1]);\n    dst[2] = Math.round(v[2]);\n    return dst;\n}\n/**\n * Clamp each element of vector between min and max\n * @param v - Operand vector.\n * @param max - Min value, default 0\n * @param min - Max value, default 1\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that the clamped value of each element of v.\n */\nfunction clamp$1(v, min = 0, max = 1, dst) {\n    dst = dst || new VecType$1(3);\n    dst[0] = Math.min(max, Math.max(min, v[0]));\n    dst[1] = Math.min(max, Math.max(min, v[1]));\n    dst[2] = Math.min(max, Math.max(min, v[2]));\n    return dst;\n}\n/**\n * Adds two vectors; assumes a and b have the same dimension.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that is the sum of a and b.\n */\nfunction add$2(a, b, dst) {\n    dst = dst || new VecType$1(3);\n    dst[0] = a[0] + b[0];\n    dst[1] = a[1] + b[1];\n    dst[2] = a[2] + b[2];\n    return dst;\n}\n/**\n * Adds two vectors, scaling the 2nd; assumes a and b have the same dimension.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param scale - Amount to scale b\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that is the sum of a + b * scale.\n */\nfunction addScaled$1(a, b, scale, dst) {\n    dst = dst || new VecType$1(3);\n    dst[0] = a[0] + b[0] * scale;\n    dst[1] = a[1] + b[1] * scale;\n    dst[2] = a[2] + b[2] * scale;\n    return dst;\n}\n/**\n * Returns the angle in radians between two vectors.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @returns The angle in radians between the 2 vectors.\n */\nfunction angle$1(a, b) {\n    const ax = a[0];\n    const ay = a[1];\n    const az = a[2];\n    const bx = a[0];\n    const by = a[1];\n    const bz = a[2];\n    const mag1 = Math.sqrt(ax * ax + ay * ay + az * az);\n    const mag2 = Math.sqrt(bx * bx + by * by + bz * bz);\n    const mag = mag1 * mag2;\n    const cosine = mag && dot$2(a, b) / mag;\n    return Math.acos(cosine);\n}\n/**\n * Subtracts two vectors.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that is the difference of a and b.\n */\nfunction subtract$2(a, b, dst) {\n    dst = dst || new VecType$1(3);\n    dst[0] = a[0] - b[0];\n    dst[1] = a[1] - b[1];\n    dst[2] = a[2] - b[2];\n    return dst;\n}\n/**\n * Subtracts two vectors.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that is the difference of a and b.\n */\nconst sub$2 = subtract$2;\n/**\n * Check if 2 vectors are approximately equal\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @returns true if vectors are approximately equal\n */\nfunction equalsApproximately$3(a, b) {\n    return Math.abs(a[0] - b[0]) < EPSILON &&\n        Math.abs(a[1] - b[1]) < EPSILON &&\n        Math.abs(a[2] - b[2]) < EPSILON;\n}\n/**\n * Check if 2 vectors are exactly equal\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @returns true if vectors are exactly equal\n */\nfunction equals$3(a, b) {\n    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];\n}\n/**\n * Performs linear interpolation on two vectors.\n * Given vectors a and b and interpolation coefficient t, returns\n * a + t * (b - a).\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param t - Interpolation coefficient.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The linear interpolated result.\n */\nfunction lerp$2(a, b, t, dst) {\n    dst = dst || new VecType$1(3);\n    dst[0] = a[0] + t * (b[0] - a[0]);\n    dst[1] = a[1] + t * (b[1] - a[1]);\n    dst[2] = a[2] + t * (b[2] - a[2]);\n    return dst;\n}\n/**\n * Performs linear interpolation on two vectors.\n * Given vectors a and b and interpolation coefficient vector t, returns\n * a + t * (b - a).\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param t - Interpolation coefficients vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns the linear interpolated result.\n */\nfunction lerpV$1(a, b, t, dst) {\n    dst = dst || new VecType$1(3);\n    dst[0] = a[0] + t[0] * (b[0] - a[0]);\n    dst[1] = a[1] + t[1] * (b[1] - a[1]);\n    dst[2] = a[2] + t[2] * (b[2] - a[2]);\n    return dst;\n}\n/**\n * Return max values of two vectors.\n * Given vectors a and b returns\n * [max(a[0], b[0]), max(a[1], b[1]), max(a[2], b[2])].\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The max components vector.\n */\nfunction max$1(a, b, dst) {\n    dst = dst || new VecType$1(3);\n    dst[0] = Math.max(a[0], b[0]);\n    dst[1] = Math.max(a[1], b[1]);\n    dst[2] = Math.max(a[2], b[2]);\n    return dst;\n}\n/**\n * Return min values of two vectors.\n * Given vectors a and b returns\n * [min(a[0], b[0]), min(a[1], b[1]), min(a[2], b[2])].\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The min components vector.\n */\nfunction min$1(a, b, dst) {\n    dst = dst || new VecType$1(3);\n    dst[0] = Math.min(a[0], b[0]);\n    dst[1] = Math.min(a[1], b[1]);\n    dst[2] = Math.min(a[2], b[2]);\n    return dst;\n}\n/**\n * Multiplies a vector by a scalar.\n * @param v - The vector.\n * @param k - The scalar.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The scaled vector.\n */\nfunction mulScalar$2(v, k, dst) {\n    dst = dst || new VecType$1(3);\n    dst[0] = v[0] * k;\n    dst[1] = v[1] * k;\n    dst[2] = v[2] * k;\n    return dst;\n}\n/**\n * Multiplies a vector by a scalar. (same as mulScalar)\n * @param v - The vector.\n * @param k - The scalar.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The scaled vector.\n */\nconst scale$3 = mulScalar$2;\n/**\n * Divides a vector by a scalar.\n * @param v - The vector.\n * @param k - The scalar.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The scaled vector.\n */\nfunction divScalar$2(v, k, dst) {\n    dst = dst || new VecType$1(3);\n    dst[0] = v[0] / k;\n    dst[1] = v[1] / k;\n    dst[2] = v[2] / k;\n    return dst;\n}\n/**\n * Inverse a vector.\n * @param v - The vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The inverted vector.\n */\nfunction inverse$3(v, dst) {\n    dst = dst || new VecType$1(3);\n    dst[0] = 1 / v[0];\n    dst[1] = 1 / v[1];\n    dst[2] = 1 / v[2];\n    return dst;\n}\n/**\n * Invert a vector. (same as inverse)\n * @param v - The vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The inverted vector.\n */\nconst invert$2 = inverse$3;\n/**\n * Computes the cross product of two vectors; assumes both vectors have\n * three entries.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The vector of a cross b.\n */\nfunction cross(a, b, dst) {\n    dst = dst || new VecType$1(3);\n    const t1 = a[2] * b[0] - a[0] * b[2];\n    const t2 = a[0] * b[1] - a[1] * b[0];\n    dst[0] = a[1] * b[2] - a[2] * b[1];\n    dst[1] = t1;\n    dst[2] = t2;\n    return dst;\n}\n/**\n * Computes the dot product of two vectors; assumes both vectors have\n * three entries.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @returns dot product\n */\nfunction dot$2(a, b) {\n    return (a[0] * b[0]) + (a[1] * b[1]) + (a[2] * b[2]);\n}\n/**\n * Computes the length of vector\n * @param v - vector.\n * @returns length of vector.\n */\nfunction length$2(v) {\n    const v0 = v[0];\n    const v1 = v[1];\n    const v2 = v[2];\n    return Math.sqrt(v0 * v0 + v1 * v1 + v2 * v2);\n}\n/**\n * Computes the length of vector (same as length)\n * @param v - vector.\n * @returns length of vector.\n */\nconst len$2 = length$2;\n/**\n * Computes the square of the length of vector\n * @param v - vector.\n * @returns square of the length of vector.\n */\nfunction lengthSq$2(v) {\n    const v0 = v[0];\n    const v1 = v[1];\n    const v2 = v[2];\n    return v0 * v0 + v1 * v1 + v2 * v2;\n}\n/**\n * Computes the square of the length of vector (same as lengthSq)\n * @param v - vector.\n * @returns square of the length of vector.\n */\nconst lenSq$2 = lengthSq$2;\n/**\n * Computes the distance between 2 points\n * @param a - vector.\n * @param b - vector.\n * @returns distance between a and b\n */\nfunction distance$1(a, b) {\n    const dx = a[0] - b[0];\n    const dy = a[1] - b[1];\n    const dz = a[2] - b[2];\n    return Math.sqrt(dx * dx + dy * dy + dz * dz);\n}\n/**\n * Computes the distance between 2 points (same as distance)\n * @param a - vector.\n * @param b - vector.\n * @returns distance between a and b\n */\nconst dist$1 = distance$1;\n/**\n * Computes the square of the distance between 2 points\n * @param a - vector.\n * @param b - vector.\n * @returns square of the distance between a and b\n */\nfunction distanceSq$1(a, b) {\n    const dx = a[0] - b[0];\n    const dy = a[1] - b[1];\n    const dz = a[2] - b[2];\n    return dx * dx + dy * dy + dz * dz;\n}\n/**\n * Computes the square of the distance between 2 points (same as distanceSq)\n * @param a - vector.\n * @param b - vector.\n * @returns square of the distance between a and b\n */\nconst distSq$1 = distanceSq$1;\n/**\n * Divides a vector by its Euclidean length and returns the quotient.\n * @param v - The vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The normalized vector.\n */\nfunction normalize$2(v, dst) {\n    dst = dst || new VecType$1(3);\n    const v0 = v[0];\n    const v1 = v[1];\n    const v2 = v[2];\n    const len = Math.sqrt(v0 * v0 + v1 * v1 + v2 * v2);\n    if (len > 0.00001) {\n        dst[0] = v0 / len;\n        dst[1] = v1 / len;\n        dst[2] = v2 / len;\n    }\n    else {\n        dst[0] = 0;\n        dst[1] = 0;\n        dst[2] = 0;\n    }\n    return dst;\n}\n/**\n * Negates a vector.\n * @param v - The vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns -v.\n */\nfunction negate$2(v, dst) {\n    dst = dst || new VecType$1(3);\n    dst[0] = -v[0];\n    dst[1] = -v[1];\n    dst[2] = -v[2];\n    return dst;\n}\n/**\n * Copies a vector. (same as clone)\n * @param v - The vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A copy of v.\n */\nfunction copy$3(v, dst) {\n    dst = dst || new VecType$1(3);\n    dst[0] = v[0];\n    dst[1] = v[1];\n    dst[2] = v[2];\n    return dst;\n}\n/**\n * Clones a vector. (same as copy)\n * @param v - The vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A copy of v.\n */\nconst clone$3 = copy$3;\n/**\n * Multiplies a vector by another vector (component-wise); assumes a and\n * b have the same length.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The vector of products of entries of a and b.\n */\nfunction multiply$3(a, b, dst) {\n    dst = dst || new VecType$1(3);\n    dst[0] = a[0] * b[0];\n    dst[1] = a[1] * b[1];\n    dst[2] = a[2] * b[2];\n    return dst;\n}\n/**\n * Multiplies a vector by another vector (component-wise); assumes a and\n * b have the same length. (same as mul)\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The vector of products of entries of a and b.\n */\nconst mul$3 = multiply$3;\n/**\n * Divides a vector by another vector (component-wise); assumes a and\n * b have the same length.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The vector of quotients of entries of a and b.\n */\nfunction divide$1(a, b, dst) {\n    dst = dst || new VecType$1(3);\n    dst[0] = a[0] / b[0];\n    dst[1] = a[1] / b[1];\n    dst[2] = a[2] / b[2];\n    return dst;\n}\n/**\n * Divides a vector by another vector (component-wise); assumes a and\n * b have the same length. (same as divide)\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The vector of quotients of entries of a and b.\n */\nconst div$1 = divide$1;\n/**\n * Creates a random vector\n * @param scale - Default 1\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The random vector.\n */\nfunction random(scale = 1, dst) {\n    dst = dst || new VecType$1(3);\n    const angle = Math.random() * 2 * Math.PI;\n    const z = Math.random() * 2 - 1;\n    const zScale = Math.sqrt(1 - z * z) * scale;\n    dst[0] = Math.cos(angle) * zScale;\n    dst[1] = Math.sin(angle) * zScale;\n    dst[2] = z * scale;\n    return dst;\n}\n/**\n * Zero's a vector\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The zeroed vector.\n */\nfunction zero$1(dst) {\n    dst = dst || new VecType$1(3);\n    dst[0] = 0;\n    dst[1] = 0;\n    dst[2] = 0;\n    return dst;\n}\n/**\n * transform vec3 by 4x4 matrix\n * @param v - the vector\n * @param m - The matrix.\n * @param dst - optional vec3 to store result. If not passed a new one is created.\n * @returns the transformed vector\n */\nfunction transformMat4$1(v, m, dst) {\n    dst = dst || new VecType$1(3);\n    const x = v[0];\n    const y = v[1];\n    const z = v[2];\n    const w = (m[3] * x + m[7] * y + m[11] * z + m[15]) || 1;\n    dst[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;\n    dst[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;\n    dst[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;\n    return dst;\n}\n/**\n * Transform vec4 by upper 3x3 matrix inside 4x4 matrix.\n * @param v - The direction.\n * @param m - The matrix.\n * @param dst - optional Vec3 to store result. If not passed a new one is created.\n * @returns The transformed vector.\n */\nfunction transformMat4Upper3x3(v, m, dst) {\n    dst = dst || new VecType$1(3);\n    const v0 = v[0];\n    const v1 = v[1];\n    const v2 = v[2];\n    dst[0] = v0 * m[0 * 4 + 0] + v1 * m[1 * 4 + 0] + v2 * m[2 * 4 + 0];\n    dst[1] = v0 * m[0 * 4 + 1] + v1 * m[1 * 4 + 1] + v2 * m[2 * 4 + 1];\n    dst[2] = v0 * m[0 * 4 + 2] + v1 * m[1 * 4 + 2] + v2 * m[2 * 4 + 2];\n    return dst;\n}\n/**\n * Transforms vec4 by 3x3 matrix\n *\n * @param v - the vector\n * @param m - The matrix.\n * @param dst - optional vec3 to store result. If not passed a new one is created.\n * @returns the transformed vector\n */\nfunction transformMat3(v, m, dst) {\n    dst = dst || new VecType$1(3);\n    const x = v[0];\n    const y = v[1];\n    const z = v[2];\n    dst[0] = x * m[0] + y * m[4] + z * m[8];\n    dst[1] = x * m[1] + y * m[5] + z * m[9];\n    dst[2] = x * m[2] + y * m[6] + z * m[10];\n    return dst;\n}\n/**\n * Returns the translation component of a 4-by-4 matrix as a vector with 3\n * entries.\n * @param m - The matrix.\n * @param dst - vector to hold result. If not passed a new one is created.\n * @returns The translation component of m.\n */\nfunction getTranslation$1(m, dst) {\n    dst = dst || new VecType$1(3);\n    dst[0] = m[12];\n    dst[1] = m[13];\n    dst[2] = m[14];\n    return dst;\n}\n/**\n * Returns an axis of a 4x4 matrix as a vector with 3 entries\n * @param m - The matrix.\n * @param axis - The axis 0 = x, 1 = y, 2 = z;\n * @returns The axis component of m.\n */\nfunction getAxis$1(m, axis, dst) {\n    dst = dst || new VecType$1(3);\n    const off = axis * 4;\n    dst[0] = m[off + 0];\n    dst[1] = m[off + 1];\n    dst[2] = m[off + 2];\n    return dst;\n}\n/**\n * Returns the scaling component of the matrix\n * @param m - The Matrix\n * @param dst - The vector to set. If not passed a new one is created.\n */\nfunction getScaling$1(m, dst) {\n    dst = dst || new VecType$1(3);\n    const xx = m[0];\n    const xy = m[1];\n    const xz = m[2];\n    const yx = m[4];\n    const yy = m[5];\n    const yz = m[6];\n    const zx = m[8];\n    const zy = m[9];\n    const zz = m[10];\n    dst[0] = Math.sqrt(xx * xx + xy * xy + xz * xz);\n    dst[1] = Math.sqrt(yx * yx + yy * yy + yz * yz);\n    dst[2] = Math.sqrt(zx * zx + zy * zy + zz * zz);\n    return dst;\n}\n\nvar vec3Impl = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    add: add$2,\n    addScaled: addScaled$1,\n    angle: angle$1,\n    ceil: ceil$1,\n    clamp: clamp$1,\n    clone: clone$3,\n    copy: copy$3,\n    create: create$3,\n    cross: cross,\n    dist: dist$1,\n    distSq: distSq$1,\n    distance: distance$1,\n    distanceSq: distanceSq$1,\n    div: div$1,\n    divScalar: divScalar$2,\n    divide: divide$1,\n    dot: dot$2,\n    equals: equals$3,\n    equalsApproximately: equalsApproximately$3,\n    floor: floor$1,\n    fromValues: fromValues$2,\n    getAxis: getAxis$1,\n    getScaling: getScaling$1,\n    getTranslation: getTranslation$1,\n    inverse: inverse$3,\n    invert: invert$2,\n    len: len$2,\n    lenSq: lenSq$2,\n    length: length$2,\n    lengthSq: lengthSq$2,\n    lerp: lerp$2,\n    lerpV: lerpV$1,\n    max: max$1,\n    min: min$1,\n    mul: mul$3,\n    mulScalar: mulScalar$2,\n    multiply: multiply$3,\n    negate: negate$2,\n    normalize: normalize$2,\n    random: random,\n    round: round$1,\n    scale: scale$3,\n    setDefaultType: setDefaultType$4,\n    sub: sub$2,\n    subtract: subtract$2,\n    transformMat3: transformMat3,\n    transformMat4: transformMat4$1,\n    transformMat4Upper3x3: transformMat4Upper3x3,\n    zero: zero$1\n});\n\n/**\n * 4x4 Matrix math math functions.\n *\n * Almost all functions take an optional `dst` argument. If it is not passed in the\n * functions will create a new matrix. In other words you can do this\n *\n *     const mat = mat4.translation([1, 2, 3]);  // Creates a new translation matrix\n *\n * or\n *\n *     const mat = mat4.create();\n *     mat4.translation([1, 2, 3], mat);  // Puts translation matrix in mat.\n *\n * The first style is often easier but depending on where it's used it generates garbage where\n * as there is almost never allocation with the second style.\n *\n * It is always save to pass any matrix as the destination. So for example\n *\n *     const mat = mat4.identity();\n *     const trans = mat4.translation([1, 2, 3]);\n *     mat4.multiply(mat, trans, mat);  // Multiplies mat * trans and puts result in mat.\n *\n */\nlet MatType = Float32Array;\n/**\n * Sets the type this library creates for a Mat4\n * @param ctor - the constructor for the type. Either `Float32Array`, `Float64Array`, or `Array`\n * @returns previous constructor for Mat4\n */\nfunction setDefaultType$3(ctor) {\n    const oldType = MatType;\n    MatType = ctor;\n    return oldType;\n}\n/**\n * Create a Mat4 from values\n *\n * Note: Since passing in a raw JavaScript array\n * is valid in all circumstances, if you want to\n * force a JavaScript array into a Mat4's specified type\n * it would be faster to use\n *\n * ```\n * const m = mat4.clone(someJSArray);\n * ```\n *\n * Note: a consequence of the implementation is if your Mat4Type = `Array`\n * instead of `Float32Array` or `Float64Array` then any values you\n * don't pass in will be undefined. Usually this is not an issue since\n * (a) using `Array` is rare and (b) using `mat4.create` is usually used\n * to create a Mat4 to be filled out as in\n *\n * ```\n * const m = mat4.create();\n * mat4.perspective(fov, aspect, near, far, m);\n * ```\n *\n * @param v0 - value for element 0\n * @param v1 - value for element 1\n * @param v2 - value for element 2\n * @param v3 - value for element 3\n * @param v4 - value for element 4\n * @param v5 - value for element 5\n * @param v6 - value for element 6\n * @param v7 - value for element 7\n * @param v8 - value for element 8\n * @param v9 - value for element 9\n * @param v10 - value for element 10\n * @param v11 - value for element 11\n * @param v12 - value for element 12\n * @param v13 - value for element 13\n * @param v14 - value for element 14\n * @param v15 - value for element 15\n * @returns created from values.\n */\nfunction create$2(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15) {\n    const dst = new MatType(16);\n    if (v0 !== undefined) {\n        dst[0] = v0;\n        if (v1 !== undefined) {\n            dst[1] = v1;\n            if (v2 !== undefined) {\n                dst[2] = v2;\n                if (v3 !== undefined) {\n                    dst[3] = v3;\n                    if (v4 !== undefined) {\n                        dst[4] = v4;\n                        if (v5 !== undefined) {\n                            dst[5] = v5;\n                            if (v6 !== undefined) {\n                                dst[6] = v6;\n                                if (v7 !== undefined) {\n                                    dst[7] = v7;\n                                    if (v8 !== undefined) {\n                                        dst[8] = v8;\n                                        if (v9 !== undefined) {\n                                            dst[9] = v9;\n                                            if (v10 !== undefined) {\n                                                dst[10] = v10;\n                                                if (v11 !== undefined) {\n                                                    dst[11] = v11;\n                                                    if (v12 !== undefined) {\n                                                        dst[12] = v12;\n                                                        if (v13 !== undefined) {\n                                                            dst[13] = v13;\n                                                            if (v14 !== undefined) {\n                                                                dst[14] = v14;\n                                                                if (v15 !== undefined) {\n                                                                    dst[15] = v15;\n                                                                }\n                                                            }\n                                                        }\n                                                    }\n                                                }\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return dst;\n}\n/**\n * Creates a Mat4 from a Mat3\n * @param m3 - source matrix\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns Mat4 made from m3\n */\nfunction fromMat3(m3, dst) {\n    dst = dst || new MatType(16);\n    dst[0] = m3[0];\n    dst[1] = m3[1];\n    dst[2] = m3[2];\n    dst[3] = 0;\n    dst[4] = m3[4];\n    dst[5] = m3[5];\n    dst[6] = m3[6];\n    dst[7] = 0;\n    dst[8] = m3[8];\n    dst[9] = m3[9];\n    dst[10] = m3[10];\n    dst[11] = 0;\n    dst[12] = 0;\n    dst[13] = 0;\n    dst[14] = 0;\n    dst[15] = 1;\n    return dst;\n}\n/**\n * Creates a Mat4 rotation matrix from a quaternion\n * @param q - quaternion to create matrix from\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns Mat4 made from q\n */\nfunction fromQuat(q, dst) {\n    dst = dst || new MatType(16);\n    const x = q[0];\n    const y = q[1];\n    const z = q[2];\n    const w = q[3];\n    const x2 = x + x;\n    const y2 = y + y;\n    const z2 = z + z;\n    const xx = x * x2;\n    const yx = y * x2;\n    const yy = y * y2;\n    const zx = z * x2;\n    const zy = z * y2;\n    const zz = z * z2;\n    const wx = w * x2;\n    const wy = w * y2;\n    const wz = w * z2;\n    dst[0] = 1 - yy - zz;\n    dst[1] = yx + wz;\n    dst[2] = zx - wy;\n    dst[3] = 0;\n    dst[4] = yx - wz;\n    dst[5] = 1 - xx - zz;\n    dst[6] = zy + wx;\n    dst[7] = 0;\n    dst[8] = zx + wy;\n    dst[9] = zy - wx;\n    dst[10] = 1 - xx - yy;\n    dst[11] = 0;\n    dst[12] = 0;\n    dst[13] = 0;\n    dst[14] = 0;\n    dst[15] = 1;\n    return dst;\n}\n/**\n * Negates a matrix.\n * @param m - The matrix.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns -m.\n */\nfunction negate$1(m, dst) {\n    dst = dst || new MatType(16);\n    dst[0] = -m[0];\n    dst[1] = -m[1];\n    dst[2] = -m[2];\n    dst[3] = -m[3];\n    dst[4] = -m[4];\n    dst[5] = -m[5];\n    dst[6] = -m[6];\n    dst[7] = -m[7];\n    dst[8] = -m[8];\n    dst[9] = -m[9];\n    dst[10] = -m[10];\n    dst[11] = -m[11];\n    dst[12] = -m[12];\n    dst[13] = -m[13];\n    dst[14] = -m[14];\n    dst[15] = -m[15];\n    return dst;\n}\n/**\n * Copies a matrix.\n * @param m - The matrix.\n * @param dst - The matrix. If not passed a new one is created.\n * @returns A copy of m.\n */\nfunction copy$2(m, dst) {\n    dst = dst || new MatType(16);\n    dst[0] = m[0];\n    dst[1] = m[1];\n    dst[2] = m[2];\n    dst[3] = m[3];\n    dst[4] = m[4];\n    dst[5] = m[5];\n    dst[6] = m[6];\n    dst[7] = m[7];\n    dst[8] = m[8];\n    dst[9] = m[9];\n    dst[10] = m[10];\n    dst[11] = m[11];\n    dst[12] = m[12];\n    dst[13] = m[13];\n    dst[14] = m[14];\n    dst[15] = m[15];\n    return dst;\n}\n/**\n * Copies a matrix (same as copy)\n * @param m - The matrix.\n * @param dst - The matrix. If not passed a new one is created.\n * @returns A copy of m.\n */\nconst clone$2 = copy$2;\n/**\n * Check if 2 matrices are approximately equal\n * @param a - Operand matrix.\n * @param b - Operand matrix.\n * @returns true if matrices are approximately equal\n */\nfunction equalsApproximately$2(a, b) {\n    return Math.abs(a[0] - b[0]) < EPSILON &&\n        Math.abs(a[1] - b[1]) < EPSILON &&\n        Math.abs(a[2] - b[2]) < EPSILON &&\n        Math.abs(a[3] - b[3]) < EPSILON &&\n        Math.abs(a[4] - b[4]) < EPSILON &&\n        Math.abs(a[5] - b[5]) < EPSILON &&\n        Math.abs(a[6] - b[6]) < EPSILON &&\n        Math.abs(a[7] - b[7]) < EPSILON &&\n        Math.abs(a[8] - b[8]) < EPSILON &&\n        Math.abs(a[9] - b[9]) < EPSILON &&\n        Math.abs(a[10] - b[10]) < EPSILON &&\n        Math.abs(a[11] - b[11]) < EPSILON &&\n        Math.abs(a[12] - b[12]) < EPSILON &&\n        Math.abs(a[13] - b[13]) < EPSILON &&\n        Math.abs(a[14] - b[14]) < EPSILON &&\n        Math.abs(a[15] - b[15]) < EPSILON;\n}\n/**\n * Check if 2 matrices are exactly equal\n * @param a - Operand matrix.\n * @param b - Operand matrix.\n * @returns true if matrices are exactly equal\n */\nfunction equals$2(a, b) {\n    return a[0] === b[0] &&\n        a[1] === b[1] &&\n        a[2] === b[2] &&\n        a[3] === b[3] &&\n        a[4] === b[4] &&\n        a[5] === b[5] &&\n        a[6] === b[6] &&\n        a[7] === b[7] &&\n        a[8] === b[8] &&\n        a[9] === b[9] &&\n        a[10] === b[10] &&\n        a[11] === b[11] &&\n        a[12] === b[12] &&\n        a[13] === b[13] &&\n        a[14] === b[14] &&\n        a[15] === b[15];\n}\n/**\n * Creates a 4-by-4 identity matrix.\n *\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns A 4-by-4 identity matrix.\n */\nfunction identity$1(dst) {\n    dst = dst || new MatType(16);\n    dst[0] = 1;\n    dst[1] = 0;\n    dst[2] = 0;\n    dst[3] = 0;\n    dst[4] = 0;\n    dst[5] = 1;\n    dst[6] = 0;\n    dst[7] = 0;\n    dst[8] = 0;\n    dst[9] = 0;\n    dst[10] = 1;\n    dst[11] = 0;\n    dst[12] = 0;\n    dst[13] = 0;\n    dst[14] = 0;\n    dst[15] = 1;\n    return dst;\n}\n/**\n * Takes the transpose of a matrix.\n * @param m - The matrix.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The transpose of m.\n */\nfunction transpose(m, dst) {\n    dst = dst || new MatType(16);\n    if (dst === m) {\n        let t;\n        t = m[1];\n        m[1] = m[4];\n        m[4] = t;\n        t = m[2];\n        m[2] = m[8];\n        m[8] = t;\n        t = m[3];\n        m[3] = m[12];\n        m[12] = t;\n        t = m[6];\n        m[6] = m[9];\n        m[9] = t;\n        t = m[7];\n        m[7] = m[13];\n        m[13] = t;\n        t = m[11];\n        m[11] = m[14];\n        m[14] = t;\n        return dst;\n    }\n    const m00 = m[0 * 4 + 0];\n    const m01 = m[0 * 4 + 1];\n    const m02 = m[0 * 4 + 2];\n    const m03 = m[0 * 4 + 3];\n    const m10 = m[1 * 4 + 0];\n    const m11 = m[1 * 4 + 1];\n    const m12 = m[1 * 4 + 2];\n    const m13 = m[1 * 4 + 3];\n    const m20 = m[2 * 4 + 0];\n    const m21 = m[2 * 4 + 1];\n    const m22 = m[2 * 4 + 2];\n    const m23 = m[2 * 4 + 3];\n    const m30 = m[3 * 4 + 0];\n    const m31 = m[3 * 4 + 1];\n    const m32 = m[3 * 4 + 2];\n    const m33 = m[3 * 4 + 3];\n    dst[0] = m00;\n    dst[1] = m10;\n    dst[2] = m20;\n    dst[3] = m30;\n    dst[4] = m01;\n    dst[5] = m11;\n    dst[6] = m21;\n    dst[7] = m31;\n    dst[8] = m02;\n    dst[9] = m12;\n    dst[10] = m22;\n    dst[11] = m32;\n    dst[12] = m03;\n    dst[13] = m13;\n    dst[14] = m23;\n    dst[15] = m33;\n    return dst;\n}\n/**\n * Computes the inverse of a 4-by-4 matrix.\n * @param m - The matrix.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The inverse of m.\n */\nfunction inverse$2(m, dst) {\n    dst = dst || new MatType(16);\n    const m00 = m[0 * 4 + 0];\n    const m01 = m[0 * 4 + 1];\n    const m02 = m[0 * 4 + 2];\n    const m03 = m[0 * 4 + 3];\n    const m10 = m[1 * 4 + 0];\n    const m11 = m[1 * 4 + 1];\n    const m12 = m[1 * 4 + 2];\n    const m13 = m[1 * 4 + 3];\n    const m20 = m[2 * 4 + 0];\n    const m21 = m[2 * 4 + 1];\n    const m22 = m[2 * 4 + 2];\n    const m23 = m[2 * 4 + 3];\n    const m30 = m[3 * 4 + 0];\n    const m31 = m[3 * 4 + 1];\n    const m32 = m[3 * 4 + 2];\n    const m33 = m[3 * 4 + 3];\n    const tmp0 = m22 * m33;\n    const tmp1 = m32 * m23;\n    const tmp2 = m12 * m33;\n    const tmp3 = m32 * m13;\n    const tmp4 = m12 * m23;\n    const tmp5 = m22 * m13;\n    const tmp6 = m02 * m33;\n    const tmp7 = m32 * m03;\n    const tmp8 = m02 * m23;\n    const tmp9 = m22 * m03;\n    const tmp10 = m02 * m13;\n    const tmp11 = m12 * m03;\n    const tmp12 = m20 * m31;\n    const tmp13 = m30 * m21;\n    const tmp14 = m10 * m31;\n    const tmp15 = m30 * m11;\n    const tmp16 = m10 * m21;\n    const tmp17 = m20 * m11;\n    const tmp18 = m00 * m31;\n    const tmp19 = m30 * m01;\n    const tmp20 = m00 * m21;\n    const tmp21 = m20 * m01;\n    const tmp22 = m00 * m11;\n    const tmp23 = m10 * m01;\n    const t0 = (tmp0 * m11 + tmp3 * m21 + tmp4 * m31) -\n        (tmp1 * m11 + tmp2 * m21 + tmp5 * m31);\n    const t1 = (tmp1 * m01 + tmp6 * m21 + tmp9 * m31) -\n        (tmp0 * m01 + tmp7 * m21 + tmp8 * m31);\n    const t2 = (tmp2 * m01 + tmp7 * m11 + tmp10 * m31) -\n        (tmp3 * m01 + tmp6 * m11 + tmp11 * m31);\n    const t3 = (tmp5 * m01 + tmp8 * m11 + tmp11 * m21) -\n        (tmp4 * m01 + tmp9 * m11 + tmp10 * m21);\n    const d = 1 / (m00 * t0 + m10 * t1 + m20 * t2 + m30 * t3);\n    dst[0] = d * t0;\n    dst[1] = d * t1;\n    dst[2] = d * t2;\n    dst[3] = d * t3;\n    dst[4] = d * ((tmp1 * m10 + tmp2 * m20 + tmp5 * m30) -\n        (tmp0 * m10 + tmp3 * m20 + tmp4 * m30));\n    dst[5] = d * ((tmp0 * m00 + tmp7 * m20 + tmp8 * m30) -\n        (tmp1 * m00 + tmp6 * m20 + tmp9 * m30));\n    dst[6] = d * ((tmp3 * m00 + tmp6 * m10 + tmp11 * m30) -\n        (tmp2 * m00 + tmp7 * m10 + tmp10 * m30));\n    dst[7] = d * ((tmp4 * m00 + tmp9 * m10 + tmp10 * m20) -\n        (tmp5 * m00 + tmp8 * m10 + tmp11 * m20));\n    dst[8] = d * ((tmp12 * m13 + tmp15 * m23 + tmp16 * m33) -\n        (tmp13 * m13 + tmp14 * m23 + tmp17 * m33));\n    dst[9] = d * ((tmp13 * m03 + tmp18 * m23 + tmp21 * m33) -\n        (tmp12 * m03 + tmp19 * m23 + tmp20 * m33));\n    dst[10] = d * ((tmp14 * m03 + tmp19 * m13 + tmp22 * m33) -\n        (tmp15 * m03 + tmp18 * m13 + tmp23 * m33));\n    dst[11] = d * ((tmp17 * m03 + tmp20 * m13 + tmp23 * m23) -\n        (tmp16 * m03 + tmp21 * m13 + tmp22 * m23));\n    dst[12] = d * ((tmp14 * m22 + tmp17 * m32 + tmp13 * m12) -\n        (tmp16 * m32 + tmp12 * m12 + tmp15 * m22));\n    dst[13] = d * ((tmp20 * m32 + tmp12 * m02 + tmp19 * m22) -\n        (tmp18 * m22 + tmp21 * m32 + tmp13 * m02));\n    dst[14] = d * ((tmp18 * m12 + tmp23 * m32 + tmp15 * m02) -\n        (tmp22 * m32 + tmp14 * m02 + tmp19 * m12));\n    dst[15] = d * ((tmp22 * m22 + tmp16 * m02 + tmp21 * m12) -\n        (tmp20 * m12 + tmp23 * m22 + tmp17 * m02));\n    return dst;\n}\n/**\n * Compute the determinant of a matrix\n * @param m - the matrix\n * @returns the determinant\n */\nfunction determinant(m) {\n    const m00 = m[0 * 4 + 0];\n    const m01 = m[0 * 4 + 1];\n    const m02 = m[0 * 4 + 2];\n    const m03 = m[0 * 4 + 3];\n    const m10 = m[1 * 4 + 0];\n    const m11 = m[1 * 4 + 1];\n    const m12 = m[1 * 4 + 2];\n    const m13 = m[1 * 4 + 3];\n    const m20 = m[2 * 4 + 0];\n    const m21 = m[2 * 4 + 1];\n    const m22 = m[2 * 4 + 2];\n    const m23 = m[2 * 4 + 3];\n    const m30 = m[3 * 4 + 0];\n    const m31 = m[3 * 4 + 1];\n    const m32 = m[3 * 4 + 2];\n    const m33 = m[3 * 4 + 3];\n    const tmp0 = m22 * m33;\n    const tmp1 = m32 * m23;\n    const tmp2 = m12 * m33;\n    const tmp3 = m32 * m13;\n    const tmp4 = m12 * m23;\n    const tmp5 = m22 * m13;\n    const tmp6 = m02 * m33;\n    const tmp7 = m32 * m03;\n    const tmp8 = m02 * m23;\n    const tmp9 = m22 * m03;\n    const tmp10 = m02 * m13;\n    const tmp11 = m12 * m03;\n    const t0 = (tmp0 * m11 + tmp3 * m21 + tmp4 * m31) -\n        (tmp1 * m11 + tmp2 * m21 + tmp5 * m31);\n    const t1 = (tmp1 * m01 + tmp6 * m21 + tmp9 * m31) -\n        (tmp0 * m01 + tmp7 * m21 + tmp8 * m31);\n    const t2 = (tmp2 * m01 + tmp7 * m11 + tmp10 * m31) -\n        (tmp3 * m01 + tmp6 * m11 + tmp11 * m31);\n    const t3 = (tmp5 * m01 + tmp8 * m11 + tmp11 * m21) -\n        (tmp4 * m01 + tmp9 * m11 + tmp10 * m21);\n    return m00 * t0 + m10 * t1 + m20 * t2 + m30 * t3;\n}\n/**\n * Computes the inverse of a 4-by-4 matrix. (same as inverse)\n * @param m - The matrix.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The inverse of m.\n */\nconst invert$1 = inverse$2;\n/**\n * Multiplies two 4-by-4 matrices with a on the left and b on the right\n * @param a - The matrix on the left.\n * @param b - The matrix on the right.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The matrix product of a and b.\n */\nfunction multiply$2(a, b, dst) {\n    dst = dst || new MatType(16);\n    const a00 = a[0];\n    const a01 = a[1];\n    const a02 = a[2];\n    const a03 = a[3];\n    const a10 = a[4 + 0];\n    const a11 = a[4 + 1];\n    const a12 = a[4 + 2];\n    const a13 = a[4 + 3];\n    const a20 = a[8 + 0];\n    const a21 = a[8 + 1];\n    const a22 = a[8 + 2];\n    const a23 = a[8 + 3];\n    const a30 = a[12 + 0];\n    const a31 = a[12 + 1];\n    const a32 = a[12 + 2];\n    const a33 = a[12 + 3];\n    const b00 = b[0];\n    const b01 = b[1];\n    const b02 = b[2];\n    const b03 = b[3];\n    const b10 = b[4 + 0];\n    const b11 = b[4 + 1];\n    const b12 = b[4 + 2];\n    const b13 = b[4 + 3];\n    const b20 = b[8 + 0];\n    const b21 = b[8 + 1];\n    const b22 = b[8 + 2];\n    const b23 = b[8 + 3];\n    const b30 = b[12 + 0];\n    const b31 = b[12 + 1];\n    const b32 = b[12 + 2];\n    const b33 = b[12 + 3];\n    dst[0] = a00 * b00 + a10 * b01 + a20 * b02 + a30 * b03;\n    dst[1] = a01 * b00 + a11 * b01 + a21 * b02 + a31 * b03;\n    dst[2] = a02 * b00 + a12 * b01 + a22 * b02 + a32 * b03;\n    dst[3] = a03 * b00 + a13 * b01 + a23 * b02 + a33 * b03;\n    dst[4] = a00 * b10 + a10 * b11 + a20 * b12 + a30 * b13;\n    dst[5] = a01 * b10 + a11 * b11 + a21 * b12 + a31 * b13;\n    dst[6] = a02 * b10 + a12 * b11 + a22 * b12 + a32 * b13;\n    dst[7] = a03 * b10 + a13 * b11 + a23 * b12 + a33 * b13;\n    dst[8] = a00 * b20 + a10 * b21 + a20 * b22 + a30 * b23;\n    dst[9] = a01 * b20 + a11 * b21 + a21 * b22 + a31 * b23;\n    dst[10] = a02 * b20 + a12 * b21 + a22 * b22 + a32 * b23;\n    dst[11] = a03 * b20 + a13 * b21 + a23 * b22 + a33 * b23;\n    dst[12] = a00 * b30 + a10 * b31 + a20 * b32 + a30 * b33;\n    dst[13] = a01 * b30 + a11 * b31 + a21 * b32 + a31 * b33;\n    dst[14] = a02 * b30 + a12 * b31 + a22 * b32 + a32 * b33;\n    dst[15] = a03 * b30 + a13 * b31 + a23 * b32 + a33 * b33;\n    return dst;\n}\n/**\n * Multiplies two 4-by-4 matrices with a on the left and b on the right (same as multiply)\n * @param a - The matrix on the left.\n * @param b - The matrix on the right.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The matrix product of a and b.\n */\nconst mul$2 = multiply$2;\n/**\n * Sets the translation component of a 4-by-4 matrix to the given\n * vector.\n * @param a - The matrix.\n * @param v - The vector.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The matrix with translation set.\n */\nfunction setTranslation(a, v, dst) {\n    dst = dst || identity$1();\n    if (a !== dst) {\n        dst[0] = a[0];\n        dst[1] = a[1];\n        dst[2] = a[2];\n        dst[3] = a[3];\n        dst[4] = a[4];\n        dst[5] = a[5];\n        dst[6] = a[6];\n        dst[7] = a[7];\n        dst[8] = a[8];\n        dst[9] = a[9];\n        dst[10] = a[10];\n        dst[11] = a[11];\n    }\n    dst[12] = v[0];\n    dst[13] = v[1];\n    dst[14] = v[2];\n    dst[15] = 1;\n    return dst;\n}\n/**\n * Returns the translation component of a 4-by-4 matrix as a vector with 3\n * entries.\n * @param m - The matrix.\n * @param dst - vector to hold result. If not passed a new one is created.\n * @returns The translation component of m.\n */\nfunction getTranslation(m, dst) {\n    dst = dst || create$3();\n    dst[0] = m[12];\n    dst[1] = m[13];\n    dst[2] = m[14];\n    return dst;\n}\n/**\n * Returns an axis of a 4x4 matrix as a vector with 3 entries\n * @param m - The matrix.\n * @param axis - The axis 0 = x, 1 = y, 2 = z;\n * @returns The axis component of m.\n */\nfunction getAxis(m, axis, dst) {\n    dst = dst || create$3();\n    const off = axis * 4;\n    dst[0] = m[off + 0];\n    dst[1] = m[off + 1];\n    dst[2] = m[off + 2];\n    return dst;\n}\n/**\n * Sets an axis of a 4x4 matrix as a vector with 3 entries\n * @param m - The matrix.\n * @param v - the axis vector\n * @param axis - The axis  0 = x, 1 = y, 2 = z;\n * @param dst - The matrix to set. If not passed a new one is created.\n * @returns The matrix with axis set.\n */\nfunction setAxis(a, v, axis, dst) {\n    if (dst !== a) {\n        dst = copy$2(a, dst);\n    }\n    const off = axis * 4;\n    dst[off + 0] = v[0];\n    dst[off + 1] = v[1];\n    dst[off + 2] = v[2];\n    return dst;\n}\n/**\n * Returns the scaling component of the matrix\n * @param m - The Matrix\n * @param dst - The vector to set. If not passed a new one is created.\n */\nfunction getScaling(m, dst) {\n    dst = dst || create$3();\n    const xx = m[0];\n    const xy = m[1];\n    const xz = m[2];\n    const yx = m[4];\n    const yy = m[5];\n    const yz = m[6];\n    const zx = m[8];\n    const zy = m[9];\n    const zz = m[10];\n    dst[0] = Math.sqrt(xx * xx + xy * xy + xz * xz);\n    dst[1] = Math.sqrt(yx * yx + yy * yy + yz * yz);\n    dst[2] = Math.sqrt(zx * zx + zy * zy + zz * zz);\n    return dst;\n}\n/**\n * Computes a 4-by-4 perspective transformation matrix given the angular height\n * of the frustum, the aspect ratio, and the near and far clipping planes.  The\n * arguments define a frustum extending in the negative z direction.  The given\n * angle is the vertical angle of the frustum, and the horizontal angle is\n * determined to produce the given aspect ratio.  The arguments near and far are\n * the distances to the near and far clipping planes.  Note that near and far\n * are not z coordinates, but rather they are distances along the negative\n * z-axis.  The matrix generated sends the viewing frustum to the unit box.\n * We assume a unit box extending from -1 to 1 in the x and y dimensions and\n * from 0 to 1 in the z dimension.\n *\n * Note: If you pass `Infinity` for zFar then it will produce a projection matrix\n * returns -Infinity for Z when transforming coordinates with Z <= 0 and +Infinity for Z\n * otherwise.\n *\n * @param fieldOfViewYInRadians - The camera angle from top to bottom (in radians).\n * @param aspect - The aspect ratio width / height.\n * @param zNear - The depth (negative z coordinate)\n *     of the near clipping plane.\n * @param zFar - The depth (negative z coordinate)\n *     of the far clipping plane.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The perspective matrix.\n */\nfunction perspective(fieldOfViewYInRadians, aspect, zNear, zFar, dst) {\n    dst = dst || new MatType(16);\n    const f = Math.tan(Math.PI * 0.5 - 0.5 * fieldOfViewYInRadians);\n    dst[0] = f / aspect;\n    dst[1] = 0;\n    dst[2] = 0;\n    dst[3] = 0;\n    dst[4] = 0;\n    dst[5] = f;\n    dst[6] = 0;\n    dst[7] = 0;\n    dst[8] = 0;\n    dst[9] = 0;\n    dst[11] = -1;\n    dst[12] = 0;\n    dst[13] = 0;\n    dst[15] = 0;\n    if (zFar === Infinity) {\n        dst[10] = -1;\n        dst[14] = -zNear;\n    }\n    else {\n        const rangeInv = 1 / (zNear - zFar);\n        dst[10] = zFar * rangeInv;\n        dst[14] = zFar * zNear * rangeInv;\n    }\n    return dst;\n}\n/**\n * Computes a 4-by-4 orthogonal transformation matrix that transforms from\n * the given the left, right, bottom, and top dimensions to -1 +1 in x, and y\n * and 0 to +1 in z.\n * @param left - Left side of the near clipping plane viewport.\n * @param right - Right side of the near clipping plane viewport.\n * @param bottom - Bottom of the near clipping plane viewport.\n * @param top - Top of the near clipping plane viewport.\n * @param near - The depth (negative z coordinate)\n *     of the near clipping plane.\n * @param far - The depth (negative z coordinate)\n *     of the far clipping plane.\n * @param dst - Output matrix. If not passed a new one is created.\n * @returns The orthographic projection matrix.\n */\nfunction ortho(left, right, bottom, top, near, far, dst) {\n    dst = dst || new MatType(16);\n    dst[0] = 2 / (right - left);\n    dst[1] = 0;\n    dst[2] = 0;\n    dst[3] = 0;\n    dst[4] = 0;\n    dst[5] = 2 / (top - bottom);\n    dst[6] = 0;\n    dst[7] = 0;\n    dst[8] = 0;\n    dst[9] = 0;\n    dst[10] = 1 / (near - far);\n    dst[11] = 0;\n    dst[12] = (right + left) / (left - right);\n    dst[13] = (top + bottom) / (bottom - top);\n    dst[14] = near / (near - far);\n    dst[15] = 1;\n    return dst;\n}\n/**\n * Computes a 4-by-4 perspective transformation matrix given the left, right,\n * top, bottom, near and far clipping planes. The arguments define a frustum\n * extending in the negative z direction. The arguments near and far are the\n * distances to the near and far clipping planes. Note that near and far are not\n * z coordinates, but rather they are distances along the negative z-axis. The\n * matrix generated sends the viewing frustum to the unit box. We assume a unit\n * box extending from -1 to 1 in the x and y dimensions and from 0 to 1 in the z\n * dimension.\n * @param left - The x coordinate of the left plane of the box.\n * @param right - The x coordinate of the right plane of the box.\n * @param bottom - The y coordinate of the bottom plane of the box.\n * @param top - The y coordinate of the right plane of the box.\n * @param near - The negative z coordinate of the near plane of the box.\n * @param far - The negative z coordinate of the far plane of the box.\n * @param dst - Output matrix. If not passed a new one is created.\n * @returns The perspective projection matrix.\n */\nfunction frustum(left, right, bottom, top, near, far, dst) {\n    dst = dst || new MatType(16);\n    const dx = (right - left);\n    const dy = (top - bottom);\n    const dz = (near - far);\n    dst[0] = 2 * near / dx;\n    dst[1] = 0;\n    dst[2] = 0;\n    dst[3] = 0;\n    dst[4] = 0;\n    dst[5] = 2 * near / dy;\n    dst[6] = 0;\n    dst[7] = 0;\n    dst[8] = (left + right) / dx;\n    dst[9] = (top + bottom) / dy;\n    dst[10] = far / dz;\n    dst[11] = -1;\n    dst[12] = 0;\n    dst[13] = 0;\n    dst[14] = near * far / dz;\n    dst[15] = 0;\n    return dst;\n}\nlet xAxis;\nlet yAxis;\nlet zAxis;\n/**\n * Computes a 4-by-4 aim transformation.\n *\n * This is a matrix which positions an object aiming down positive Z.\n * toward the target.\n *\n * Note: this is **NOT** the inverse of lookAt as lookAt looks at negative Z.\n *\n * @param position - The position of the object.\n * @param target - The position meant to be aimed at.\n * @param up - A vector pointing up.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The aim matrix.\n */\nfunction aim(position, target, up, dst) {\n    dst = dst || new MatType(16);\n    xAxis = xAxis || create$3();\n    yAxis = yAxis || create$3();\n    zAxis = zAxis || create$3();\n    normalize$2(subtract$2(target, position, zAxis), zAxis);\n    normalize$2(cross(up, zAxis, xAxis), xAxis);\n    normalize$2(cross(zAxis, xAxis, yAxis), yAxis);\n    dst[0] = xAxis[0];\n    dst[1] = xAxis[1];\n    dst[2] = xAxis[2];\n    dst[3] = 0;\n    dst[4] = yAxis[0];\n    dst[5] = yAxis[1];\n    dst[6] = yAxis[2];\n    dst[7] = 0;\n    dst[8] = zAxis[0];\n    dst[9] = zAxis[1];\n    dst[10] = zAxis[2];\n    dst[11] = 0;\n    dst[12] = position[0];\n    dst[13] = position[1];\n    dst[14] = position[2];\n    dst[15] = 1;\n    return dst;\n}\n/**\n * Computes a 4-by-4 camera aim transformation.\n *\n * This is a matrix which positions an object aiming down negative Z.\n * toward the target.\n *\n * Note: this is the inverse of `lookAt`\n *\n * @param eye - The position of the object.\n * @param target - The position meant to be aimed at.\n * @param up - A vector pointing up.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The aim matrix.\n */\nfunction cameraAim(eye, target, up, dst) {\n    dst = dst || new MatType(16);\n    xAxis = xAxis || create$3();\n    yAxis = yAxis || create$3();\n    zAxis = zAxis || create$3();\n    normalize$2(subtract$2(eye, target, zAxis), zAxis);\n    normalize$2(cross(up, zAxis, xAxis), xAxis);\n    normalize$2(cross(zAxis, xAxis, yAxis), yAxis);\n    dst[0] = xAxis[0];\n    dst[1] = xAxis[1];\n    dst[2] = xAxis[2];\n    dst[3] = 0;\n    dst[4] = yAxis[0];\n    dst[5] = yAxis[1];\n    dst[6] = yAxis[2];\n    dst[7] = 0;\n    dst[8] = zAxis[0];\n    dst[9] = zAxis[1];\n    dst[10] = zAxis[2];\n    dst[11] = 0;\n    dst[12] = eye[0];\n    dst[13] = eye[1];\n    dst[14] = eye[2];\n    dst[15] = 1;\n    return dst;\n}\n/**\n * Computes a 4-by-4 view transformation.\n *\n * This is a view matrix which transforms all other objects\n * to be in the space of the view defined by the parameters.\n *\n * @param eye - The position of the object.\n * @param target - The position meant to be aimed at.\n * @param up - A vector pointing up.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The look-at matrix.\n */\nfunction lookAt(eye, target, up, dst) {\n    dst = dst || new MatType(16);\n    xAxis = xAxis || create$3();\n    yAxis = yAxis || create$3();\n    zAxis = zAxis || create$3();\n    normalize$2(subtract$2(eye, target, zAxis), zAxis);\n    normalize$2(cross(up, zAxis, xAxis), xAxis);\n    normalize$2(cross(zAxis, xAxis, yAxis), yAxis);\n    dst[0] = xAxis[0];\n    dst[1] = yAxis[0];\n    dst[2] = zAxis[0];\n    dst[3] = 0;\n    dst[4] = xAxis[1];\n    dst[5] = yAxis[1];\n    dst[6] = zAxis[1];\n    dst[7] = 0;\n    dst[8] = xAxis[2];\n    dst[9] = yAxis[2];\n    dst[10] = zAxis[2];\n    dst[11] = 0;\n    dst[12] = -(xAxis[0] * eye[0] + xAxis[1] * eye[1] + xAxis[2] * eye[2]);\n    dst[13] = -(yAxis[0] * eye[0] + yAxis[1] * eye[1] + yAxis[2] * eye[2]);\n    dst[14] = -(zAxis[0] * eye[0] + zAxis[1] * eye[1] + zAxis[2] * eye[2]);\n    dst[15] = 1;\n    return dst;\n}\n/**\n * Creates a 4-by-4 matrix which translates by the given vector v.\n * @param v - The vector by\n *     which to translate.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The translation matrix.\n */\nfunction translation(v, dst) {\n    dst = dst || new MatType(16);\n    dst[0] = 1;\n    dst[1] = 0;\n    dst[2] = 0;\n    dst[3] = 0;\n    dst[4] = 0;\n    dst[5] = 1;\n    dst[6] = 0;\n    dst[7] = 0;\n    dst[8] = 0;\n    dst[9] = 0;\n    dst[10] = 1;\n    dst[11] = 0;\n    dst[12] = v[0];\n    dst[13] = v[1];\n    dst[14] = v[2];\n    dst[15] = 1;\n    return dst;\n}\n/**\n * Translates the given 4-by-4 matrix by the given vector v.\n * @param m - The matrix.\n * @param v - The vector by\n *     which to translate.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The translated matrix.\n */\nfunction translate(m, v, dst) {\n    dst = dst || new MatType(16);\n    const v0 = v[0];\n    const v1 = v[1];\n    const v2 = v[2];\n    const m00 = m[0];\n    const m01 = m[1];\n    const m02 = m[2];\n    const m03 = m[3];\n    const m10 = m[1 * 4 + 0];\n    const m11 = m[1 * 4 + 1];\n    const m12 = m[1 * 4 + 2];\n    const m13 = m[1 * 4 + 3];\n    const m20 = m[2 * 4 + 0];\n    const m21 = m[2 * 4 + 1];\n    const m22 = m[2 * 4 + 2];\n    const m23 = m[2 * 4 + 3];\n    const m30 = m[3 * 4 + 0];\n    const m31 = m[3 * 4 + 1];\n    const m32 = m[3 * 4 + 2];\n    const m33 = m[3 * 4 + 3];\n    if (m !== dst) {\n        dst[0] = m00;\n        dst[1] = m01;\n        dst[2] = m02;\n        dst[3] = m03;\n        dst[4] = m10;\n        dst[5] = m11;\n        dst[6] = m12;\n        dst[7] = m13;\n        dst[8] = m20;\n        dst[9] = m21;\n        dst[10] = m22;\n        dst[11] = m23;\n    }\n    dst[12] = m00 * v0 + m10 * v1 + m20 * v2 + m30;\n    dst[13] = m01 * v0 + m11 * v1 + m21 * v2 + m31;\n    dst[14] = m02 * v0 + m12 * v1 + m22 * v2 + m32;\n    dst[15] = m03 * v0 + m13 * v1 + m23 * v2 + m33;\n    return dst;\n}\n/**\n * Creates a 4-by-4 matrix which rotates around the x-axis by the given angle.\n * @param angleInRadians - The angle by which to rotate (in radians).\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The rotation matrix.\n */\nfunction rotationX(angleInRadians, dst) {\n    dst = dst || new MatType(16);\n    const c = Math.cos(angleInRadians);\n    const s = Math.sin(angleInRadians);\n    dst[0] = 1;\n    dst[1] = 0;\n    dst[2] = 0;\n    dst[3] = 0;\n    dst[4] = 0;\n    dst[5] = c;\n    dst[6] = s;\n    dst[7] = 0;\n    dst[8] = 0;\n    dst[9] = -s;\n    dst[10] = c;\n    dst[11] = 0;\n    dst[12] = 0;\n    dst[13] = 0;\n    dst[14] = 0;\n    dst[15] = 1;\n    return dst;\n}\n/**\n * Rotates the given 4-by-4 matrix around the x-axis by the given\n * angle.\n * @param m - The matrix.\n * @param angleInRadians - The angle by which to rotate (in radians).\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The rotated matrix.\n */\nfunction rotateX$1(m, angleInRadians, dst) {\n    dst = dst || new MatType(16);\n    const m10 = m[4];\n    const m11 = m[5];\n    const m12 = m[6];\n    const m13 = m[7];\n    const m20 = m[8];\n    const m21 = m[9];\n    const m22 = m[10];\n    const m23 = m[11];\n    const c = Math.cos(angleInRadians);\n    const s = Math.sin(angleInRadians);\n    dst[4] = c * m10 + s * m20;\n    dst[5] = c * m11 + s * m21;\n    dst[6] = c * m12 + s * m22;\n    dst[7] = c * m13 + s * m23;\n    dst[8] = c * m20 - s * m10;\n    dst[9] = c * m21 - s * m11;\n    dst[10] = c * m22 - s * m12;\n    dst[11] = c * m23 - s * m13;\n    if (m !== dst) {\n        dst[0] = m[0];\n        dst[1] = m[1];\n        dst[2] = m[2];\n        dst[3] = m[3];\n        dst[12] = m[12];\n        dst[13] = m[13];\n        dst[14] = m[14];\n        dst[15] = m[15];\n    }\n    return dst;\n}\n/**\n * Creates a 4-by-4 matrix which rotates around the y-axis by the given angle.\n * @param angleInRadians - The angle by which to rotate (in radians).\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The rotation matrix.\n */\nfunction rotationY(angleInRadians, dst) {\n    dst = dst || new MatType(16);\n    const c = Math.cos(angleInRadians);\n    const s = Math.sin(angleInRadians);\n    dst[0] = c;\n    dst[1] = 0;\n    dst[2] = -s;\n    dst[3] = 0;\n    dst[4] = 0;\n    dst[5] = 1;\n    dst[6] = 0;\n    dst[7] = 0;\n    dst[8] = s;\n    dst[9] = 0;\n    dst[10] = c;\n    dst[11] = 0;\n    dst[12] = 0;\n    dst[13] = 0;\n    dst[14] = 0;\n    dst[15] = 1;\n    return dst;\n}\n/**\n * Rotates the given 4-by-4 matrix around the y-axis by the given\n * angle.\n * @param m - The matrix.\n * @param angleInRadians - The angle by which to rotate (in radians).\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The rotated matrix.\n */\nfunction rotateY$1(m, angleInRadians, dst) {\n    dst = dst || new MatType(16);\n    const m00 = m[0 * 4 + 0];\n    const m01 = m[0 * 4 + 1];\n    const m02 = m[0 * 4 + 2];\n    const m03 = m[0 * 4 + 3];\n    const m20 = m[2 * 4 + 0];\n    const m21 = m[2 * 4 + 1];\n    const m22 = m[2 * 4 + 2];\n    const m23 = m[2 * 4 + 3];\n    const c = Math.cos(angleInRadians);\n    const s = Math.sin(angleInRadians);\n    dst[0] = c * m00 - s * m20;\n    dst[1] = c * m01 - s * m21;\n    dst[2] = c * m02 - s * m22;\n    dst[3] = c * m03 - s * m23;\n    dst[8] = c * m20 + s * m00;\n    dst[9] = c * m21 + s * m01;\n    dst[10] = c * m22 + s * m02;\n    dst[11] = c * m23 + s * m03;\n    if (m !== dst) {\n        dst[4] = m[4];\n        dst[5] = m[5];\n        dst[6] = m[6];\n        dst[7] = m[7];\n        dst[12] = m[12];\n        dst[13] = m[13];\n        dst[14] = m[14];\n        dst[15] = m[15];\n    }\n    return dst;\n}\n/**\n * Creates a 4-by-4 matrix which rotates around the z-axis by the given angle.\n * @param angleInRadians - The angle by which to rotate (in radians).\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The rotation matrix.\n */\nfunction rotationZ(angleInRadians, dst) {\n    dst = dst || new MatType(16);\n    const c = Math.cos(angleInRadians);\n    const s = Math.sin(angleInRadians);\n    dst[0] = c;\n    dst[1] = s;\n    dst[2] = 0;\n    dst[3] = 0;\n    dst[4] = -s;\n    dst[5] = c;\n    dst[6] = 0;\n    dst[7] = 0;\n    dst[8] = 0;\n    dst[9] = 0;\n    dst[10] = 1;\n    dst[11] = 0;\n    dst[12] = 0;\n    dst[13] = 0;\n    dst[14] = 0;\n    dst[15] = 1;\n    return dst;\n}\n/**\n * Rotates the given 4-by-4 matrix around the z-axis by the given\n * angle.\n * @param m - The matrix.\n * @param angleInRadians - The angle by which to rotate (in radians).\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The rotated matrix.\n */\nfunction rotateZ$1(m, angleInRadians, dst) {\n    dst = dst || new MatType(16);\n    const m00 = m[0 * 4 + 0];\n    const m01 = m[0 * 4 + 1];\n    const m02 = m[0 * 4 + 2];\n    const m03 = m[0 * 4 + 3];\n    const m10 = m[1 * 4 + 0];\n    const m11 = m[1 * 4 + 1];\n    const m12 = m[1 * 4 + 2];\n    const m13 = m[1 * 4 + 3];\n    const c = Math.cos(angleInRadians);\n    const s = Math.sin(angleInRadians);\n    dst[0] = c * m00 + s * m10;\n    dst[1] = c * m01 + s * m11;\n    dst[2] = c * m02 + s * m12;\n    dst[3] = c * m03 + s * m13;\n    dst[4] = c * m10 - s * m00;\n    dst[5] = c * m11 - s * m01;\n    dst[6] = c * m12 - s * m02;\n    dst[7] = c * m13 - s * m03;\n    if (m !== dst) {\n        dst[8] = m[8];\n        dst[9] = m[9];\n        dst[10] = m[10];\n        dst[11] = m[11];\n        dst[12] = m[12];\n        dst[13] = m[13];\n        dst[14] = m[14];\n        dst[15] = m[15];\n    }\n    return dst;\n}\n/**\n * Creates a 4-by-4 matrix which rotates around the given axis by the given\n * angle.\n * @param axis - The axis\n *     about which to rotate.\n * @param angleInRadians - The angle by which to rotate (in radians).\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns A matrix which rotates angle radians\n *     around the axis.\n */\nfunction axisRotation(axis, angleInRadians, dst) {\n    dst = dst || new MatType(16);\n    let x = axis[0];\n    let y = axis[1];\n    let z = axis[2];\n    const n = Math.sqrt(x * x + y * y + z * z);\n    x /= n;\n    y /= n;\n    z /= n;\n    const xx = x * x;\n    const yy = y * y;\n    const zz = z * z;\n    const c = Math.cos(angleInRadians);\n    const s = Math.sin(angleInRadians);\n    const oneMinusCosine = 1 - c;\n    dst[0] = xx + (1 - xx) * c;\n    dst[1] = x * y * oneMinusCosine + z * s;\n    dst[2] = x * z * oneMinusCosine - y * s;\n    dst[3] = 0;\n    dst[4] = x * y * oneMinusCosine - z * s;\n    dst[5] = yy + (1 - yy) * c;\n    dst[6] = y * z * oneMinusCosine + x * s;\n    dst[7] = 0;\n    dst[8] = x * z * oneMinusCosine + y * s;\n    dst[9] = y * z * oneMinusCosine - x * s;\n    dst[10] = zz + (1 - zz) * c;\n    dst[11] = 0;\n    dst[12] = 0;\n    dst[13] = 0;\n    dst[14] = 0;\n    dst[15] = 1;\n    return dst;\n}\n/**\n * Creates a 4-by-4 matrix which rotates around the given axis by the given\n * angle. (same as axisRotation)\n * @param axis - The axis\n *     about which to rotate.\n * @param angleInRadians - The angle by which to rotate (in radians).\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns A matrix which rotates angle radians\n *     around the axis.\n */\nconst rotation = axisRotation;\n/**\n * Rotates the given 4-by-4 matrix around the given axis by the\n * given angle.\n * @param m - The matrix.\n * @param axis - The axis\n *     about which to rotate.\n * @param angleInRadians - The angle by which to rotate (in radians).\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The rotated matrix.\n */\nfunction axisRotate(m, axis, angleInRadians, dst) {\n    dst = dst || new MatType(16);\n    let x = axis[0];\n    let y = axis[1];\n    let z = axis[2];\n    const n = Math.sqrt(x * x + y * y + z * z);\n    x /= n;\n    y /= n;\n    z /= n;\n    const xx = x * x;\n    const yy = y * y;\n    const zz = z * z;\n    const c = Math.cos(angleInRadians);\n    const s = Math.sin(angleInRadians);\n    const oneMinusCosine = 1 - c;\n    const r00 = xx + (1 - xx) * c;\n    const r01 = x * y * oneMinusCosine + z * s;\n    const r02 = x * z * oneMinusCosine - y * s;\n    const r10 = x * y * oneMinusCosine - z * s;\n    const r11 = yy + (1 - yy) * c;\n    const r12 = y * z * oneMinusCosine + x * s;\n    const r20 = x * z * oneMinusCosine + y * s;\n    const r21 = y * z * oneMinusCosine - x * s;\n    const r22 = zz + (1 - zz) * c;\n    const m00 = m[0];\n    const m01 = m[1];\n    const m02 = m[2];\n    const m03 = m[3];\n    const m10 = m[4];\n    const m11 = m[5];\n    const m12 = m[6];\n    const m13 = m[7];\n    const m20 = m[8];\n    const m21 = m[9];\n    const m22 = m[10];\n    const m23 = m[11];\n    dst[0] = r00 * m00 + r01 * m10 + r02 * m20;\n    dst[1] = r00 * m01 + r01 * m11 + r02 * m21;\n    dst[2] = r00 * m02 + r01 * m12 + r02 * m22;\n    dst[3] = r00 * m03 + r01 * m13 + r02 * m23;\n    dst[4] = r10 * m00 + r11 * m10 + r12 * m20;\n    dst[5] = r10 * m01 + r11 * m11 + r12 * m21;\n    dst[6] = r10 * m02 + r11 * m12 + r12 * m22;\n    dst[7] = r10 * m03 + r11 * m13 + r12 * m23;\n    dst[8] = r20 * m00 + r21 * m10 + r22 * m20;\n    dst[9] = r20 * m01 + r21 * m11 + r22 * m21;\n    dst[10] = r20 * m02 + r21 * m12 + r22 * m22;\n    dst[11] = r20 * m03 + r21 * m13 + r22 * m23;\n    if (m !== dst) {\n        dst[12] = m[12];\n        dst[13] = m[13];\n        dst[14] = m[14];\n        dst[15] = m[15];\n    }\n    return dst;\n}\n/**\n * Rotates the given 4-by-4 matrix around the given axis by the\n * given angle. (same as rotate)\n * @param m - The matrix.\n * @param axis - The axis\n *     about which to rotate.\n * @param angleInRadians - The angle by which to rotate (in radians).\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The rotated matrix.\n */\nconst rotate = axisRotate;\n/**\n * Creates a 4-by-4 matrix which scales in each dimension by an amount given by\n * the corresponding entry in the given vector; assumes the vector has three\n * entries.\n * @param v - A vector of\n *     three entries specifying the factor by which to scale in each dimension.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The scaling matrix.\n */\nfunction scaling(v, dst) {\n    dst = dst || new MatType(16);\n    dst[0] = v[0];\n    dst[1] = 0;\n    dst[2] = 0;\n    dst[3] = 0;\n    dst[4] = 0;\n    dst[5] = v[1];\n    dst[6] = 0;\n    dst[7] = 0;\n    dst[8] = 0;\n    dst[9] = 0;\n    dst[10] = v[2];\n    dst[11] = 0;\n    dst[12] = 0;\n    dst[13] = 0;\n    dst[14] = 0;\n    dst[15] = 1;\n    return dst;\n}\n/**\n * Scales the given 4-by-4 matrix in each dimension by an amount\n * given by the corresponding entry in the given vector; assumes the vector has\n * three entries.\n * @param m - The matrix to be modified.\n * @param v - A vector of three entries specifying the\n *     factor by which to scale in each dimension.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The scaled matrix.\n */\nfunction scale$2(m, v, dst) {\n    dst = dst || new MatType(16);\n    const v0 = v[0];\n    const v1 = v[1];\n    const v2 = v[2];\n    dst[0] = v0 * m[0 * 4 + 0];\n    dst[1] = v0 * m[0 * 4 + 1];\n    dst[2] = v0 * m[0 * 4 + 2];\n    dst[3] = v0 * m[0 * 4 + 3];\n    dst[4] = v1 * m[1 * 4 + 0];\n    dst[5] = v1 * m[1 * 4 + 1];\n    dst[6] = v1 * m[1 * 4 + 2];\n    dst[7] = v1 * m[1 * 4 + 3];\n    dst[8] = v2 * m[2 * 4 + 0];\n    dst[9] = v2 * m[2 * 4 + 1];\n    dst[10] = v2 * m[2 * 4 + 2];\n    dst[11] = v2 * m[2 * 4 + 3];\n    if (m !== dst) {\n        dst[12] = m[12];\n        dst[13] = m[13];\n        dst[14] = m[14];\n        dst[15] = m[15];\n    }\n    return dst;\n}\n\nvar mat4Impl = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    aim: aim,\n    axisRotate: axisRotate,\n    axisRotation: axisRotation,\n    cameraAim: cameraAim,\n    clone: clone$2,\n    copy: copy$2,\n    create: create$2,\n    determinant: determinant,\n    equals: equals$2,\n    equalsApproximately: equalsApproximately$2,\n    fromMat3: fromMat3,\n    fromQuat: fromQuat,\n    frustum: frustum,\n    getAxis: getAxis,\n    getScaling: getScaling,\n    getTranslation: getTranslation,\n    identity: identity$1,\n    inverse: inverse$2,\n    invert: invert$1,\n    lookAt: lookAt,\n    mul: mul$2,\n    multiply: multiply$2,\n    negate: negate$1,\n    ortho: ortho,\n    perspective: perspective,\n    rotate: rotate,\n    rotateX: rotateX$1,\n    rotateY: rotateY$1,\n    rotateZ: rotateZ$1,\n    rotation: rotation,\n    rotationX: rotationX,\n    rotationY: rotationY,\n    rotationZ: rotationZ,\n    scale: scale$2,\n    scaling: scaling,\n    setAxis: setAxis,\n    setDefaultType: setDefaultType$3,\n    setTranslation: setTranslation,\n    translate: translate,\n    translation: translation,\n    transpose: transpose\n});\n\n/**\n *\n * Quat4 math functions.\n *\n * Almost all functions take an optional `dst` argument. If it is not passed in the\n * functions will create a new `Quat4`. In other words you can do this\n *\n *     const v = quat4.cross(v1, v2);  // Creates a new Quat4 with the cross product of v1 x v2.\n *\n * or\n *\n *     const v = quat4.create();\n *     quat4.cross(v1, v2, v);  // Puts the cross product of v1 x v2 in v\n *\n * The first style is often easier but depending on where it's used it generates garbage where\n * as there is almost never allocation with the second style.\n *\n * It is always safe to pass any vector as the destination. So for example\n *\n *     quat4.cross(v1, v2, v1);  // Puts the cross product of v1 x v2 in v1\n *\n */\nlet QuatType = Float32Array;\n/**\n * Sets the type this library creates for a Quat4\n * @param ctor - the constructor for the type. Either `Float32Array`, `Float64Array`, or `Array`\n * @returns previous constructor for Quat4\n */\nfunction setDefaultType$2(ctor) {\n    const oldType = QuatType;\n    QuatType = ctor;\n    return oldType;\n}\n/**\n * Creates a quat4; may be called with x, y, z to set initial values.\n * @param x - Initial x value.\n * @param y - Initial y value.\n * @param z - Initial z value.\n * @param w - Initial w value.\n * @returns the created vector\n */\nfunction create$1(x, y, z, w) {\n    const dst = new QuatType(4);\n    if (x !== undefined) {\n        dst[0] = x;\n        if (y !== undefined) {\n            dst[1] = y;\n            if (z !== undefined) {\n                dst[2] = z;\n                if (w !== undefined) {\n                    dst[3] = w;\n                }\n            }\n        }\n    }\n    return dst;\n}\n\n/*\n * Copyright 2022 Gregg Tavares\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n/**\n * Creates a Quat; may be called with x, y, z to set initial values. (same as create)\n * @param x - Initial x value.\n * @param y - Initial y value.\n * @param z - Initial z value.\n * @param z - Initial w value.\n * @returns the created vector\n */\nconst fromValues$1 = create$1;\n/**\n * Sets a quaternion from the given angle and  axis,\n * then returns it.\n *\n * @param axis - the axis to rotate around\n * @param angleInRadians - the angle\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns The quaternion that represents the given axis and angle\n **/\nfunction fromAxisAngle(axis, angleInRadians, dst) {\n    dst = dst || new QuatType(4);\n    const halfAngle = angleInRadians * 0.5;\n    const s = Math.sin(halfAngle);\n    dst[0] = s * axis[0];\n    dst[1] = s * axis[1];\n    dst[2] = s * axis[2];\n    dst[3] = Math.cos(halfAngle);\n    return dst;\n}\n/**\n * Gets the rotation axis and angle\n * @param q - quaternion to compute from\n * @param dst - Vec3 to hold result. If not passed in a new one is created.\n * @return angle and axis\n */\nfunction toAxisAngle(q, dst) {\n    dst = dst || create$3(4);\n    const angle = Math.acos(q[3]) * 2;\n    const s = Math.sin(angle * 0.5);\n    if (s > EPSILON) {\n        dst[0] = q[0] / s;\n        dst[1] = q[1] / s;\n        dst[2] = q[2] / s;\n    }\n    else {\n        dst[0] = 1;\n        dst[1] = 0;\n        dst[2] = 0;\n    }\n    return { angle, axis: dst };\n}\n/**\n * Returns the angle in degrees between two rotations a and b.\n * @param a - quaternion a\n * @param b - quaternion b\n * @return angle in radians between the two quaternions\n */\nfunction angle(a, b) {\n    const d = dot$1(a, b);\n    return Math.acos(2 * d * d - 1);\n}\n/**\n * Multiplies two quaternions\n *\n * @param a - the first quaternion\n * @param b - the second quaternion\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns A quaternion that is the result of a * b\n */\nfunction multiply$1(a, b, dst) {\n    dst = dst || new QuatType(4);\n    const ax = a[0];\n    const ay = a[1];\n    const az = a[2];\n    const aw = a[3];\n    const bx = b[0];\n    const by = b[1];\n    const bz = b[2];\n    const bw = b[3];\n    dst[0] = ax * bw + aw * bx + ay * bz - az * by;\n    dst[1] = ay * bw + aw * by + az * bx - ax * bz;\n    dst[2] = az * bw + aw * bz + ax * by - ay * bx;\n    dst[3] = aw * bw - ax * bx - ay * by - az * bz;\n    return dst;\n}\n/**\n * Multiplies two quaternions\n *\n * @param a - the first quaternion\n * @param b - the second quaternion\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns A quaternion that is the result of a * b\n */\nconst mul$1 = multiply$1;\n/**\n * Rotates the given quaternion around the X axis by the given angle.\n * @param q - quaternion to rotate\n * @param angleInRadians - The angle by which to rotate\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns A quaternion that is the result of a * b\n */\nfunction rotateX(q, angleInRadians, dst) {\n    dst = dst || new QuatType(4);\n    const halfAngle = angleInRadians * 0.5;\n    const qx = q[0];\n    const qy = q[1];\n    const qz = q[2];\n    const qw = q[3];\n    const bx = Math.sin(halfAngle);\n    const bw = Math.cos(halfAngle);\n    dst[0] = qx * bw + qw * bx;\n    dst[1] = qy * bw + qz * bx;\n    dst[2] = qz * bw - qy * bx;\n    dst[3] = qw * bw - qx * bx;\n    return dst;\n}\n/**\n * Rotates the given quaternion around the Y axis by the given angle.\n * @param q - quaternion to rotate\n * @param angleInRadians - The angle by which to rotate\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns A quaternion that is the result of a * b\n */\nfunction rotateY(q, angleInRadians, dst) {\n    dst = dst || new QuatType(4);\n    const halfAngle = angleInRadians * 0.5;\n    const qx = q[0];\n    const qy = q[1];\n    const qz = q[2];\n    const qw = q[3];\n    const by = Math.sin(halfAngle);\n    const bw = Math.cos(halfAngle);\n    dst[0] = qx * bw - qz * by;\n    dst[1] = qy * bw + qw * by;\n    dst[2] = qz * bw + qx * by;\n    dst[3] = qw * bw - qy * by;\n    return dst;\n}\n/**\n * Rotates the given quaternion around the Z axis by the given angle.\n * @param q - quaternion to rotate\n * @param angleInRadians - The angle by which to rotate\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns A quaternion that is the result of a * b\n */\nfunction rotateZ(q, angleInRadians, dst) {\n    dst = dst || new QuatType(4);\n    const halfAngle = angleInRadians * 0.5;\n    const qx = q[0];\n    const qy = q[1];\n    const qz = q[2];\n    const qw = q[3];\n    const bz = Math.sin(halfAngle);\n    const bw = Math.cos(halfAngle);\n    dst[0] = qx * bw + qy * bz;\n    dst[1] = qy * bw - qx * bz;\n    dst[2] = qz * bw + qw * bz;\n    dst[3] = qw * bw - qz * bz;\n    return dst;\n}\n/**\n * Spherically linear interpolate between two quaternions\n *\n * @param a - starting value\n * @param b - ending value\n * @param t - value where 0 = a and 1 = b\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns A quaternion that is the result of a * b\n */\nfunction slerp(a, b, t, dst) {\n    dst = dst || new QuatType(4);\n    const ax = a[0];\n    const ay = a[1];\n    const az = a[2];\n    const aw = a[3];\n    let bx = b[0];\n    let by = b[1];\n    let bz = b[2];\n    let bw = b[3];\n    let cosOmega = ax * bx + ay * by + az * bz + aw * bw;\n    if (cosOmega < 0) {\n        cosOmega = -cosOmega;\n        bx = -bx;\n        by = -by;\n        bz = -bz;\n        bw = -bw;\n    }\n    let scale0;\n    let scale1;\n    if (1.0 - cosOmega > EPSILON) {\n        const omega = Math.acos(cosOmega);\n        const sinOmega = Math.sin(omega);\n        scale0 = Math.sin((1 - t) * omega) / sinOmega;\n        scale1 = Math.sin(t * omega) / sinOmega;\n    }\n    else {\n        scale0 = 1.0 - t;\n        scale1 = t;\n    }\n    dst[0] = scale0 * ax + scale1 * bx;\n    dst[1] = scale0 * ay + scale1 * by;\n    dst[2] = scale0 * az + scale1 * bz;\n    dst[3] = scale0 * aw + scale1 * bw;\n    return dst;\n}\n/**\n * Compute the inverse of a quaternion\n *\n * @param q - quaternion to compute the inverse of\n * @returns A quaternion that is the result of a * b\n */\nfunction inverse$1(q, dst) {\n    dst = dst || new QuatType(4);\n    const a0 = q[0];\n    const a1 = q[1];\n    const a2 = q[2];\n    const a3 = q[3];\n    const dot = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3;\n    const invDot = dot ? 1 / dot : 0;\n    dst[0] = -a0 * invDot;\n    dst[1] = -a1 * invDot;\n    dst[2] = -a2 * invDot;\n    dst[3] = a3 * invDot;\n    return dst;\n}\n/**\n * Compute the conjugate of a quaternion\n * For quaternions with a magnitude of 1 (a unit quaternion)\n * this returns the same as the inverse but is faster to calculate.\n *\n * @param q - quaternion to compute the conjugate of.\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns The conjugate of q\n */\nfunction conjugate(q, dst) {\n    dst = dst || new QuatType(4);\n    dst[0] = -q[0];\n    dst[1] = -q[1];\n    dst[2] = -q[2];\n    dst[3] = q[3];\n    return dst;\n}\n/**\n * Creates a quaternion from the given rotation matrix.\n *\n * The created quaternion is not normalized.\n *\n * @param m - rotation matrix\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns the result\n */\nfunction fromMat(m, dst) {\n    dst = dst || new QuatType(4);\n    /*\n    0 1 2\n    3 4 5\n    6 7 8\n  \n    0 1 2\n    4 5 6\n    8 9 10\n     */\n    // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes\n    // article \"Quaternion Calculus and Fast Animation\".\n    const trace = m[0] + m[5] + m[10];\n    if (trace > 0.0) {\n        // |w| > 1/2, may as well choose w > 1/2\n        const root = Math.sqrt(trace + 1); // 2w\n        dst[3] = 0.5 * root;\n        const invRoot = 0.5 / root; // 1/(4w)\n        dst[0] = (m[6] - m[9]) * invRoot;\n        dst[1] = (m[8] - m[2]) * invRoot;\n        dst[2] = (m[1] - m[4]) * invRoot;\n    }\n    else {\n        // |w| <= 1/2\n        let i = 0;\n        if (m[5] > m[0]) {\n            i = 1;\n        }\n        if (m[10] > m[i * 4 + i]) {\n            i = 2;\n        }\n        const j = (i + 1) % 3;\n        const k = (i + 2) % 3;\n        const root = Math.sqrt(m[i * 4 + i] - m[j * 4 + j] - m[k * 4 + k] + 1.0);\n        dst[i] = 0.5 * root;\n        const invRoot = 0.5 / root;\n        dst[3] = (m[j * 4 + k] - m[k * 4 + j]) * invRoot;\n        dst[j] = (m[j * 4 + i] + m[i * 4 + j]) * invRoot;\n        dst[k] = (m[k * 4 + i] + m[i * 4 + k]) * invRoot;\n    }\n    return dst;\n}\n/**\n * Creates a quaternion from the given euler angle x, y, z using the provided intrinsic order for the conversion.\n *\n * @param xAngleInRadians - angle to rotate around X axis in radians.\n * @param yAngleInRadians - angle to rotate around Y axis in radians.\n * @param zAngleInRadians - angle to rotate around Z axis in radians.\n * @param order - order to apply euler angles\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns A quaternion representing the same rotation as the euler angles applied in the given order\n */\nfunction fromEuler(xAngleInRadians, yAngleInRadians, zAngleInRadians, order, dst) {\n    dst = dst || new QuatType(4);\n    const xHalfAngle = xAngleInRadians * 0.5;\n    const yHalfAngle = yAngleInRadians * 0.5;\n    const zHalfAngle = zAngleInRadians * 0.5;\n    const sx = Math.sin(xHalfAngle);\n    const cx = Math.cos(xHalfAngle);\n    const sy = Math.sin(yHalfAngle);\n    const cy = Math.cos(yHalfAngle);\n    const sz = Math.sin(zHalfAngle);\n    const cz = Math.cos(zHalfAngle);\n    switch (order) {\n        case 'xyz':\n            dst[0] = sx * cy * cz + cx * sy * sz;\n            dst[1] = cx * sy * cz - sx * cy * sz;\n            dst[2] = cx * cy * sz + sx * sy * cz;\n            dst[3] = cx * cy * cz - sx * sy * sz;\n            break;\n        case 'xzy':\n            dst[0] = sx * cy * cz - cx * sy * sz;\n            dst[1] = cx * sy * cz - sx * cy * sz;\n            dst[2] = cx * cy * sz + sx * sy * cz;\n            dst[3] = cx * cy * cz + sx * sy * sz;\n            break;\n        case 'yxz':\n            dst[0] = sx * cy * cz + cx * sy * sz;\n            dst[1] = cx * sy * cz - sx * cy * sz;\n            dst[2] = cx * cy * sz - sx * sy * cz;\n            dst[3] = cx * cy * cz + sx * sy * sz;\n            break;\n        case 'yzx':\n            dst[0] = sx * cy * cz + cx * sy * sz;\n            dst[1] = cx * sy * cz + sx * cy * sz;\n            dst[2] = cx * cy * sz - sx * sy * cz;\n            dst[3] = cx * cy * cz - sx * sy * sz;\n            break;\n        case 'zxy':\n            dst[0] = sx * cy * cz - cx * sy * sz;\n            dst[1] = cx * sy * cz + sx * cy * sz;\n            dst[2] = cx * cy * sz + sx * sy * cz;\n            dst[3] = cx * cy * cz - sx * sy * sz;\n            break;\n        case 'zyx':\n            dst[0] = sx * cy * cz - cx * sy * sz;\n            dst[1] = cx * sy * cz + sx * cy * sz;\n            dst[2] = cx * cy * sz - sx * sy * cz;\n            dst[3] = cx * cy * cz + sx * sy * sz;\n            break;\n        default:\n            throw new Error(`Unknown rotation order: ${order}`);\n    }\n    return dst;\n}\n/**\n * Copies a quaternion. (same as clone)\n * @param q - The quaternion.\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns A quaternion that is a copy of q\n */\nfunction copy$1(q, dst) {\n    dst = dst || new QuatType(4);\n    dst[0] = q[0];\n    dst[1] = q[1];\n    dst[2] = q[2];\n    dst[3] = q[3];\n    return dst;\n}\n/**\n * Clones a quaternion. (same as copy)\n * @param q - The quaternion.\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns A copy of q.\n */\nconst clone$1 = copy$1;\n/**\n * Adds two quaternions; assumes a and b have the same dimension.\n * @param a - Operand quaternion.\n * @param b - Operand quaternion.\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns A quaternion that is the sum of a and b.\n */\nfunction add$1(a, b, dst) {\n    dst = dst || new QuatType(4);\n    dst[0] = a[0] + b[0];\n    dst[1] = a[1] + b[1];\n    dst[2] = a[2] + b[2];\n    dst[3] = a[3] + b[3];\n    return dst;\n}\n/**\n * Subtracts two quaternions.\n * @param a - Operand quaternion.\n * @param b - Operand quaternion.\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns A quaternion that is the difference of a and b.\n */\nfunction subtract$1(a, b, dst) {\n    dst = dst || new QuatType(4);\n    dst[0] = a[0] - b[0];\n    dst[1] = a[1] - b[1];\n    dst[2] = a[2] - b[2];\n    dst[3] = a[3] - b[3];\n    return dst;\n}\n/**\n * Subtracts two quaternions.\n * @param a - Operand quaternion.\n * @param b - Operand quaternion.\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns A quaternion that is the difference of a and b.\n */\nconst sub$1 = subtract$1;\n/**\n * Multiplies a quaternion by a scalar.\n * @param v - The quaternion.\n * @param k - The scalar.\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns The scaled quaternion.\n */\nfunction mulScalar$1(v, k, dst) {\n    dst = dst || new QuatType(4);\n    dst[0] = v[0] * k;\n    dst[1] = v[1] * k;\n    dst[2] = v[2] * k;\n    dst[3] = v[3] * k;\n    return dst;\n}\n/**\n * Multiplies a quaternion by a scalar. (same as mulScalar)\n * @param v - The quaternion.\n * @param k - The scalar.\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns The scaled quaternion.\n */\nconst scale$1 = mulScalar$1;\n/**\n * Divides a vector by a scalar.\n * @param v - The vector.\n * @param k - The scalar.\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns The scaled quaternion.\n */\nfunction divScalar$1(v, k, dst) {\n    dst = dst || new QuatType(4);\n    dst[0] = v[0] / k;\n    dst[1] = v[1] / k;\n    dst[2] = v[2] / k;\n    dst[3] = v[3] / k;\n    return dst;\n}\n/**\n * Computes the dot product of two quaternions\n * @param a - Operand quaternion.\n * @param b - Operand quaternion.\n * @returns dot product\n */\nfunction dot$1(a, b) {\n    return (a[0] * b[0]) + (a[1] * b[1]) + (a[2] * b[2]) + (a[3] * b[3]);\n}\n/**\n * Performs linear interpolation on two quaternions.\n * Given quaternions a and b and interpolation coefficient t, returns\n * a + t * (b - a).\n * @param a - Operand quaternion.\n * @param b - Operand quaternion.\n * @param t - Interpolation coefficient.\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns The linear interpolated result.\n */\nfunction lerp$1(a, b, t, dst) {\n    dst = dst || new QuatType(4);\n    dst[0] = a[0] + t * (b[0] - a[0]);\n    dst[1] = a[1] + t * (b[1] - a[1]);\n    dst[2] = a[2] + t * (b[2] - a[2]);\n    dst[3] = a[3] + t * (b[3] - a[3]);\n    return dst;\n}\n/**\n * Computes the length of quaternion\n * @param v - quaternion.\n * @returns length of quaternion.\n */\nfunction length$1(v) {\n    const v0 = v[0];\n    const v1 = v[1];\n    const v2 = v[2];\n    const v3 = v[3];\n    return Math.sqrt(v0 * v0 + v1 * v1 + v2 * v2 + v3 * v3);\n}\n/**\n * Computes the length of quaternion (same as length)\n * @param v - quaternion.\n * @returns length of quaternion.\n */\nconst len$1 = length$1;\n/**\n * Computes the square of the length of quaternion\n * @param v - quaternion.\n * @returns square of the length of quaternion.\n */\nfunction lengthSq$1(v) {\n    const v0 = v[0];\n    const v1 = v[1];\n    const v2 = v[2];\n    const v3 = v[3];\n    return v0 * v0 + v1 * v1 + v2 * v2 + v3 * v3;\n}\n/**\n * Computes the square of the length of quaternion (same as lengthSq)\n * @param v - quaternion.\n * @returns square of the length of quaternion.\n */\nconst lenSq$1 = lengthSq$1;\n/**\n * Divides a quaternion by its Euclidean length and returns the quotient.\n * @param v - The quaternion.\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns The normalized quaternion.\n */\nfunction normalize$1(v, dst) {\n    dst = dst || new QuatType(4);\n    const v0 = v[0];\n    const v1 = v[1];\n    const v2 = v[2];\n    const v3 = v[3];\n    const len = Math.sqrt(v0 * v0 + v1 * v1 + v2 * v2 + v3 * v3);\n    if (len > 0.00001) {\n        dst[0] = v0 / len;\n        dst[1] = v1 / len;\n        dst[2] = v2 / len;\n        dst[3] = v3 / len;\n    }\n    else {\n        dst[0] = 0;\n        dst[1] = 0;\n        dst[2] = 0;\n        dst[3] = 0;\n    }\n    return dst;\n}\n/**\n * Check if 2 quaternions are approximately equal\n * @param a - Operand quaternion.\n * @param b - Operand quaternion.\n * @returns true if quaternions are approximately equal\n */\nfunction equalsApproximately$1(a, b) {\n    return Math.abs(a[0] - b[0]) < EPSILON &&\n        Math.abs(a[1] - b[1]) < EPSILON &&\n        Math.abs(a[2] - b[2]) < EPSILON &&\n        Math.abs(a[3] - b[3]) < EPSILON;\n}\n/**\n * Check if 2 quaternions are exactly equal\n * @param a - Operand quaternion.\n * @param b - Operand quaternion.\n * @returns true if quaternions are exactly equal\n */\nfunction equals$1(a, b) {\n    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];\n}\n/**\n * Creates an identity quaternion\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns an identity quaternion\n */\nfunction identity(dst) {\n    dst = dst || new QuatType(4);\n    dst[0] = 0;\n    dst[1] = 0;\n    dst[2] = 0;\n    dst[3] = 1;\n    return dst;\n}\nlet tempVec3;\nlet xUnitVec3;\nlet yUnitVec3;\n/**\n * Computes a quaternion to represent the shortest rotation from one vector to another.\n *\n * @param aUnit - the start vector\n * @param bUnit - the end vector\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns the result\n */\nfunction rotationTo(aUnit, bUnit, dst) {\n    dst = dst || new QuatType(4);\n    tempVec3 = tempVec3 || create$3();\n    xUnitVec3 = xUnitVec3 || create$3(1, 0, 0);\n    yUnitVec3 = yUnitVec3 || create$3(0, 1, 0);\n    const dot = dot$2(aUnit, bUnit);\n    if (dot < -0.999999) {\n        cross(xUnitVec3, aUnit, tempVec3);\n        if (len$2(tempVec3) < 0.000001) {\n            cross(yUnitVec3, aUnit, tempVec3);\n        }\n        normalize$2(tempVec3, tempVec3);\n        fromAxisAngle(tempVec3, Math.PI, dst);\n        return dst;\n    }\n    else if (dot > 0.999999) {\n        dst[0] = 0;\n        dst[1] = 0;\n        dst[2] = 0;\n        dst[3] = 1;\n        return dst;\n    }\n    else {\n        cross(aUnit, bUnit, tempVec3);\n        dst[0] = tempVec3[0];\n        dst[1] = tempVec3[1];\n        dst[2] = tempVec3[2];\n        dst[3] = 1 + dot;\n        return normalize$1(dst, dst);\n    }\n}\nlet tempQuat1;\nlet tempQuat2;\n/**\n * Performs a spherical linear interpolation with two control points\n *\n * @param a - the first quaternion\n * @param b - the second quaternion\n * @param c - the third quaternion\n * @param d - the fourth quaternion\n * @param t - Interpolation coefficient 0 to 1\n * @returns result\n */\nfunction sqlerp(a, b, c, d, t, dst) {\n    dst = dst || new QuatType(4);\n    tempQuat1 = tempQuat1 || new QuatType(4);\n    tempQuat2 = tempQuat2 || new QuatType(4);\n    slerp(a, d, t, tempQuat1);\n    slerp(b, c, t, tempQuat2);\n    slerp(tempQuat1, tempQuat2, 2 * t * (1 - t), dst);\n    return dst;\n}\n\nvar quatImpl = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    add: add$1,\n    angle: angle,\n    clone: clone$1,\n    conjugate: conjugate,\n    copy: copy$1,\n    create: create$1,\n    divScalar: divScalar$1,\n    dot: dot$1,\n    equals: equals$1,\n    equalsApproximately: equalsApproximately$1,\n    fromAxisAngle: fromAxisAngle,\n    fromEuler: fromEuler,\n    fromMat: fromMat,\n    fromValues: fromValues$1,\n    identity: identity,\n    inverse: inverse$1,\n    len: len$1,\n    lenSq: lenSq$1,\n    length: length$1,\n    lengthSq: lengthSq$1,\n    lerp: lerp$1,\n    mul: mul$1,\n    mulScalar: mulScalar$1,\n    multiply: multiply$1,\n    normalize: normalize$1,\n    rotateX: rotateX,\n    rotateY: rotateY,\n    rotateZ: rotateZ,\n    rotationTo: rotationTo,\n    scale: scale$1,\n    setDefaultType: setDefaultType$2,\n    slerp: slerp,\n    sqlerp: sqlerp,\n    sub: sub$1,\n    subtract: subtract$1,\n    toAxisAngle: toAxisAngle\n});\n\n/**\n *\n * Vec4 math functions.\n *\n * Almost all functions take an optional `dst` argument. If it is not passed in the\n * functions will create a new `Vec4`. In other words you can do this\n *\n *     const v = vec4.cross(v1, v2);  // Creates a new Vec4 with the cross product of v1 x v2.\n *\n * or\n *\n *     const v = vec4.create();\n *     vec4.cross(v1, v2, v);  // Puts the cross product of v1 x v2 in v\n *\n * The first style is often easier but depending on where it's used it generates garbage where\n * as there is almost never allocation with the second style.\n *\n * It is always safe to pass any vector as the destination. So for example\n *\n *     vec4.cross(v1, v2, v1);  // Puts the cross product of v1 x v2 in v1\n *\n */\nlet VecType = Float32Array;\n/**\n * Sets the type this library creates for a Vec4\n * @param ctor - the constructor for the type. Either `Float32Array`, `Float64Array`, or `Array`\n * @returns previous constructor for Vec4\n */\nfunction setDefaultType$1(ctor) {\n    const oldType = VecType;\n    VecType = ctor;\n    return oldType;\n}\n/**\n * Creates a vec4; may be called with x, y, z to set initial values.\n * @param x - Initial x value.\n * @param y - Initial y value.\n * @param z - Initial z value.\n * @param w - Initial w value.\n * @returns the created vector\n */\nfunction create(x, y, z, w) {\n    const dst = new VecType(4);\n    if (x !== undefined) {\n        dst[0] = x;\n        if (y !== undefined) {\n            dst[1] = y;\n            if (z !== undefined) {\n                dst[2] = z;\n                if (w !== undefined) {\n                    dst[3] = w;\n                }\n            }\n        }\n    }\n    return dst;\n}\n\n/*\n * Copyright 2022 Gregg Tavares\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n/**\n * Creates a vec4; may be called with x, y, z to set initial values. (same as create)\n * @param x - Initial x value.\n * @param y - Initial y value.\n * @param z - Initial z value.\n * @param z - Initial w value.\n * @returns the created vector\n */\nconst fromValues = create;\n/**\n * Applies Math.ceil to each element of vector\n * @param v - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that is the ceil of each element of v.\n */\nfunction ceil(v, dst) {\n    dst = dst || new VecType(4);\n    dst[0] = Math.ceil(v[0]);\n    dst[1] = Math.ceil(v[1]);\n    dst[2] = Math.ceil(v[2]);\n    dst[3] = Math.ceil(v[3]);\n    return dst;\n}\n/**\n * Applies Math.floor to each element of vector\n * @param v - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that is the floor of each element of v.\n */\nfunction floor(v, dst) {\n    dst = dst || new VecType(4);\n    dst[0] = Math.floor(v[0]);\n    dst[1] = Math.floor(v[1]);\n    dst[2] = Math.floor(v[2]);\n    dst[3] = Math.floor(v[3]);\n    return dst;\n}\n/**\n * Applies Math.round to each element of vector\n * @param v - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that is the round of each element of v.\n */\nfunction round(v, dst) {\n    dst = dst || new VecType(4);\n    dst[0] = Math.round(v[0]);\n    dst[1] = Math.round(v[1]);\n    dst[2] = Math.round(v[2]);\n    dst[3] = Math.round(v[3]);\n    return dst;\n}\n/**\n * Clamp each element of vector between min and max\n * @param v - Operand vector.\n * @param max - Min value, default 0\n * @param min - Max value, default 1\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that the clamped value of each element of v.\n */\nfunction clamp(v, min = 0, max = 1, dst) {\n    dst = dst || new VecType(4);\n    dst[0] = Math.min(max, Math.max(min, v[0]));\n    dst[1] = Math.min(max, Math.max(min, v[1]));\n    dst[2] = Math.min(max, Math.max(min, v[2]));\n    dst[3] = Math.min(max, Math.max(min, v[3]));\n    return dst;\n}\n/**\n * Adds two vectors; assumes a and b have the same dimension.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that is the sum of a and b.\n */\nfunction add(a, b, dst) {\n    dst = dst || new VecType(4);\n    dst[0] = a[0] + b[0];\n    dst[1] = a[1] + b[1];\n    dst[2] = a[2] + b[2];\n    dst[3] = a[3] + b[3];\n    return dst;\n}\n/**\n * Adds two vectors, scaling the 2nd; assumes a and b have the same dimension.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param scale - Amount to scale b\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that is the sum of a + b * scale.\n */\nfunction addScaled(a, b, scale, dst) {\n    dst = dst || new VecType(4);\n    dst[0] = a[0] + b[0] * scale;\n    dst[1] = a[1] + b[1] * scale;\n    dst[2] = a[2] + b[2] * scale;\n    dst[3] = a[3] + b[3] * scale;\n    return dst;\n}\n/**\n * Subtracts two vectors.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that is the difference of a and b.\n */\nfunction subtract(a, b, dst) {\n    dst = dst || new VecType(4);\n    dst[0] = a[0] - b[0];\n    dst[1] = a[1] - b[1];\n    dst[2] = a[2] - b[2];\n    dst[3] = a[3] - b[3];\n    return dst;\n}\n/**\n * Subtracts two vectors.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that is the difference of a and b.\n */\nconst sub = subtract;\n/**\n * Check if 2 vectors are approximately equal\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @returns true if vectors are approximately equal\n */\nfunction equalsApproximately(a, b) {\n    return Math.abs(a[0] - b[0]) < EPSILON &&\n        Math.abs(a[1] - b[1]) < EPSILON &&\n        Math.abs(a[2] - b[2]) < EPSILON &&\n        Math.abs(a[3] - b[3]) < EPSILON;\n}\n/**\n * Check if 2 vectors are exactly equal\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @returns true if vectors are exactly equal\n */\nfunction equals(a, b) {\n    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];\n}\n/**\n * Performs linear interpolation on two vectors.\n * Given vectors a and b and interpolation coefficient t, returns\n * a + t * (b - a).\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param t - Interpolation coefficient.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The linear interpolated result.\n */\nfunction lerp(a, b, t, dst) {\n    dst = dst || new VecType(4);\n    dst[0] = a[0] + t * (b[0] - a[0]);\n    dst[1] = a[1] + t * (b[1] - a[1]);\n    dst[2] = a[2] + t * (b[2] - a[2]);\n    dst[3] = a[3] + t * (b[3] - a[3]);\n    return dst;\n}\n/**\n * Performs linear interpolation on two vectors.\n * Given vectors a and b and interpolation coefficient vector t, returns\n * a + t * (b - a).\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param t - Interpolation coefficients vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns the linear interpolated result.\n */\nfunction lerpV(a, b, t, dst) {\n    dst = dst || new VecType(4);\n    dst[0] = a[0] + t[0] * (b[0] - a[0]);\n    dst[1] = a[1] + t[1] * (b[1] - a[1]);\n    dst[2] = a[2] + t[2] * (b[2] - a[2]);\n    dst[3] = a[3] + t[3] * (b[3] - a[3]);\n    return dst;\n}\n/**\n * Return max values of two vectors.\n * Given vectors a and b returns\n * [max(a[0], b[0]), max(a[1], b[1]), max(a[2], b[2])].\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The max components vector.\n */\nfunction max(a, b, dst) {\n    dst = dst || new VecType(4);\n    dst[0] = Math.max(a[0], b[0]);\n    dst[1] = Math.max(a[1], b[1]);\n    dst[2] = Math.max(a[2], b[2]);\n    dst[3] = Math.max(a[3], b[3]);\n    return dst;\n}\n/**\n * Return min values of two vectors.\n * Given vectors a and b returns\n * [min(a[0], b[0]), min(a[1], b[1]), min(a[2], b[2])].\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The min components vector.\n */\nfunction min(a, b, dst) {\n    dst = dst || new VecType(4);\n    dst[0] = Math.min(a[0], b[0]);\n    dst[1] = Math.min(a[1], b[1]);\n    dst[2] = Math.min(a[2], b[2]);\n    dst[3] = Math.min(a[3], b[3]);\n    return dst;\n}\n/**\n * Multiplies a vector by a scalar.\n * @param v - The vector.\n * @param k - The scalar.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The scaled vector.\n */\nfunction mulScalar(v, k, dst) {\n    dst = dst || new VecType(4);\n    dst[0] = v[0] * k;\n    dst[1] = v[1] * k;\n    dst[2] = v[2] * k;\n    dst[3] = v[3] * k;\n    return dst;\n}\n/**\n * Multiplies a vector by a scalar. (same as mulScalar)\n * @param v - The vector.\n * @param k - The scalar.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The scaled vector.\n */\nconst scale = mulScalar;\n/**\n * Divides a vector by a scalar.\n * @param v - The vector.\n * @param k - The scalar.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The scaled vector.\n */\nfunction divScalar(v, k, dst) {\n    dst = dst || new VecType(4);\n    dst[0] = v[0] / k;\n    dst[1] = v[1] / k;\n    dst[2] = v[2] / k;\n    dst[3] = v[3] / k;\n    return dst;\n}\n/**\n * Inverse a vector.\n * @param v - The vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The inverted vector.\n */\nfunction inverse(v, dst) {\n    dst = dst || new VecType(4);\n    dst[0] = 1 / v[0];\n    dst[1] = 1 / v[1];\n    dst[2] = 1 / v[2];\n    dst[3] = 1 / v[3];\n    return dst;\n}\n/**\n * Invert a vector. (same as inverse)\n * @param v - The vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The inverted vector.\n */\nconst invert = inverse;\n/**\n * Computes the dot product of two vectors\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @returns dot product\n */\nfunction dot(a, b) {\n    return (a[0] * b[0]) + (a[1] * b[1]) + (a[2] * b[2]) + (a[3] * b[3]);\n}\n/**\n * Computes the length of vector\n * @param v - vector.\n * @returns length of vector.\n */\nfunction length(v) {\n    const v0 = v[0];\n    const v1 = v[1];\n    const v2 = v[2];\n    const v3 = v[3];\n    return Math.sqrt(v0 * v0 + v1 * v1 + v2 * v2 + v3 * v3);\n}\n/**\n * Computes the length of vector (same as length)\n * @param v - vector.\n * @returns length of vector.\n */\nconst len = length;\n/**\n * Computes the square of the length of vector\n * @param v - vector.\n * @returns square of the length of vector.\n */\nfunction lengthSq(v) {\n    const v0 = v[0];\n    const v1 = v[1];\n    const v2 = v[2];\n    const v3 = v[3];\n    return v0 * v0 + v1 * v1 + v2 * v2 + v3 * v3;\n}\n/**\n * Computes the square of the length of vector (same as lengthSq)\n * @param v - vector.\n * @returns square of the length of vector.\n */\nconst lenSq = lengthSq;\n/**\n * Computes the distance between 2 points\n * @param a - vector.\n * @param b - vector.\n * @returns distance between a and b\n */\nfunction distance(a, b) {\n    const dx = a[0] - b[0];\n    const dy = a[1] - b[1];\n    const dz = a[2] - b[2];\n    const dw = a[3] - b[3];\n    return Math.sqrt(dx * dx + dy * dy + dz * dz + dw * dw);\n}\n/**\n * Computes the distance between 2 points (same as distance)\n * @param a - vector.\n * @param b - vector.\n * @returns distance between a and b\n */\nconst dist = distance;\n/**\n * Computes the square of the distance between 2 points\n * @param a - vector.\n * @param b - vector.\n * @returns square of the distance between a and b\n */\nfunction distanceSq(a, b) {\n    const dx = a[0] - b[0];\n    const dy = a[1] - b[1];\n    const dz = a[2] - b[2];\n    const dw = a[3] - b[3];\n    return dx * dx + dy * dy + dz * dz + dw * dw;\n}\n/**\n * Computes the square of the distance between 2 points (same as distanceSq)\n * @param a - vector.\n * @param b - vector.\n * @returns square of the distance between a and b\n */\nconst distSq = distanceSq;\n/**\n * Divides a vector by its Euclidean length and returns the quotient.\n * @param v - The vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The normalized vector.\n */\nfunction normalize(v, dst) {\n    dst = dst || new VecType(4);\n    const v0 = v[0];\n    const v1 = v[1];\n    const v2 = v[2];\n    const v3 = v[3];\n    const len = Math.sqrt(v0 * v0 + v1 * v1 + v2 * v2 + v3 * v3);\n    if (len > 0.00001) {\n        dst[0] = v0 / len;\n        dst[1] = v1 / len;\n        dst[2] = v2 / len;\n        dst[3] = v3 / len;\n    }\n    else {\n        dst[0] = 0;\n        dst[1] = 0;\n        dst[2] = 0;\n        dst[3] = 0;\n    }\n    return dst;\n}\n/**\n * Negates a vector.\n * @param v - The vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns -v.\n */\nfunction negate(v, dst) {\n    dst = dst || new VecType(4);\n    dst[0] = -v[0];\n    dst[1] = -v[1];\n    dst[2] = -v[2];\n    dst[3] = -v[3];\n    return dst;\n}\n/**\n * Copies a vector. (same as clone)\n * @param v - The vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A copy of v.\n */\nfunction copy(v, dst) {\n    dst = dst || new VecType(4);\n    dst[0] = v[0];\n    dst[1] = v[1];\n    dst[2] = v[2];\n    dst[3] = v[3];\n    return dst;\n}\n/**\n * Clones a vector. (same as copy)\n * @param v - The vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A copy of v.\n */\nconst clone = copy;\n/**\n * Multiplies a vector by another vector (component-wise); assumes a and\n * b have the same length.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The vector of products of entries of a and b.\n */\nfunction multiply(a, b, dst) {\n    dst = dst || new VecType(4);\n    dst[0] = a[0] * b[0];\n    dst[1] = a[1] * b[1];\n    dst[2] = a[2] * b[2];\n    dst[3] = a[3] * b[3];\n    return dst;\n}\n/**\n * Multiplies a vector by another vector (component-wise); assumes a and\n * b have the same length. (same as mul)\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The vector of products of entries of a and b.\n */\nconst mul = multiply;\n/**\n * Divides a vector by another vector (component-wise); assumes a and\n * b have the same length.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The vector of quotients of entries of a and b.\n */\nfunction divide(a, b, dst) {\n    dst = dst || new VecType(4);\n    dst[0] = a[0] / b[0];\n    dst[1] = a[1] / b[1];\n    dst[2] = a[2] / b[2];\n    dst[3] = a[3] / b[3];\n    return dst;\n}\n/**\n * Divides a vector by another vector (component-wise); assumes a and\n * b have the same length. (same as divide)\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The vector of quotients of entries of a and b.\n */\nconst div = divide;\n/**\n * Zero's a vector\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The zeroed vector.\n */\nfunction zero(dst) {\n    dst = dst || new VecType(4);\n    dst[0] = 0;\n    dst[1] = 0;\n    dst[2] = 0;\n    dst[3] = 0;\n    return dst;\n}\n/**\n * transform vec4 by 4x4 matrix\n * @param v - the vector\n * @param m - The matrix.\n * @param dst - optional vec4 to store result. If not passed a new one is created.\n * @returns the transformed vector\n */\nfunction transformMat4(v, m, dst) {\n    dst = dst || new VecType(4);\n    const x = v[0];\n    const y = v[1];\n    const z = v[2];\n    const w = v[3];\n    dst[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;\n    dst[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;\n    dst[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;\n    dst[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;\n    return dst;\n}\n\nvar vec4Impl = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    add: add,\n    addScaled: addScaled,\n    ceil: ceil,\n    clamp: clamp,\n    clone: clone,\n    copy: copy,\n    create: create,\n    dist: dist,\n    distSq: distSq,\n    distance: distance,\n    distanceSq: distanceSq,\n    div: div,\n    divScalar: divScalar,\n    divide: divide,\n    dot: dot,\n    equals: equals,\n    equalsApproximately: equalsApproximately,\n    floor: floor,\n    fromValues: fromValues,\n    inverse: inverse,\n    invert: invert,\n    len: len,\n    lenSq: lenSq,\n    length: length,\n    lengthSq: lengthSq,\n    lerp: lerp,\n    lerpV: lerpV,\n    max: max,\n    min: min,\n    mul: mul,\n    mulScalar: mulScalar,\n    multiply: multiply,\n    negate: negate,\n    normalize: normalize,\n    round: round,\n    scale: scale,\n    setDefaultType: setDefaultType$1,\n    sub: sub,\n    subtract: subtract,\n    transformMat4: transformMat4,\n    zero: zero\n});\n\n/**\n * Sets the type this library creates for all types\n *\n * example:\n *\n * ```\n * setDefaultType(Float64Array);\n * ```\n *\n * @param ctor - the constructor for the type. Either `Float32Array`, `Float64Array`, or `Array`\n */\nfunction setDefaultType(ctor) {\n    setDefaultType$5(ctor);\n    setDefaultType$3(ctor);\n    setDefaultType$2(ctor);\n    setDefaultType$6(ctor);\n    setDefaultType$4(ctor);\n    setDefaultType$1(ctor);\n}\n\nexport { mat3Impl as mat3, mat4Impl as mat4, quatImpl as quat, setDefaultType, arrayLike as types, utils, vec2Impl as vec2, vec3Impl as vec3, vec4Impl as vec4 };\n//# sourceMappingURL=wgpu-matrix.module.js.map\n","import { vec3 } from \"wgpu-matrix\";\nexport class Ray {\n    constructor(origin, direction) {\n        this.origin = origin;\n        this.direction = vec3.normalize(direction);\n        this.inv_direction = [1, 1, 1];\n        vec3.div(this.inv_direction, direction, this.inv_direction);\n    }\n}\nexport class RayHit {\n    constructor(position, voxel_position, voxel, normal) {\n        this.position = position;\n        this.voxel_position = voxel_position;\n        this.voxel = voxel;\n        this.normal = normal;\n    }\n}\nexport class Voxel {\n    constructor() {\n        this.color = vec3.create();\n        this.opacity = 0.0;\n        this.roughness = 1.0;\n        this.lightness = 0.0;\n    }\n}\nexport class Scene {\n    constructor() {\n        this.grid_size = 8;\n        this.voxel_count = 16;\n        this.grid = new Array(this.grid_size * this.grid_size * this.grid_size);\n        this.boundary_min = [\n            -this.grid_size / 2,\n            -this.grid_size / 2,\n            -this.grid_size / 2,\n        ];\n        this.boundary_max = [\n            this.grid_size / 2,\n            this.grid_size / 2,\n            this.grid_size / 2,\n        ];\n        this.voxel_size = this.grid_size / this.voxel_count;\n        this.initialize_grid();\n        this.direct_light = vec3.normalize([1.5, 0.6, 3]);\n        this.direct_light_brightness = 1;\n        this.background_color = [0, 0, 0];\n    }\n    initialize_grid() {\n        this.grid = new Array(this.voxel_count ** 3);\n        for (let x = 0; x < this.voxel_count; x++) {\n            for (let y = 0; y < this.voxel_count; y++) {\n                for (let z = 0; z < this.voxel_count; z++) {\n                    let vox = new Voxel();\n                    vox.color = [0, 0, 0];\n                    vox.opacity = 0;\n                    this.grid[z * this.voxel_count * this.voxel_count + y * this.voxel_count + x] = vox;\n                }\n            }\n        }\n    }\n    initialize_default_grid() {\n        for (let x = 0; x < this.voxel_count; x++) {\n            for (let y = 0; y < this.voxel_count; y++) {\n                for (let z = 0; z < this.voxel_count; z++) {\n                    let voxel = new Voxel();\n                    if (z < 3) {\n                        voxel.color = [\n                            x / this.voxel_count,\n                            y / this.voxel_count,\n                            z / this.voxel_count,\n                        ];\n                        vec3.scale(voxel.color, 2, voxel.color);\n                        voxel.opacity = 1;\n                        voxel.lightness = 0;\n                        voxel.roughness = 1;\n                    }\n                    if (vec3.dist([x, y, z], [this.voxel_count / 2, this.voxel_count / 2, this.voxel_count / 2]) < 5) {\n                        voxel.opacity = 1;\n                        voxel.color = [\n                            0.2,\n                            y / this.voxel_count + 0.3,\n                            z / this.voxel_count + 0.3,\n                        ];\n                        vec3.scale(voxel.color, 2, voxel.color);\n                        // voxel.color = [0.8, 0.8, 0.8];\n                        voxel.lightness = 0;\n                        voxel.roughness = 1;\n                    }\n                    if (x == this.voxel_count - 2 || y < 2) {\n                        voxel.color = [\n                            x / this.voxel_count,\n                            y / this.voxel_count,\n                            z / this.voxel_count,\n                        ];\n                        voxel.opacity = 1;\n                        voxel.roughness = 0.3;\n                    }\n                    // if (z < 1) {\n                    // \tvoxel.opacity = 1;\n                    // \t// voxel.color = [0.8, 0.2, 0.3];\n                    // \tvoxel.color = [x / 4, y / 4, 0.9];\n                    // \tvoxel.lightness = 0;\n                    // \tvoxel.roughness = 1;\n                    // }\n                    // if (\n                    // \tvec3.dist(\n                    // \t\t[x + 1, y + 1, z],\n                    // \t\t[this.voxel_count / 2, this.voxel_count / 2, this.voxel_count / 2]\n                    // \t) > 7\n                    // ) {\n                    // \tvoxel.opacity = 1;\n                    // \tvoxel.color = [x / 4, y / 4, z / 4];\n                    // \t// voxel.color = [0.8, 0.8, 0.8];\n                    // \tvoxel.lightness = 0;\n                    // \tvoxel.roughness = 1;\n                    // }\n                    // if (z > 12) {\n                    // \tvoxel.opacity = 1;\n                    // \tvoxel.color = [0.2, y / 4, 0.7];\n                    // \tvoxel.roughness = 0.2;\n                    // \tvoxel.lightness = 0;\n                    // }\n                    // if (z == 2) {\n                    // \tvoxel.color = [0.1, 0.4, 0.9];\n                    // \tvoxel.roughness = 0.7;\n                    // \tvoxel.opacity = 1;\n                    // }\n                    // if (\n                    // \t(x === 5 && y === 5 && z === 5) ||\n                    // \t(x === 5 && y === 10 && z === 5)\n                    // ) {\n                    // \tvoxel.color = [0.8, 0.5, 0.4];\n                    // \tvoxel.opacity = 0.5;\n                    // \tvoxel.roughness = 1;\n                    // \tvoxel.lightness = 0;\n                    // }\n                    //voxel.color = [0.8, 0.8, 0.8];\n                    voxel.color[0] = Math.min(1, voxel.color[0]);\n                    voxel.color[1] = Math.min(1, voxel.color[1]);\n                    voxel.color[2] = Math.min(1, voxel.color[2]);\n                    //voxel.roughness = 1;\n                    this.set_voxel_comp(voxel, x, y, z);\n                }\n            }\n        }\n    }\n    ray_any(ray) {\n        let tmin = 0.0;\n        let tmax = Infinity;\n        for (let d = 0; d < 3; d++) {\n            let t1 = (this.boundary_min[d] - ray.origin[d]) * ray.inv_direction[d];\n            let t2 = (this.boundary_max[d] - ray.origin[d]) * ray.inv_direction[d];\n            tmin = Math.min(Math.max(t1, tmin), Math.max(t2, tmin));\n            tmax = Math.max(Math.min(t1, tmax), Math.min(t2, tmax));\n        }\n        if (tmin > tmax) {\n            return undefined;\n        }\n        const ray_entry = vec3.add(ray.origin, vec3.scale(ray.direction, tmin));\n        const ray_exit = vec3.add(ray.origin, vec3.scale(ray.direction, tmax));\n        let voxel = [\n            Math.max(0, Math.min(this.voxel_count - 1, Math.floor((ray_entry[0] - this.boundary_min[0]) / this.voxel_size))),\n            Math.max(0, Math.min(this.voxel_count - 1, Math.floor((ray_entry[1] - this.boundary_min[1]) / this.voxel_size))),\n            Math.max(0, Math.min(this.voxel_count - 1, Math.floor((ray_entry[2] - this.boundary_min[2]) / this.voxel_size))),\n        ];\n        let voxel_upper_edge = [voxel[0] + 1, voxel[1] + 1, voxel[2] + 1];\n        // console.log(``);\n        // console.log(`entry: ${ray_entry}, (${voxel}, ${this.get_voxel_id(voxel)})`);\n        // console.log(`hit: ${this.get_voxel(voxel)}`);\n        // console.log(`tmin: ${tmin}`);\n        // console.log(`tmin: ${tmax}`);\n        let step = [0, 0, 0];\n        let tmax_comp = [0, 0, 0];\n        let tdelta = [0, 0, 0];\n        let end_voxel = [0, 0, 0];\n        let thit = tmin;\n        let hit_normal = [0, 0, 0];\n        for (let d = 0; d < 3; d++) {\n            end_voxel[d] = Math.max(0, Math.min(this.voxel_count - 1, Math.floor((ray_exit[d] - this.boundary_min[d]) / this.voxel_size)));\n            if (ray.direction[d] > 0.0) {\n                step[d] = 1;\n                tdelta[d] = this.voxel_size / ray.direction[d];\n                tmax_comp[d] =\n                    tmin +\n                        (this.boundary_min[d] +\n                            voxel_upper_edge[d] * this.voxel_size -\n                            ray_entry[d]) /\n                            ray.direction[d];\n            }\n            else if (ray.direction[d] < 0.0) {\n                step[d] = -1;\n                tdelta[d] = this.voxel_size / -ray.direction[d];\n                tmax_comp[d] =\n                    tmin +\n                        (this.boundary_min[d] + voxel[d] * this.voxel_size - ray_entry[d]) /\n                            ray.direction[d];\n            }\n            else {\n                step[d] = 0;\n                tdelta[d] = tmax;\n                tmax_comp[d] = tmax;\n            }\n        }\n        // while (\n        // \tvoxel[0] != end_voxel[0] ||\n        // \tvoxel[1] != end_voxel[1] ||\n        // \tvoxel[2] != end_voxel[2]) {\n        while (voxel[0] < this.voxel_count &&\n            voxel[0] >= 0 &&\n            voxel[1] < this.voxel_count &&\n            voxel[1] >= 0 &&\n            voxel[2] < this.voxel_count &&\n            voxel[2] >= 0) {\n            // console.log(\"\");\n            // console.log(voxel);\n            // console.log(tmax_comp);\n            // console.log(tdelta);\n            if (this.get_voxel(voxel).opacity > 0.01) {\n                const hit_position = vec3.add(ray.origin, vec3.scale(ray.direction, thit));\n                return new RayHit(hit_position, voxel, this.get_voxel(voxel), hit_normal);\n            }\n            if (tmax_comp[0] < tmax_comp[1] && tmax_comp[0] < tmax_comp[2]) {\n                voxel[0] += step[0];\n                thit = tmax_comp[0];\n                tmax_comp[0] += tdelta[0];\n                hit_normal = [-step[0], 0, 0];\n            }\n            else if (tmax_comp[1] < tmax_comp[2]) {\n                voxel[1] += step[1];\n                thit = tmax_comp[1];\n                tmax_comp[1] += tdelta[1];\n                hit_normal = [0, -step[1], 0];\n            }\n            else {\n                voxel[2] += step[2];\n                thit = tmax_comp[2];\n                tmax_comp[2] += tdelta[2];\n                hit_normal = [0, 0, -step[2]];\n            }\n        }\n        return undefined;\n    }\n    get_voxel_id_comp(x, y, z) {\n        return z * this.voxel_count * this.voxel_count + y * this.voxel_count + x;\n    }\n    get_voxel_id(voxel) {\n        return (voxel[2] * this.voxel_count * this.voxel_count +\n            voxel[1] * this.voxel_count +\n            voxel[0]);\n    }\n    get_voxel_comp(x, y, z) {\n        return this.grid[z * this.voxel_count * this.voxel_count + y * this.voxel_count + x];\n    }\n    get_voxel(voxel) {\n        return this.grid[voxel[2] * this.voxel_count * this.voxel_count +\n            voxel[1] * this.voxel_count +\n            voxel[0]];\n    }\n    set_voxel(value, voxel) {\n        if (voxel[0] > 0 &&\n            voxel[0] < this.voxel_count - 1 &&\n            voxel[1] > 0 &&\n            voxel[1] < this.voxel_count - 1 &&\n            voxel[2] > 0 &&\n            voxel[2] < this.voxel_count - 1)\n            this.grid[voxel[2] * this.voxel_count * this.voxel_count +\n                voxel[1] * this.voxel_count +\n                voxel[0]] = value;\n    }\n    set_voxel_comp(value, x, y, z) {\n        if (x > 0 &&\n            x < this.voxel_count - 1 &&\n            y > 0 &&\n            y < this.voxel_count - 1 &&\n            z > 0 &&\n            z < this.voxel_count - 1)\n            this.grid[z * this.voxel_count * this.voxel_count + y * this.voxel_count + x] = value;\n    }\n}\n","export function Deg2Rad(theta) {\n    return theta * Math.PI / 180;\n}\n","import { vec2, vec3 } from \"wgpu-matrix\";\nimport { Deg2Rad } from \"./math_util\";\nimport { Ray } from \"./scene\";\nexport class OrbitCamera {\n    constructor(distance, theta, phi) {\n        this.dragged = false;\n        this.velocity = [0, 0];\n        this.distance = 8;\n        this.forward = vec3.create();\n        this.right = vec3.create();\n        this.up = vec3.create();\n        this.position = vec3.create();\n        this.eulers = [0, phi, theta];\n        this.distance = distance;\n    }\n    update() {\n        this.eulers[1] = Math.min(80, Math.max(-80, this.eulers[1]));\n        this.eulers[2] = this.eulers[2] % 360;\n        this.forward = [\n            Math.cos(Deg2Rad(this.eulers[2])) * Math.cos(Deg2Rad(this.eulers[1])),\n            Math.sin(Deg2Rad(this.eulers[2])) * Math.cos(Deg2Rad(this.eulers[1])),\n            Math.sin(Deg2Rad(this.eulers[1])),\n        ];\n        vec3.normalize(vec3.cross(this.forward, [0, 0, 1], this.right), this.right);\n        vec3.normalize(vec3.cross(this.right, this.forward, this.up), this.up);\n        vec3.scale(this.forward, -this.distance, this.position);\n    }\n    tick(delta_time) {\n        if (!this.dragged) {\n            this.eulers[1] -= this.velocity[1];\n            this.eulers[2] -= this.velocity[0];\n        }\n        vec2.scale(this.velocity, 0.96 * (1 - delta_time), this.velocity);\n        this.update();\n    }\n    screen_to_ray(x, y, sx, sy) {\n        const horizontal_coefficient = (x - sx / 2) / sx;\n        const vertical_coefficient = (y - sy / 2) / -sy;\n        let ray_direction = vec3.create();\n        vec3.add(ray_direction, this.forward, ray_direction);\n        vec3.add(ray_direction, vec3.scale(this.right, horizontal_coefficient), ray_direction);\n        vec3.add(ray_direction, vec3.scale(this.up, vertical_coefficient), ray_direction);\n        return new Ray(this.position, ray_direction);\n    }\n}\n","import { Renderer } from \"./renderer\";\nimport { Scene } from \"./scene\";\nimport { Controller } from \"./controller\";\nimport { switch_latte, switch_mocha } from \"./theme_switch\";\nimport { SliceRenderer } from \"./slice_renderer\";\nconst canvas = document.getElementById(\"canv\");\nconst fps = document.getElementById(\"fps\");\nconst img = document.getElementById(\"kloppenheim_02\");\nconst slice_canvas = document.getElementById(\"slice-canvas\");\n//let camera = new FPCamera([-8.0, 0.0, 0.0], 0.0, 50.0);\nconst scene = new Scene();\nlet controller = new Controller(scene, canvas, 12, 0.0, 0.0);\nlet renderer = new Renderer(canvas, scene, controller.camera);\nscene.initialize_default_grid();\nrenderer.initialize(false);\nlet slice_renderer = new SliceRenderer(slice_canvas, scene);\nslice_renderer.slice = 6;\nslice_renderer.background = [30 / 255, 30 / 255, 46 / 255];\nslice_renderer.update();\nlet last_time = performance.now();\nlet camera_active = false;\n// const btn_renderer = <HTMLInputElement>document.getElementById(\"renderer\");\n// btn_renderer.addEventListener(\"change\", (e) => {\n//   renderer.shutdown();\n//   renderer.initialize((<HTMLInputElement>e.target).checked);\n// });\n//\naddEventListener(\"scroll\", () => {\n    document.documentElement.dataset.scroll = window.scrollY.toString();\n});\nrequestAnimationFrame(function tick() {\n    renderer.render();\n    const elapsed = performance.now() - last_time;\n    controller.tick(elapsed / 1000);\n    last_time = performance.now();\n    fps.innerText = Math.round((1 / elapsed) * 1000).toString() + \" fps\";\n    requestAnimationFrame(tick);\n});\naddEventListener(\"mousedown\", (e) => {\n    if (e.button == 2)\n        camera_active = true;\n});\nlet theme = \"mocha\";\nconst btn_switch_theme = document.getElementById(\"menu_switch_theme\");\nbtn_switch_theme === null || btn_switch_theme === void 0 ? void 0 : btn_switch_theme.addEventListener(\"click\", (e) => {\n    if (theme === \"mocha\") {\n        theme = \"latte\";\n        switch_latte();\n        scene.background_color = [204 / 255, 208 / 255, 218 / 255];\n        slice_renderer.set_background([204 / 255, 208 / 255, 218 / 255]);\n    }\n    else {\n        theme = \"mocha\";\n        switch_mocha();\n        scene.background_color = [30 / 255, 30 / 255, 46 / 255];\n        slice_renderer.set_background([30 / 255, 30 / 255, 46 / 255]);\n    }\n});\nscene.background_color = [30 / 255, 30 / 255, 46 / 255];\nconst btn_rescale_canvas = document.getElementById(\"menu_rescale_canvas\");\nbtn_rescale_canvas === null || btn_rescale_canvas === void 0 ? void 0 : btn_rescale_canvas.addEventListener(\"click\", (e) => {\n    const root = document.querySelector(\":root\");\n    const scaled = Math.min(window.innerWidth, window.innerHeight) * 0.8;\n    canvas.height = scaled;\n    canvas.width = scaled;\n    renderer.shutdown();\n    renderer.initialize(renderer.pathtracing);\n});\n//switch_latte();\n// addEventListener(\"mouseup\", (e) => {\n// \tif (e.button == 2) camera_active = false;\n// \tif (e.button == 0) {\n// \t\tconst rect = canvas.getBoundingClientRect();\n// \t\tconst x = e.clientX - rect.left;\n// \t\tconst y = e.clientY - rect.top;\n// \t\tconst hit = scene.ray_any(camera.screen_to_ray(x, y, canvas.width, canvas.height));\n// \t\tif (hit) {\n// \t\t\tlet voxel = new Voxel();\n// \t\t\tvoxel.opacity = 0;\n// \t\t\tscene.set_voxel(voxel, hit.voxel_position);\n// \t\t}\n// \t}\n// });\naddEventListener(\"contextmenu\", (e) => {\n    e.preventDefault();\n    // const rect = canvas.getBoundingClientRect();\n    // const x = e.clientX - rect.left;\n    // const y = e.clientY - rect.top;\n    // renderer.shoot_ray(x, y);\n    return false;\n});\n","import { vec2, vec3 } from \"wgpu-matrix\";\nimport { OrbitCamera } from \"./orbit_camera\";\nimport { Voxel } from \"./scene\";\nexport class Controller {\n    constructor(scene, canvas, distance, theta, phi) {\n        this.mouse_down = false;\n        this.mouse_dragged = false;\n        this.last_move = 0;\n        this.velocity = [0, 0];\n        this.selected_color = [0, 0, 0];\n        this.selected_roughness = 1;\n        this.selected_opacity = 1;\n        this.selected_lightness = 0;\n        this.camera = new OrbitCamera(distance, theta, phi);\n        this.setup();\n        this.last_move = performance.now();\n        this.last_movement = [0, 0];\n        this.scene = scene;\n        this.canvas = canvas;\n        this.selected_tool = \"place\";\n    }\n    tick(delta_time) {\n        this.camera.tick(delta_time);\n    }\n    setup() {\n        var _a, _b, _c, _d, _e, _f, _g;\n        addEventListener(\"mousedown\", (e) => {\n            if (e.button == 0) {\n                this.mouse_down = true;\n                this.mouse_dragged = false;\n                this.camera.dragged = true;\n                this.last_move = performance.now();\n            }\n        });\n        addEventListener(\"mouseup\", (e) => {\n            if (e.button == 0) {\n                this.mouse_down = false;\n                this.camera.dragged = false;\n                this.camera.velocity = [...this.velocity];\n                if (!this.mouse_dragged) {\n                    const rect = this.canvas.getBoundingClientRect();\n                    const x = e.clientX - rect.left;\n                    const y = e.clientY - rect.top;\n                    let voxel = this.scene.ray_any(this.camera.screen_to_ray(x, y, rect.width, rect.height));\n                    if (voxel) {\n                        switch (this.selected_tool) {\n                            case \"place\":\n                                let n_voxel = new Voxel();\n                                n_voxel.color = this.selected_color;\n                                n_voxel.roughness = this.selected_roughness;\n                                n_voxel.lightness = this.selected_lightness;\n                                n_voxel.opacity = this.selected_opacity;\n                                this.scene.set_voxel(n_voxel, voxel.voxel_position.map((val, i) => val + voxel.normal[i]));\n                                break;\n                            case \"replace\":\n                                let r_voxel = new Voxel();\n                                r_voxel.color = this.selected_color;\n                                r_voxel.roughness = this.selected_roughness;\n                                r_voxel.lightness = this.selected_lightness;\n                                r_voxel.opacity = this.selected_opacity;\n                                this.scene.set_voxel(r_voxel, voxel.voxel_position);\n                                break;\n                            case \"remove\":\n                                let d_voxel = new Voxel();\n                                d_voxel.opacity = 0;\n                                this.scene.set_voxel(d_voxel, voxel.voxel_position);\n                                break;\n                        }\n                    }\n                }\n            }\n        });\n        addEventListener(\"mousemove\", (e) => {\n            this.last_movement = vec2.scale([e.movementX, e.movementY], 0.2);\n            if (this.mouse_down)\n                this.mouse_drag(e);\n            this.calculate_velocity();\n            this.last_move = performance.now();\n        });\n        (_a = document.getElementById(\"color_value\")) === null || _a === void 0 ? void 0 : _a.addEventListener(\"input\", (e) => {\n            var _a;\n            const col = e.target.value;\n            this.selected_color = vec3.scale((_a = col.match(/\\w\\w/g)) === null || _a === void 0 ? void 0 : _a.map(x => parseInt(x, 16)), 1 / 255);\n        });\n        (_b = document.getElementById(\"roughness_value\")) === null || _b === void 0 ? void 0 : _b.addEventListener(\"input\", (e) => {\n            this.selected_roughness = 1 - parseInt(e.target.value) / 100;\n        });\n        (_c = document.getElementById(\"lightness_value\")) === null || _c === void 0 ? void 0 : _c.addEventListener(\"input\", (e) => {\n            this.selected_lightness = parseInt(e.target.value) / 100;\n        });\n        (_d = document.getElementById(\"opacity_value\")) === null || _d === void 0 ? void 0 : _d.addEventListener(\"input\", (e) => {\n            this.selected_opacity = parseInt(e.target.value) / 100;\n        });\n        (_e = document.getElementById(\"tool-place-button\")) === null || _e === void 0 ? void 0 : _e.addEventListener(\"change\", (e) => {\n            this.selected_tool = \"place\";\n        });\n        (_f = document.getElementById(\"tool-replace-button\")) === null || _f === void 0 ? void 0 : _f.addEventListener(\"change\", (e) => {\n            this.selected_tool = \"replace\";\n        });\n        (_g = document.getElementById(\"tool-remove-button\")) === null || _g === void 0 ? void 0 : _g.addEventListener(\"change\", (e) => {\n            this.selected_tool = \"remove\";\n        });\n    }\n    calculate_velocity() {\n        const t = performance.now() - this.last_move;\n        vec2.scale(this.last_movement, 1 / t, this.velocity);\n    }\n    mouse_drag(e) {\n        this.camera.eulers[1] = this.camera.eulers[1] - this.last_movement[1];\n        this.camera.eulers[2] = this.camera.eulers[2] - this.last_movement[0];\n        // this.camera.velocity = [e.movementY, e.movementX];\n        this.mouse_dragged = true;\n    }\n}\n","export default \"const light_scatter_samples: i32 = 2;\\r\\n\\r\\nfn gamma_correct(color: vec3<f32>) -> vec3<f32> {\\r\\n    let correction = 1.0 / f32(samples);\\r\\n    return sqrt(correction * color);\\r\\n}\\r\\n\\r\\nfn trace(ray: Ray, depth: i32) -> vec3<f32> {\\r\\n\\tif (depth <= 0) {\\r\\n\\t\\treturn vec3<f32>(0);\\r\\n\\t}\\r\\n\\t\\tvar accum: vec3<f32> = vec3<f32>(0.0);\\r\\n\\t\\tvar mask: vec3<f32> = vec3<f32>(1.0);\\r\\n\\t\\tvar curr_ray: Ray = ray;\\r\\n\\t\\tvar curr_hit: RayHit;\\r\\n\\t\\tvar refl: f32 = 1.0;\\r\\n\\t\\tvar hits: i32 = 0;\\r\\n\\r\\n\\t\\tvar bounce_results: array<RayHit, light_bounces>;\\r\\n\\r\\n\\t\\tfor (; hits < light_bounces;){\\r\\n\\t\\t\\tif (voxel_ray_any(curr_ray, 0.0001, &curr_hit)) {\\r\\n\\t\\t\\t\\tlet bounce_direction = random_unit_vector() + curr_hit.normal;\\r\\n\\t\\t\\t\\tif (all(bounce_direction == vec3<f32>(0))){\\r\\n\\t\\t\\t\\t\\tcurr_ray = Ray(curr_hit.position, curr_hit.normal, 1 / curr_hit.normal);\\r\\n\\t\\t\\t\\t} else {\\r\\n\\t\\t\\t\\t\\tlet normalized = normalize(bounce_direction);\\r\\n\\t\\t\\t\\t\\tcurr_ray = Ray(curr_hit.position, normalized, 1 / normalized);\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\tbounce_results[hits] = curr_hit;\\r\\n\\t\\t\\t\\thits++;\\r\\n\\t\\t\\t} else {\\r\\n\\t\\t\\t\\t// accum = pow(textureSampleLevel(hdr_tex, hdr_sampler, sample_spherical_map(curr_ray.direction), 0.0).rgb, vec3<f32>(2)) * 5;\\r\\n\\t\\t\\t\\taccum = vec3<f32>(pow(max(0, dot(curr_ray.direction, scene.direct_light) - 0.98) * 40, 1));\\r\\n\\t\\t\\t\\tbreak;\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif (hits == 0){\\r\\n\\t\\t\\t// return textureSampleLevel(hdr_tex, hdr_sampler, sample_spherical_map(ray.direction), 0.0).rgb;\\r\\n\\t\\t\\treturn vec3<f32>(pow(max(0, dot(ray.direction, scene.direct_light) - 0.95) * 20, 1));\\r\\n\\t\\t}\\r\\n\\t\\tif (hits == light_bounces){\\r\\n\\t\\t\\taccum = vec3<f32>(0, 0, 0);\\r\\n\\t\\t} else {\\r\\n\\t\\t\\t// accum = textureSampleLevel(hdr_tex, hdr_sampler, sample_spherical_map(bounce_results[hits - 1].ray_direction), 0.0).rgb;\\r\\n\\t\\t\\t/* accum = vec3<f32>(max(0, dot(bounce_results[hits - 1].ray_direction, scene.direct_light))); */\\r\\n\\t\\t\\t// accum = vec3<f32>(0);\\r\\n\\t\\t}\\r\\n\\t\\tfor (var i: i32 = hits - 1; i >= 0; i--){\\r\\n\\t\\t\\tlet bounce = bounce_results[i];\\r\\n\\t\\t\\t/* accum = min(vec3<f32>(1), accum) * min(vec3<f32>(1), bounce.voxel.color); */\\r\\n\\t\\t\\taccum = accum * bounce.voxel.color\\r\\n\\t\\t\\t\\t+ bounce_results[i].voxel.lightness * bounce_results[i].voxel.color;\\r\\n\\t\\t\\t// if (all(bounce.normal == vec3<f32>(0)) && all(bounce.ray_direction == vec3<f32>(0))){\\r\\n\\t\\t\\t// \\t// accum = textureSampleLevel(hdr_tex, hdr_sampler, sample_spherical_map(bounce_results[i].ray_direction), 0.0).rgb;\\r\\n\\t\\t\\t// \\taccum = vec3<f32>(0.5);\\r\\n\\t\\t\\t// \\tcontinue;\\r\\n\\t\\t\\t// }\\r\\n\\t\\t\\t// accum = accum * bounce.voxel.color;\\r\\n\\t\\t\\t// accum = accum * bounce.voxel.color;\\r\\n\\t\\t}\\r\\n\\treturn accum; // / f32(light_scatter_samples);\\r\\n}\\r\\n\\r\\nfn direct_illumination(orig_hit: RayHit, refl: ptr<function, f32>) -> vec3<f32> {\\r\\n\\tvar hit: RayHit;\\r\\n\\tif (!voxel_ray_any(Ray(orig_hit.position, scene.direct_light, 1 / scene.direct_light), 0.00001, &hit)){\\r\\n\\t\\treturn scene.direct_light_brightness * orig_hit.voxel.color;\\r\\n\\t} else {\\r\\n\\t\\treturn 0.2 * orig_hit.voxel.color;\\r\\n\\t}\\r\\n}\\r\\n\\r\\nfn voxel_ray_any(ray: Ray, start_tolerance: f32, hit: ptr<function, RayHit>) -> bool {\\r\\n\\tvar tmin: f32 = 0.0;\\r\\n\\tvar tmax: f32 = 300000000;\\r\\n\\tfor (var d: i32 = 0; d < 3; d++) {\\r\\n\\t\\tlet t1 = (boundary_min[d] - ray.origin[d]) * ray.inv_direction[d];\\r\\n\\t\\tlet t2 = (boundary_max[d] - ray.origin[d]) * ray.inv_direction[d];\\r\\n\\r\\n\\t\\ttmin = min(max(t1, tmin), max(t2, tmin));\\r\\n\\t\\ttmax = max(min(t1, tmax), min(t2, tmax));\\r\\n\\t}\\r\\n\\t// Hier ist noch ein Fehler drin, tritt nur von ausserhalb des grid auf, das kommt ja vielleicht eh noch weg\\r\\n\\tif tmin > tmax { return false; }\\r\\n    \\tlet ray_entry = ray.origin + ray.direction * tmin;\\r\\n\\tlet ray_exit = ray.origin + ray.direction * tmax;\\r\\n\\r\\n\\tvar voxel: vec3<i32> = max(vec3<i32>(0), min(vec3<i32>(voxel_count - 1), vec3<i32>((ray_entry - boundary_min) / f32(voxel_size))));\\r\\n\\t//var end_voxel: vec3<i32> = max(vec3<i32>(0), min(vec3<i32>(voxel_count - 1), vec3<i32>((ray_exit - boundary_min - ray.direction * 0.000001) / f32(voxel_size))));\\r\\n\\r\\n\\tlet direction_zeros: vec3<bool> = ray.direction == vec3<f32>(0);\\r\\n\\tlet step: vec3<i32> = vec3<i32>(sign(ray.direction));\\r\\n\\tlet tdelta: vec3<f32> = select(voxel_size / abs(ray.direction), vec3<f32>(tmax), direction_zeros);\\r\\n\\tlet voxel_boundary: vec3<f32> = vec3<f32>(voxel + max(vec3<i32>(0), step)) * voxel_size;\\r\\n\\tvar tmax_comp: vec3<f32> = select(tmin + (boundary_min + voxel_boundary - ray_entry) / ray.direction, vec3<f32>(tmax), direction_zeros);\\r\\n\\tvar thit: f32 = tmin;\\r\\n\\tvar hit_normal: vec3<f32> = vec3<f32>(0, 0, 0);\\r\\n\\r\\n\\twhile(all(voxel >= vec3<i32>(0)) && all(voxel < vec3<i32>(voxel_count))) {\\r\\n\\t\\tlet hit_voxel = get_voxel(voxel);\\r\\n\\t\\tif (hit_voxel.opacity > 0.01 && all(tmax_comp > vec3<f32>(start_tolerance))){\\r\\n\\t\\t\\t(*hit).position = ray.origin + ray.direction * thit;\\r\\n\\t\\t\\t(*hit).voxel = hit_voxel;\\r\\n\\t\\t\\t(*hit).voxel_position = voxel;\\r\\n\\t\\t\\t(*hit).depth = 1 - (thit - depth_clip_min) / (depth_clip_max - depth_clip_min);\\r\\n\\t\\t\\t(*hit).normal = hit_normal;\\r\\n\\t\\t\\t(*hit).ray_direction = ray.direction;\\r\\n\\t\\t\\treturn true;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif (tmax_comp.x < tmax_comp.y && tmax_comp.x < tmax_comp.z) {\\r\\n\\t\\t\\tvoxel.x += step.x;\\r\\n\\t\\t\\tthit = tmax_comp.x;\\r\\n\\t\\t\\ttmax_comp.x += tdelta.x;\\r\\n\\t\\t\\thit_normal = vec3<f32>(f32(-step.x), 0, 0);\\r\\n\\t\\t} else if (tmax_comp.y < tmax_comp.z){\\r\\n\\t\\t\\tvoxel.y += step.y;\\r\\n\\t\\t\\tthit = tmax_comp.y;\\r\\n\\t\\t\\ttmax_comp.y += tdelta.y;\\r\\n\\t\\t\\thit_normal = vec3<f32>(0, f32(-step.y), 0);\\r\\n\\t\\t} else {\\r\\n\\t\\t\\tvoxel.z += step.z;\\r\\n\\t\\t\\tthit = tmax_comp.z;\\r\\n\\t\\t\\ttmax_comp.z += tdelta.z;\\r\\n\\t\\t\\thit_normal = vec3<f32>(0, 0, f32(-step.z));\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\treturn false;\\r\\n}\\r\\n\"","export default \"const ao_samples: i32 = 20;\\r\\nconst ao_range: f32 = 0.2;\\r\\n\\r\\nstruct penetration {\\r\\n\\tcolor: vec3<f32>,\\r\\n\\tao: f32,\\r\\n\\topacity: f32,\\r\\n}\\r\\n\\r\\nfn gamma_correct(color: vec3<f32>) -> vec3<f32> {\\r\\n    return color / f32(samples);\\r\\n}\\r\\n\\r\\nfn trace(ray: Ray, depth: i32) -> TraceResult {\\r\\n\\tvar hit: RayHit;\\r\\n\\tvar bounces: array<RayHit, reflection_bounces>;\\r\\n\\tvar curr_ray = ray;\\r\\n\\tvar hits: i32 = 0;\\r\\n\\tvar has_next_ray = true;\\r\\n\\tvar penetrations: array<penetration, max_penetrations>;\\r\\n\\tvar penetration_count = 0;\\r\\n\\r\\n\\tfor (var p = 0; p < max_penetrations; p++){\\r\\n\\t\\tvar color = vec3<f32>(0.0);\\r\\n\\t\\tvar ao = 0f;\\r\\n\\t\\tvar first_hit: RayHit;\\r\\n\\t\\tfor (var i = 0; i < reflection_bounces; i++){\\r\\n\\t\\t\\tif(voxel_ray_any(curr_ray, 0.001, &hit)){\\r\\n\\t\\t\\t\\tbounces[i] = hit;\\r\\n\\t\\t\\t\\tcurr_ray = ray_reflect(curr_ray, hit.position, hit.normal);\\r\\n\\t\\t\\t\\thits++;\\r\\n\\t\\t\\t\\tif (i == 0){\\r\\n\\t\\t\\t\\t\\tfirst_hit = hit;\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\tif (hit.voxel.roughness > 0.99){\\r\\n\\t\\t\\t\\t\\tbreak;\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t} else {\\r\\n\\t\\t\\t\\tcolor = scene.background_color;\\r\\n\\t\\t\\t\\tbreak;\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t\\tif (hits == 0){\\r\\n\\t\\t\\tbreak;\\r\\n\\t\\t\\t// return background;\\r\\n\\t\\t\\t// return ray.direction;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tfor (var i: i32 = hits; i >= 0; i--){\\r\\n\\t\\t\\tlet t = bounces[i].voxel.roughness;\\r\\n\\t\\t\\tcolor = color * (1 - t) + t * bounces[i].voxel.color * illumination(bounces[i].position);\\r\\n\\t\\t\\tif (i == 0){\\r\\n\\t\\t\\t\\t//ao = get_point_ao(bounces[0].position);\\r\\n\\t\\t\\t\\tao = get_point_ao_lambert(bounces[0].position, bounces[0].normal);\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\t\\r\\n\\t\\t\\tfor (var l: i32 = 0; l < i32(scene.light_count); l++){\\r\\n\\t\\t\\t\\tlet light = lights.data[l];\\r\\n\\t\\t\\t\\tif i32(light.emitter_type) == 0 {\\r\\n\\t\\t\\t\\t\\tlet light_voxel = get_voxel(vec3<i32>(light.location));\\r\\n\\t\\t\\t\\t\\tlet light_voxel_location = light.location * voxel_size + boundary_min;\\r\\n\\t\\t\\t\\t\\tlet light_voxel_location_top = light_voxel_location + voxel_size;\\r\\n\\t\\t\\t\\t\\tlet light_voxel_location_mid = (light_voxel_location + light_voxel_location_top) / 2;\\r\\n\\t\\t\\t\\t\\tlet lray_dir = light_voxel_location_mid - bounces[i].position;\\r\\n\\t\\t\\t\\t\\tlet lray = Ray(bounces[i].position, lray_dir, 1 / lray_dir);\\r\\n\\t\\t\\t\\t\\tvar lhit: RayHit;\\r\\n\\t\\t\\t\\t\\tif (voxel_ray_any(lray, 0.001, &lhit) && all(lhit.voxel_position == vec3<i32>(light.location))){\\r\\n\\t\\t\\t\\t\\t\\tlet dist = distance(light_voxel_location_mid, bounces[i].position);\\r\\n\\t\\t\\t\\t\\t\\tlet intensity = 1 / pow(dist, 2) * lhit.voxel.lightness;\\r\\n\\t\\t\\t\\t\\t\\tcolor += light_voxel.color * vec3<f32>(intensity) * bounces[i].voxel.color;\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t\\tpenetrations[p] = penetration(color, ao, first_hit.voxel.opacity);\\r\\n\\t\\tpenetration_count++;\\r\\n\\t\\tcurr_ray = Ray(first_hit.exit_position, ray.direction, ray.inv_direction);\\r\\n\\t\\tif (first_hit.voxel.opacity > 0.99){\\r\\n\\t\\t\\tbreak;\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\tif (penetration_count == 0){\\r\\n\\t\\treturn TraceResult(scene.background_color, 0);\\r\\n\\t}\\r\\n\\r\\n\\tvar color = penetrations[penetration_count].color;\\r\\n\\tvar ao = penetrations[penetration_count].ao;\\r\\n\\tfor (var i: i32 = penetration_count - 1; i >= 0; i--){\\r\\n\\t\\tcolor = penetrations[i].color * penetrations[i].opacity + color * (1 - penetrations[i].opacity);\\r\\n\\t\\tao = penetrations[i].ao * penetrations[i].opacity + ao * (1 - penetrations[i].opacity);\\r\\n\\t}\\r\\n\\r\\n\\treturn TraceResult(color, ao);\\r\\n\\t// return color;\\r\\n}\\r\\n\\r\\nfn illumination(p: vec3<f32>) -> f32 {\\r\\n\\tvar hit: RayHit;\\r\\n\\tif (!voxel_ray_any(Ray(p, scene.direct_light, 1 / scene.direct_light), 0.001, &hit)){\\r\\n\\t\\treturn scene.direct_light_brightness;\\r\\n\\t}\\r\\n\\treturn 0.2;\\r\\n}\\r\\n\\r\\nfn voxel_ray_any(ray: Ray, start_tolerance: f32, hit: ptr<function, RayHit>) -> bool {\\r\\n\\tvar tmin: f32 = 0.0;\\r\\n\\tvar tmax: f32 = 300000000;\\r\\n\\tfor (var d: i32 = 0; d < 3; d++) {\\r\\n\\t\\tlet t1 = (boundary_min[d] - ray.origin[d]) * ray.inv_direction[d];\\r\\n\\t\\tlet t2 = (boundary_max[d] - ray.origin[d]) * ray.inv_direction[d];\\r\\n\\r\\n\\t\\ttmin = min(max(t1, tmin), max(t2, tmin));\\r\\n\\t\\ttmax = max(min(t1, tmax), min(t2, tmax));\\r\\n\\t}\\r\\n\\t// Hier ist noch ein Fehler drin, tritt nur von ausserhalb des grid auf, das kommt ja vielleicht eh noch weg\\r\\n\\tif tmin > tmax { return false; }\\r\\n    \\tlet ray_entry = ray.origin + ray.direction * tmin;\\r\\n\\tlet ray_exit = ray.origin + ray.direction * tmax;\\r\\n\\r\\n\\tvar voxel: vec3<i32> = max(vec3<i32>(0), min(vec3<i32>(voxel_count - 1), vec3<i32>((ray_entry - boundary_min) / f32(voxel_size))));\\r\\n\\t//var end_voxel: vec3<i32> = max(vec3<i32>(0), min(vec3<i32>(voxel_count - 1), vec3<i32>((ray_exit - boundary_min - ray.direction * 0.000001) / f32(voxel_size))));\\r\\n\\r\\n\\tlet direction_zeros: vec3<bool> = ray.direction == vec3<f32>(0);\\r\\n\\tlet step: vec3<i32> = vec3<i32>(sign(ray.direction));\\r\\n\\tlet tdelta: vec3<f32> = select(voxel_size / abs(ray.direction), vec3<f32>(tmax), direction_zeros);\\r\\n\\tlet voxel_boundary: vec3<f32> = vec3<f32>(voxel + max(vec3<i32>(0), step)) * voxel_size;\\r\\n\\tvar tmax_comp: vec3<f32> = select(tmin + (boundary_min + voxel_boundary - ray_entry) / ray.direction, vec3<f32>(tmax), direction_zeros);\\r\\n\\tvar thit: f32 = tmin;\\r\\n\\tvar hit_normal: vec3<f32> = vec3<f32>(0, 0, 0);\\r\\n\\r\\n\\twhile(all(voxel >= vec3<i32>(0)) && all(voxel < vec3<i32>(voxel_count))) {\\r\\n\\t\\tlet hit_voxel = get_voxel(voxel);\\r\\n\\t\\tif (hit_voxel.opacity > 0.01 && all(tmax_comp > vec3<f32>(start_tolerance))){\\r\\n\\t\\t\\t(*hit).position = ray.origin + ray.direction * thit;\\r\\n\\t\\t\\t(*hit).voxel = hit_voxel;\\r\\n\\t\\t\\t(*hit).voxel_position = voxel;\\r\\n\\t\\t\\t(*hit).depth = 1 - (thit - depth_clip_min) / (depth_clip_max - depth_clip_min);\\r\\n\\t\\t\\t(*hit).normal = hit_normal;\\r\\n\\t\\t\\t(*hit).ray_direction = ray.direction;\\r\\n\\t\\t\\tif (tmax_comp.x < tmax_comp.y && tmax_comp.x < tmax_comp.z) {\\r\\n\\t\\t\\t\\t(*hit).exit_position = ray.origin + ray.direction * tmax_comp.x;\\r\\n\\t\\t\\t} else if (tmax_comp.y < tmax_comp.z){\\r\\n\\t\\t\\t\\t(*hit).exit_position = ray.origin + ray.direction * tmax_comp.y;\\r\\n\\t\\t\\t} else {\\r\\n\\t\\t\\t\\t(*hit).exit_position = ray.origin + ray.direction * tmax_comp.z;\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\treturn true;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif (tmax_comp.x < tmax_comp.y && tmax_comp.x < tmax_comp.z) {\\r\\n\\t\\t\\tvoxel.x += step.x;\\r\\n\\t\\t\\tthit = tmax_comp.x;\\r\\n\\t\\t\\ttmax_comp.x += tdelta.x;\\r\\n\\t\\t\\thit_normal = vec3<f32>(f32(-step.x), 0, 0);\\r\\n\\t\\t} else if (tmax_comp.y < tmax_comp.z){\\r\\n\\t\\t\\tvoxel.y += step.y;\\r\\n\\t\\t\\tthit = tmax_comp.y;\\r\\n\\t\\t\\ttmax_comp.y += tdelta.y;\\r\\n\\t\\t\\thit_normal = vec3<f32>(0, f32(-step.y), 0);\\r\\n\\t\\t} else {\\r\\n\\t\\t\\tvoxel.z += step.z;\\r\\n\\t\\t\\tthit = tmax_comp.z;\\r\\n\\t\\t\\ttmax_comp.z += tdelta.z;\\r\\n\\t\\t\\thit_normal = vec3<f32>(0, 0, f32(-step.z));\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\treturn false;\\r\\n}\\r\\n\\r\\nfn get_point_ao_lambert(point: vec3<f32>, normal: vec3<f32>) -> f32 {\\r\\n\\tvar ao: f32 = 0.0;\\r\\n\\tfor (var i = 0; i < ao_samples; i++) {\\r\\n\\t\\tlet sample_point = (random_unit_vector() + normal) * rng() * voxel_size * 0.6 + point ;\\r\\n\\t\\tao += get_voxel_by_position(sample_point).opacity;\\r\\n\\t}\\r\\n\\treturn max(0, ao / f32(ao_samples));\\r\\n}\\r\\n\\r\\nfn get_point_ao(point: vec3<f32>) -> f32 {\\r\\n\\tvar ao: f32 = 0.0;\\r\\n\\tfor (var i = 0; i < ao_samples; i++) {\\r\\n\\t\\tlet sample_point = random_unit_vector() * rng() * ao_range + point;\\r\\n\\t\\tao += get_voxel_by_position(sample_point).opacity;\\r\\n\\t}\\r\\n\\treturn max(0, ao / f32(ao_samples) - 0.5);\\r\\n}\\r\\n\"","import { vec3 } from \"wgpu-matrix\";\nexport class SliceRenderer {\n    constructor(canvas, scene) {\n        this.background = [0, 0, 0];\n        this.canvas = canvas;\n        this.axis = \"z\";\n        this.slice = 0;\n        this.scene = scene;\n        this.context = canvas.getContext(\"2d\");\n        const slice_input = (document.getElementById(\"slice-input\"));\n        slice_input.addEventListener(\"change\", (e) => {\n            const slice = Math.floor((parseInt(slice_input.value) / 100) * this.scene.voxel_count);\n            this.set_slice(slice > this.scene.voxel_count - 1 ? this.scene.voxel_count - 1 : slice);\n            console.log(slice);\n        });\n    }\n    set_background(background) {\n        this.background = background;\n        this.update();\n    }\n    set_axis(axis) {\n        this.axis = axis;\n        this.update();\n    }\n    set_slice(slice) {\n        this.slice = slice;\n        this.update();\n    }\n    update() {\n        const sx = this.canvas.width;\n        const sy = this.canvas.height;\n        const sxpv = sx / this.scene.voxel_count;\n        const sypv = sy / this.scene.voxel_count;\n        // this.context.fillStyle = this.color_to_string(this.background, 1);\n        // this.context.fillStyle = \"#FFFFFF00\";\n        this.context.clearRect(0, 0, sx, sy);\n        // const img = this.context?.createImageData(sx, sy);\n        for (let x = 0; x < this.scene.voxel_count; x++) {\n            for (let y = 0; y < this.scene.voxel_count; y++) {\n                const id = y * sx + x;\n                const vox_pos = this.axis === \"x\"\n                    ? [this.slice, x, y]\n                    : this.axis === \"y\"\n                        ? [x, this.slice, y]\n                        : [x, y, this.slice];\n                const vox = this.scene.get_voxel(vox_pos);\n                const scaled_color = vec3.floor(vec3.scale(vox.color, 255));\n                this.context.fillStyle = this.color_to_string(vox.color, vox.opacity);\n                this.context.fillRect(x * sxpv, y * sypv, sxpv, sypv);\n                // img.data[id * 4 + 0] = vox.color[0];\n                // img.data[id * 4 + 1] = vox.color[1];\n                // img.data[id * 4 + 2] = vox.color[2];\n                // img.data[id * 4 + 3] = 255;\n            }\n        }\n        // this.context.putImageData(img, 0, 0);\n    }\n    color_to_string(color, opacity) {\n        const scaled_color = vec3.floor(vec3.scale(color, 255));\n        return (\"#\" +\n            scaled_color[0].toString(16) +\n            scaled_color[1].toString(16) +\n            scaled_color[2].toString(16) +\n            (opacity * 255).toString(16));\n    }\n}\n","export function switch_latte() {\n    const root = document.querySelector(\":root\");\n    document.documentElement.dataset.theme = \"latte\";\n    root.style.setProperty(\"--ctp-crust\", \"#dce0e8\");\n    root.style.setProperty(\"--ctp-mantle\", \"#e6e9ef\");\n    root.style.setProperty(\"--ctp-base\", \"#eff1f5\");\n    root.style.setProperty(\"--ctp-surface0\", \"#ccd0da\");\n    root.style.setProperty(\"--ctp-surface1\", \"#bcc0cc\");\n    root.style.setProperty(\"--ctp-surface2\", \"#acb0be\");\n    root.style.setProperty(\"--ctp-overlay0\", \"#9ca0b0\");\n    root.style.setProperty(\"--ctp-overlay1\", \"#8c8fa1\");\n    root.style.setProperty(\"--ctp-overlay2\", \"#7c7f93\");\n    root.style.setProperty(\"--ctp-subtext0\", \"#6c6f85\");\n    root.style.setProperty(\"--ctp-subtext1\", \"#5c5f77\");\n    root.style.setProperty(\"--ctp-text\", \"#4c4f69\");\n    root.style.setProperty(\"--ctp-lavender\", \"#7287fd\");\n    root.style.setProperty(\"--ctp-blue\", \"#1e66f5\");\n    root.style.setProperty(\"--ctp-sapphire\", \"#209fb5\");\n    root.style.setProperty(\"--ctp-sky\", \"#04a5e5\");\n    root.style.setProperty(\"--ctp-teal\", \"#179299\");\n    root.style.setProperty(\"--ctp-green\", \"#40a02b\");\n    root.style.setProperty(\"--ctp-yellow\", \"#df8e1d\");\n    root.style.setProperty(\"--ctp-peach\", \"#fe640b\");\n    root.style.setProperty(\"--ctp-maroon\", \"#e64553\");\n    root.style.setProperty(\"--ctp-red\", \"#d20f39\");\n    root.style.setProperty(\"--ctp-mauve\", \"#8839ef\");\n    root.style.setProperty(\"--ctp-pink\", \"#ea76cb\");\n    root.style.setProperty(\"--ctp-flamingo\", \"#dd7878\");\n    root.style.setProperty(\"--ctp-rosewater\", \"#dc8a78\");\n}\nexport function switch_mocha() {\n    const root = document.querySelector(\":root\");\n    document.documentElement.dataset.theme = \"mocha\";\n    root.style.setProperty(\"--ctp-crust\", \"#11111b\");\n    root.style.setProperty(\"--ctp-mantle\", \"#181825\");\n    root.style.setProperty(\"--ctp-base\", \"#1e1e2e\");\n    root.style.setProperty(\"--ctp-surface0\", \"#313244\");\n    root.style.setProperty(\"--ctp-surface1\", \"#45475a\");\n    root.style.setProperty(\"--ctp-surface2\", \"#585b70\");\n    root.style.setProperty(\"--ctp-overlay0\", \"#6c7086\");\n    root.style.setProperty(\"--ctp-overlay1\", \"#7f849c\");\n    root.style.setProperty(\"--ctp-overlay2\", \"#9399b2\");\n    root.style.setProperty(\"--ctp-subtext0\", \"#a6adc8\");\n    root.style.setProperty(\"--ctp-subtext1\", \"#bac2de\");\n    root.style.setProperty(\"--ctp-text\", \"#cdd6f4\");\n    root.style.setProperty(\"--ctp-lavender\", \"#b4befe\");\n    root.style.setProperty(\"--ctp-blue\", \"#89b4fa\");\n    root.style.setProperty(\"--ctp-sapphire\", \"#74c7ec\");\n    root.style.setProperty(\"--ctp-sky\", \"#89dceb\");\n    root.style.setProperty(\"--ctp-teal\", \"#94e2d5\");\n    root.style.setProperty(\"--ctp-green\", \"#a6e3a1\");\n    root.style.setProperty(\"--ctp-yellow\", \"#f9e2af\");\n    root.style.setProperty(\"--ctp-peach\", \"#fab387\");\n    root.style.setProperty(\"--ctp-maroon\", \"#eba0ac\");\n    root.style.setProperty(\"--ctp-red\", \"#f38ba8\");\n    root.style.setProperty(\"--ctp-mauve\", \"#cba6f7\");\n    root.style.setProperty(\"--ctp-pink\", \"#f5c2e7\");\n    root.style.setProperty(\"--ctp-flamingo\", \"#f2cdcd\");\n    root.style.setProperty(\"--ctp-rosewater\", \"#f5e0dc\");\n}\n"],"names":["__awaiter","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","value","step","next","e","rejected","result","done","then","apply","EPSILON","VecType$2","Float32Array","create$5","x","y","dst","undefined","fromValues$3","subtract$3","a","b","sub$3","mulScalar$3","v","k","scale$5","inverse$5","invert$4","dot$3","length$3","v0","v1","Math","sqrt","len$3","lengthSq$3","lenSq$3","distance$2","dx","dy","dist$2","distanceSq$2","distSq$2","copy$5","clone$5","multiply$5","mul$5","divide$2","div$2","vec2Impl","Object","freeze","__proto__","add","addScaled","scale","angle","ax","ay","bx","by","mag","cosine","acos","ceil","clamp","min","max","clone","copy","create","cross","z","dist","distSq","distance","distanceSq","div","divScalar","divide","dot","equals","equalsApproximately","abs","floor","fromValues","inverse","invert","len","lenSq","length","lengthSq","lerp","t","lerpV","mul","mulScalar","multiply","negate","normalize","random","PI","cos","sin","round","setDefaultType","ctor","oldType","sub","subtract","transformMat3","m","transformMat4","zero","Map","Float64Array","Array","fill","get","VecType$1","create$3","fromValues$2","subtract$2","sub$2","mulScalar$2","scale$3","inverse$3","invert$2","dot$2","length$2","v2","len$2","lengthSq$2","lenSq$2","distance$1","dz","dist$1","distanceSq$1","distSq$1","copy$3","clone$3","multiply$3","mul$3","divide$1","div$1","vec3Impl","az","bz","t1","t2","getAxis","axis","off","getScaling","xx","xy","xz","yx","yy","yz","zx","zy","zz","getTranslation","zScale","w","transformMat4Upper3x3","Ray","constructor","origin","direction","this","inv_direction","RayHit","position","voxel_position","voxel","normal","Voxel","color","opacity","roughness","lightness","Deg2Rad","theta","OrbitCamera","phi","dragged","velocity","forward","right","up","eulers","update","tick","delta_time","screen_to_ray","sx","sy","horizontal_coefficient","vertical_coefficient","ray_direction","canvas","document","getElementById","fps","slice_canvas","scene","grid_size","voxel_count","grid","boundary_min","boundary_max","voxel_size","initialize_grid","direct_light","direct_light_brightness","background_color","vox","initialize_default_grid","set_voxel_comp","ray_any","ray","tmin","tmax","Infinity","d","ray_entry","ray_exit","voxel_upper_edge","tmax_comp","tdelta","end_voxel","thit","hit_normal","get_voxel","hit_position","get_voxel_id_comp","get_voxel_id","get_voxel_comp","set_voxel","controller","mouse_down","mouse_dragged","last_move","selected_color","selected_roughness","selected_opacity","selected_lightness","camera","setup","performance","now","last_movement","selected_tool","_a","_b","_c","_d","_e","_f","_g","addEventListener","button","rect","getBoundingClientRect","clientX","left","clientY","top","width","height","n_voxel","map","val","i","r_voxel","d_voxel","movementX","movementY","mouse_drag","calculate_velocity","col","target","match","parseInt","renderer","initialized","render","lights","push","device","queue","writeBuffer","sceneParameters","Date","getMilliseconds","light_data","lightData","scene_data","sceneData","commandEncoder","createCommandEncoder","ray_trace_pass","beginComputePass","setPipeline","ray_tracing_pipeline","setBindGroup","ray_tracing_bind_group","dispatchWorkgroups","end","textureView","context","getCurrentTexture","createView","renderPass","beginRenderPass","colorAttachments","view","clearValue","r","g","loadOp","storeOp","screen_pipeline","screen_bind_group","draw","submit","finish","pathtracing","initialize","setupDevice","createAssets","setupPipeline","set_hdr","hdr","shutdown","destroy","color_buffer","secondary_buffer","adapter","navigator","gpu","requestAdapter","requestDevice","getContext","format","configure","alphaMode","_h","createTexture","size","usage","GPUTextureUsage","COPY_DST","STORAGE_BINDING","TEXTURE_BINDING","color_buffer_view","secondary_buffer_view","sampler","createSampler","addressModeU","addressModeV","magFilter","minFilter","mipmapFilter","maxAnisotropy","createBuffer","GPUBufferUsage","UNIFORM","scene_size","STORAGE","createBindGroupLayout","entries","binding","visibility","GPUShaderStage","COMPUTE","storageTexture","access","viewDimension","buffer","type","createBindGroup","layout","label","resource","ray_tracing_pipline_layout","createPipelineLayout","bindGroupLayouts","createComputePipeline","compute","entryPoint","module","createShaderModule","code","constants","screen_bind_group_layout","FRAGMENT","texture","screen_pipeline_layout","createRenderPipeline","vertex","screen_shader","fragment","targets","primitive","topology","cullMode","frontFace","slice_renderer","background","slice","slice_input","set_slice","console","log","set_background","set_axis","sxpv","sypv","clearRect","vox_pos","fillStyle","color_to_string","fillRect","scaled_color","toString","last_time","camera_active","documentElement","dataset","scroll","window","scrollY","requestAnimationFrame","elapsed","innerText","theme","btn_switch_theme","root","querySelector","style","setProperty","switch_latte","switch_mocha","btn_rescale_canvas","scaled","innerWidth","innerHeight","preventDefault"],"sourceRoot":""}