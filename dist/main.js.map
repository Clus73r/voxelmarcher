{"version":3,"file":"main.js","mappings":"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","sources":["webpack://voxelraymarcher/./src/shaders/common.wgsl","webpack://voxelraymarcher/./src/shaders/screen_shader.wgsl","webpack://voxelraymarcher/./src/renderer.ts","webpack://voxelraymarcher/./node_modules/wgpu-matrix/dist/2.x/wgpu-matrix.module.js","webpack://voxelraymarcher/./src/scene.ts","webpack://voxelraymarcher/./src/math_util.ts","webpack://voxelraymarcher/./src/orbit_camera.ts","webpack://voxelraymarcher/./src/slice_renderer.ts","webpack://voxelraymarcher/./src/main.ts","webpack://voxelraymarcher/./src/controller.ts","webpack://voxelraymarcher/./src/shaders/path_trace_kernel.wgsl","webpack://voxelraymarcher/./src/shaders/ray_trace_kernel.wgsl","webpack://voxelraymarcher/./src/theme_switch.ts"],"sourcesContent":["export default \"@group(0) @binding(0) var color_buffer: texture_storage_2d<rgba8unorm, write>;\\r\\n@group(0) @binding(1) var<uniform> scene: SceneParameter;\\r\\n@group(0) @binding(2) var<storage, read> scene_data: SceneData;\\r\\n// @group(0) @binding(3) var hdr_tex: texture_2d<f32>;\\r\\n// @group(0) @binding(4) var hdr_sampler: sampler;\\r\\n@group(0) @binding(3) var<storage, read> lights: LightData;\\r\\n@group(0) @binding(4) var secondary_buffer: texture_storage_2d<rgba8unorm, write>;\\r\\n@group(0) @binding(5) var<storage, read> scene_meta_data: SceneMetaData;\\r\\n\\r\\noverride grid_size: f32 = 2f;\\r\\noverride voxel_count: i32 = 4;\\r\\nvar<private> voxel_size: f32 = grid_size / f32(voxel_count);\\r\\nvar<private> boundary_min: vec3<f32> = vec3<f32>(f32(-grid_size) / 2, f32(-grid_size) / 2, f32(-grid_size) / 2);\\r\\nvar<private> boundary_max: vec3<f32> = vec3<f32>(f32(grid_size) / 2, f32(grid_size) / 2, f32(grid_size) / 2);\\r\\nvar<private> depth_clip_min: f32 = 1f;\\r\\nvar<private> depth_clip_max: f32 = 10f;\\r\\n\\r\\nvar<private> rng_seed: u32;\\r\\nvar<private> rng_seed_steady: u32;\\r\\n\\r\\nconst samples: i32 = 1;\\r\\nconst light_bounces: i32 = 6;\\r\\nconst max_penetrations: i32 = 5;\\r\\nconst reflection_bounces: i32 = 5;\\r\\nconst scatter: i32 = 5;\\r\\nconst ambient_light: f32 = 0.03;\\r\\nconst pi = 3.14159265359;\\r\\n\\r\\n// const background: vec3<f32> = vec3<f32>(24f / 255f, 24f / 255f, 37f / 255f);\\r\\n\\r\\nstruct SceneParameter {\\r\\n    camera_pos: vec3<f32>,\\r\\n    rng_start: f32,\\r\\n    camera_forward: vec3<f32>,\\r\\n    light_count: f32,\\r\\n    camera_right: vec3<f32>,\\r\\n    camera_up: vec3<f32>,\\r\\n    direct_light: vec3<f32>,\\r\\n    direct_light_brightness: f32,\\r\\n\\tbackground_color: vec3<f32>,\\r\\n}\\r\\n\\r\\nstruct Voxel {\\r\\n\\tcolor: vec3<f32>,\\r\\n\\topacity: f32,\\r\\n\\troughness: f32,\\r\\n\\tlightness: f32,\\r\\n}\\r\\n\\r\\nstruct MetaVoxel {\\r\\n\\tgi: vec3<f32>,\\r\\n\\tsomethingelse: vec3<f32>\\r\\n}\\r\\n\\r\\nstruct SceneData {\\r\\n\\tdata: array<Voxel>,\\r\\n}\\r\\n\\r\\nstruct SceneMetaData {\\r\\n\\tdata: array<MetaVoxel>,\\r\\n}\\r\\n\\r\\nstruct LightData {\\r\\n\\tdata: array<Light>,\\r\\n}\\r\\n\\r\\nstruct Light {\\r\\n\\tlocation: vec3<f32>,\\r\\n\\temitter_type: f32,\\r\\n}\\r\\n\\r\\nstruct Ray {\\r\\n    origin: vec3<f32>,\\r\\n    direction: vec3<f32>,\\r\\n    inv_direction: vec3<f32>,\\r\\n}\\r\\n\\r\\nstruct RayHit {\\r\\n\\tposition: vec3<f32>,\\r\\n\\tdepth: f32,\\r\\n\\tvoxel_position: vec3<i32>,\\r\\n\\tvoxel: Voxel,\\r\\n\\tnormal: vec3<f32>,\\r\\n\\tray_direction: vec3<f32>,\\r\\n\\texit_position: vec3<f32>,\\r\\n\\tao: f32,\\r\\n\\tuv: vec2<f32>,\\r\\n}\\r\\n\\r\\nstruct TraceResult {\\r\\n\\tcolor: vec3<f32>,\\r\\n\\tao: f32,\\r\\n}\\r\\n\\r\\n@compute @workgroup_size(16,16,1)\\r\\nfn main(@builtin(global_invocation_id) GlobalInvocationID : vec3<u32>) {\\r\\n    let screen_size: vec2<u32> = textureDimensions(color_buffer);\\r\\n    let screen_pos : vec2<i32> = vec2<i32>(i32(GlobalInvocationID.x), i32(GlobalInvocationID.y));\\r\\n    // rng_seed = GlobalInvocationID.x + 50 + (GlobalInvocationID.y + 50) * (GlobalInvocationID.x + 100) * 1000 * u32(scene.rng_start);\\r\\n    rng_seed = GlobalInvocationID.x + 50 + (GlobalInvocationID.y + 50) * (GlobalInvocationID.x + 100) * 1000;\\r\\n    rng_seed_steady = GlobalInvocationID.x + 150 + (GlobalInvocationID.y + 75) * (GlobalInvocationID.x + 350) * 1000;\\r\\n\\r\\n    var pixel_color: vec3<f32>;\\r\\n    var pixel_ao: f32;\\r\\n    for (var i = 0; i < samples; i++){\\r\\n\\r\\n\\t    let rng_offset: vec2<f32> = select(vec2<f32>(0), vec2<f32>(rng() - 0.5, rng() - 0.5), samples > 1);\\r\\n\\t    let horizontal_coefficient: f32 = (f32(screen_pos.x) + rng_offset.x - f32(screen_size.x) / 2) / f32(screen_size.x);\\r\\n\\t    let vertical_coefficient: f32 = (f32(screen_pos.y) + rng_offset.y - f32(screen_size.y) / 2) / -f32(screen_size.y);\\r\\n\\r\\n\\t    let ray_direction = normalize(scene.camera_forward\\r\\n\\t\\t\\t    + horizontal_coefficient * scene.camera_right\\r\\n\\t\\t\\t    + vertical_coefficient * scene.camera_up);\\r\\n\\t    let ray: Ray = Ray(scene.camera_pos, ray_direction, 1 / ray_direction);\\r\\n\\t    let trace_result = trace(ray, light_bounces);\\r\\n\\t    // pixel_color += trace(ray, light_bounces);\\r\\n\\t    // pixel_color += trace_result.color;\\r\\n\\t    pixel_color += trace_result;\\r\\n\\t    // pixel_ao += trace_result.ao;\\r\\n    }\\r\\n\\r\\n    // let correction = 1.0 / f32(samples);\\r\\n    // pixel_color = sqrt(correction * pixel_color);\\r\\n\\r\\n\\tpixel_color /= f32(samples);\\r\\n\\t// pixel_ao /= f32(samples);\\r\\n\\r\\n    /* pixel_color = textureSampleLevel(hdr_tex, hdr_sampler, vec2<f32>(f32(GlobalInvocationID.x) / f32(screen_size.x), f32(GlobalInvocationID.y) / f32(screen_size.y) * 2), 0.0).rgb; */\\r\\n\\r\\n    textureStore(color_buffer, screen_pos, vec4<f32>(pixel_color, 1.0));\\r\\n    // textureStore(secondary_buffer, screen_pos, vec4<f32>(pixel_ao, 0, 0, 1.0));\\r\\n}\\r\\n\\r\\nfn rng_hash(seed: u32) -> u32 {\\r\\n\\tvar x = ( seed << 10u );\\r\\n\\tx ^= ( x >>  6u );\\r\\n\\tx += ( x <<  3u );\\r\\n\\tx ^= ( x >> 11u );\\r\\n\\tx += ( x << 15u );\\r\\n\\treturn x;\\r\\n}\\r\\n\\r\\nfn rng() -> f32 {\\r\\n\\trng_seed++;\\r\\n\\treturn bitcast<f32>((rng_hash(rng_seed) >> 9) | 0x3f800000 ) - 1.0;\\r\\n}\\r\\n\\r\\nfn rng_steady() -> f32 {\\r\\n\\trng_seed_steady++;\\r\\n\\treturn bitcast<f32>((rng_hash(rng_seed_steady) >> 9) | 0x3f800000 ) - 1.0;\\r\\n}\\r\\n\\r\\nfn ray_reflect(ray: Ray, position: vec3<f32>, normal: vec3<f32>) -> Ray {\\r\\n\\tlet reflect = ray.direction - 2 * dot(ray.direction, normal) * normal;\\r\\n\\treturn Ray(position, reflect, 1 / reflect);\\r\\n}\\r\\n\\r\\nfn get_voxel_id(v: vec3<i32>) -> i32 {\\r\\n\\treturn v.z * voxel_count * voxel_count + v.y * voxel_count + v.x;\\r\\n}\\r\\n\\r\\nfn get_voxel(v: vec3<i32>) -> Voxel {\\r\\n\\treturn scene_data.data[v.z * voxel_count * voxel_count + v.y * voxel_count + v.x];\\r\\n}\\r\\n\\r\\nfn get_meta_voxel(v: vec3<i32>) -> MetaVoxel {\\r\\n\\treturn scene_meta_data.data[v.z * voxel_count * voxel_count + v.y * voxel_count + v.x];\\r\\n}\\r\\n\\r\\nfn get_voxel_by_position(v: vec3<f32>) -> Voxel {\\r\\n\\treturn get_voxel(vec3<i32>((v - boundary_min) / f32(voxel_size)));\\r\\n}\\r\\n\\r\\nfn sample_spherical_map(v: vec3<f32>) -> vec2<f32> {\\r\\n\\tlet theta = atan2(v.x, v.y);\\r\\n\\tlet phi = acos(v.z);\\r\\n\\tlet raw_u = theta / (2 * pi);\\r\\n\\tlet uv = vec2<f32>(\\r\\n\\t\\t1 - (raw_u + 0.5),\\r\\n\\t\\tphi / pi\\r\\n\\t);\\r\\n\\treturn uv;\\r\\n}\\r\\n\\r\\nfn random_unit_vector() -> vec3<f32> {\\r\\n\\tlet phi = rng() * pi * 2;\\r\\n\\tlet costheta = rng() * 2 - 1;\\r\\n\\t\\tlet theta = acos(costheta);\\r\\n\\tlet x = sin(theta) * cos(phi);\\r\\n\\tlet y = sin(theta) * sin(phi);\\r\\n\\tlet z = cos(theta);\\r\\n\\treturn vec3<f32>(x, y, z);\\r\\n}\\r\\n\"","export default \"@group(0) @binding(0) var screen_sampler : sampler;\\r\\n@group(0) @binding(1) var color_buffer : texture_2d<f32>;\\r\\n@group(0) @binding(2) var secondary_buffer : texture_2d<f32>;\\r\\n\\r\\nstruct VertexOutput {\\r\\n        @builtin(position) Position : vec4<f32>,\\r\\n            @location(0) TexCoord : vec2<f32>,\\r\\n}\\r\\n\\r\\n@vertex\\r\\nfn vert_main(@builtin(vertex_index) VertexIndex : u32) -> VertexOutput {\\r\\n    var positions = array<vec2<f32>, 6>(\\r\\n        vec2<f32>( 1.0,  1.0),\\r\\n        vec2<f32>( 1.0, -1.0),\\r\\n        vec2<f32>(-1.0, -1.0),\\r\\n        vec2<f32>( 1.0,  1.0),\\r\\n        vec2<f32>(-1.0, -1.0),\\r\\n        vec2<f32>(-1.0,  1.0)\\r\\n    );\\r\\n\\r\\n    var texCoords = array<vec2<f32>, 6>(\\r\\n        vec2<f32>(1.0, 0.0),\\r\\n        vec2<f32>(1.0, 1.0),\\r\\n        vec2<f32>(0.0, 1.0),\\r\\n        vec2<f32>(1.0, 0.0),\\r\\n        vec2<f32>(0.0, 1.0),\\r\\n        vec2<f32>(0.0, 0.0)\\r\\n    );\\r\\n\\r\\n    var output : VertexOutput;\\r\\n    output.Position = vec4<f32>(positions[VertexIndex], 0.0, 1.0);\\r\\n    output.TexCoord = texCoords[VertexIndex];\\r\\n    return output;\\r\\n}\\r\\n\\r\\nconst ao_blur_steps = 7;\\r\\nconst ao_blur_radius = 0.00f / f32(ao_blur_steps);\\r\\nconst ao_strength = 1;\\r\\n\\r\\n@fragment\\r\\nfn frag_main(@location(0) TexCoord : vec2<f32>) -> @location(0) vec4<f32> {\\r\\n\\tvar acc = 0f;\\r\\n\\tlet blur_offset = (ao_blur_radius * f32(ao_blur_steps)) / 2;\\r\\n\\tfor (var x = 0; x < ao_blur_steps; x++){\\r\\n\\t\\tfor (var y = 0; y < ao_blur_steps; y++){\\r\\n\\t\\t\\tacc += textureSample(secondary_buffer, screen_sampler, vec2<f32>(TexCoord.x - blur_offset + ao_blur_radius * f32(x), TexCoord.y - blur_offset + ao_blur_radius * f32(y))).x;\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\tacc /= f32(ao_blur_steps) * f32(ao_blur_steps);\\r\\n\\r\\n    // return vec4<f32>(acc, acc, acc, 1.0);\\r\\n    return textureSample(color_buffer, screen_sampler, TexCoord) * (1 - acc * ao_strength);\\r\\n}\\r\\n\"","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport common from \"./shaders/common.wgsl\";\nimport ray_trace_kernel from \"./shaders/ray_trace_kernel.wgsl\";\nimport path_trace_kernel from \"./shaders/path_trace_kernel.wgsl\";\nimport screen_shader from \"./shaders/screen_shader.wgsl\";\nexport class Renderer {\n    constructor(canvas, scene, camera) {\n        // hdrtexture: HDRTexture;\n        this.initialized = false;\n        this.render = () => {\n            var _a, _b, _c, _d, _e, _f, _g;\n            if (!this.initialized)\n                return;\n            let lights = [];\n            for (let x = 0; x < this.scene.voxel_count; x++) {\n                for (let y = 0; y < this.scene.voxel_count; y++) {\n                    for (let z = 0; z < this.scene.voxel_count; z++) {\n                        if (this.scene.get_voxel([x, y, z]).lightness > 0) {\n                            lights.push([x, y, z]);\n                        }\n                    }\n                }\n            }\n            (_a = this.device) === null || _a === void 0 ? void 0 : _a.queue.writeBuffer(this.sceneParameters, 0, new Float32Array([\n                this.camera.position[0],\n                this.camera.position[1],\n                this.camera.position[2],\n                new Date().getMilliseconds(),\n                this.camera.forward[0],\n                this.camera.forward[1],\n                this.camera.forward[2],\n                lights.length,\n                this.camera.right[0],\n                this.camera.right[1],\n                this.camera.right[2],\n                0.0,\n                this.camera.up[0],\n                this.camera.up[1],\n                this.camera.up[2],\n                0.0,\n                this.scene.direct_light[0],\n                this.scene.direct_light[1],\n                this.scene.direct_light[2],\n                this.scene.direct_light_brightness,\n                this.scene.background_color[0],\n                this.scene.background_color[1],\n                this.scene.background_color[2],\n                0.0,\n            ]), 0, 24);\n            const light_data = new Float32Array(4 * lights.length);\n            for (let i = 0; i < lights.length; ++i) {\n                light_data[4 * i] = lights[i][0];\n                light_data[4 * i + 1] = lights[i][1];\n                light_data[4 * i + 2] = lights[i][2];\n                light_data[4 * i + 3] = 0;\n            }\n            (_b = this.device) === null || _b === void 0 ? void 0 : _b.queue.writeBuffer(this.lightData, 0, light_data, 0, lights.length * 4);\n            const scene_data = new Float32Array(8 * this.scene.grid.length);\n            for (let i = 0; i < this.scene.grid.length; ++i) {\n                scene_data[8 * i] = this.scene.grid[i].color[0];\n                scene_data[8 * i + 1] = this.scene.grid[i].color[1];\n                scene_data[8 * i + 2] = this.scene.grid[i].color[2];\n                scene_data[8 * i + 3] = this.scene.grid[i].opacity;\n                scene_data[8 * i + 4] = this.scene.grid[i].roughness;\n                scene_data[8 * i + 5] = this.scene.grid[i].lightness;\n                scene_data[8 * i + 6] = 0;\n                scene_data[8 * i + 7] = 0;\n            }\n            const scene_meta_data = new Float32Array(8 * this.scene.grid.length);\n            for (let i = 0; i < this.scene.grid.length; ++i) {\n                scene_meta_data[8 * i] = this.scene.meta_grid[i].gi[0];\n                scene_meta_data[8 * i + 1] = this.scene.meta_grid[i].gi[1];\n                scene_meta_data[8 * i + 2] = this.scene.meta_grid[i].gi[2];\n                scene_meta_data[8 * i + 3] = 0;\n                scene_meta_data[8 * i + 4] = 0;\n                scene_meta_data[8 * i + 5] = 0;\n                scene_meta_data[8 * i + 6] = 0;\n                scene_meta_data[8 * i + 7] = 0;\n            }\n            (_c = this.device) === null || _c === void 0 ? void 0 : _c.queue.writeBuffer(this.sceneData, 0, scene_data, 0, this.scene.grid.length * 8);\n            (_d = this.device) === null || _d === void 0 ? void 0 : _d.queue.writeBuffer(this.sceneMetaData, 0, scene_meta_data, 0, this.scene.grid.length * 8);\n            const commandEncoder = (_e = this.device) === null || _e === void 0 ? void 0 : _e.createCommandEncoder();\n            const ray_trace_pass = commandEncoder === null || commandEncoder === void 0 ? void 0 : commandEncoder.beginComputePass();\n            ray_trace_pass === null || ray_trace_pass === void 0 ? void 0 : ray_trace_pass.setPipeline(this.ray_tracing_pipeline);\n            ray_trace_pass === null || ray_trace_pass === void 0 ? void 0 : ray_trace_pass.setBindGroup(0, this.ray_tracing_bind_group);\n            ray_trace_pass === null || ray_trace_pass === void 0 ? void 0 : ray_trace_pass.dispatchWorkgroups(this.canvas.width / 16, this.canvas.height / 16, 1);\n            ray_trace_pass === null || ray_trace_pass === void 0 ? void 0 : ray_trace_pass.end();\n            const textureView = (_f = this.context) === null || _f === void 0 ? void 0 : _f.getCurrentTexture().createView();\n            const renderPass = commandEncoder === null || commandEncoder === void 0 ? void 0 : commandEncoder.beginRenderPass({\n                colorAttachments: [\n                    {\n                        view: textureView,\n                        clearValue: { r: 0.5, g: 0.0, b: 0.25, a: 1.0 },\n                        loadOp: \"clear\",\n                        storeOp: \"store\",\n                    },\n                ],\n            });\n            renderPass === null || renderPass === void 0 ? void 0 : renderPass.setPipeline(this.screen_pipeline);\n            renderPass === null || renderPass === void 0 ? void 0 : renderPass.setBindGroup(0, this.screen_bind_group);\n            renderPass === null || renderPass === void 0 ? void 0 : renderPass.draw(6, 1, 0, 0);\n            renderPass === null || renderPass === void 0 ? void 0 : renderPass.end();\n            (_g = this.device) === null || _g === void 0 ? void 0 : _g.queue.submit([commandEncoder === null || commandEncoder === void 0 ? void 0 : commandEncoder.finish()]);\n        };\n        this.canvas = canvas;\n        this.scene = scene;\n        this.pathtracing = false;\n        this.camera = camera;\n        // this.hdrtexture = new HDRTexture();\n    }\n    initialize(pathtracing) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.pathtracing = pathtracing;\n            yield this.setupDevice();\n            yield this.createAssets();\n            yield this.setupPipeline();\n            this.initialized = true;\n        });\n    }\n    set_hdr(hdr) { }\n    shutdown() {\n        var _a, _b, _c;\n        this.initialized = false;\n        (_a = this.device) === null || _a === void 0 ? void 0 : _a.destroy();\n        (_b = this.color_buffer) === null || _b === void 0 ? void 0 : _b.destroy();\n        (_c = this.secondary_buffer) === null || _c === void 0 ? void 0 : _c.destroy();\n    }\n    setupDevice() {\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function* () {\n            this.adapter = (yield ((_a = navigator.gpu) === null || _a === void 0 ? void 0 : _a.requestAdapter()));\n            this.device = yield ((_b = this.adapter) === null || _b === void 0 ? void 0 : _b.requestDevice());\n            this.context = this.canvas.getContext(\"webgpu\");\n            this.format = \"bgra8unorm\";\n            this.context.configure({\n                device: this.device,\n                format: this.format,\n                alphaMode: \"opaque\",\n            });\n        });\n    }\n    createAssets() {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j;\n        return __awaiter(this, void 0, void 0, function* () {\n            this.color_buffer = (_a = this.device) === null || _a === void 0 ? void 0 : _a.createTexture({\n                size: { width: this.canvas.width, height: this.canvas.height },\n                format: \"rgba8unorm\",\n                usage: GPUTextureUsage.COPY_DST |\n                    GPUTextureUsage.STORAGE_BINDING |\n                    GPUTextureUsage.TEXTURE_BINDING,\n            });\n            this.secondary_buffer = (_b = this.device) === null || _b === void 0 ? void 0 : _b.createTexture({\n                size: { width: this.canvas.width, height: this.canvas.height },\n                format: \"rgba8unorm\",\n                usage: GPUTextureUsage.COPY_DST |\n                    GPUTextureUsage.STORAGE_BINDING |\n                    GPUTextureUsage.TEXTURE_BINDING,\n            });\n            this.color_buffer_view = (_c = this.color_buffer) === null || _c === void 0 ? void 0 : _c.createView();\n            this.secondary_buffer_view = (_d = this.secondary_buffer) === null || _d === void 0 ? void 0 : _d.createView();\n            this.sampler = (_e = this.device) === null || _e === void 0 ? void 0 : _e.createSampler({\n                addressModeU: \"repeat\",\n                addressModeV: \"repeat\",\n                magFilter: \"linear\",\n                minFilter: \"nearest\",\n                mipmapFilter: \"nearest\",\n                maxAnisotropy: 1,\n            });\n            this.sceneParameters = (_f = this.device) === null || _f === void 0 ? void 0 : _f.createBuffer({\n                size: 96,\n                usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\n            });\n            const scene_size = this.scene.voxel_count * this.scene.voxel_count * this.scene.voxel_count;\n            this.sceneData = (_g = this.device) === null || _g === void 0 ? void 0 : _g.createBuffer({\n                size: scene_size * 8 * 4,\n                usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\n            });\n            this.sceneMetaData = (_h = this.device) === null || _h === void 0 ? void 0 : _h.createBuffer({\n                size: scene_size * 8 * 4,\n                usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\n            });\n            this.lightData = (_j = this.device) === null || _j === void 0 ? void 0 : _j.createBuffer({\n                size: 128 * 4,\n                usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\n            });\n        });\n    }\n    setupPipeline() {\n        var _a, _b, _c, _d, _e, _f, _g, _h;\n        return __awaiter(this, void 0, void 0, function* () {\n            const ray_tracing_bind_group = ((_a = this.device) === null || _a === void 0 ? void 0 : _a.createBindGroupLayout({\n                entries: [\n                    {\n                        binding: 0,\n                        visibility: GPUShaderStage.COMPUTE,\n                        storageTexture: {\n                            access: \"write-only\",\n                            format: \"rgba8unorm\",\n                            viewDimension: \"2d\",\n                        },\n                    },\n                    {\n                        binding: 1,\n                        visibility: GPUShaderStage.COMPUTE,\n                        buffer: {\n                            type: \"uniform\",\n                        },\n                    },\n                    {\n                        binding: 2,\n                        visibility: GPUShaderStage.COMPUTE,\n                        buffer: {\n                            type: \"read-only-storage\",\n                        },\n                    },\n                    // {\n                    //   binding: 3,\n                    //   visibility: GPUShaderStage.COMPUTE,\n                    //   texture: {},\n                    // },\n                    // {\n                    //   binding: 4,\n                    //   visibility: GPUShaderStage.COMPUTE,\n                    //   sampler: {},\n                    // },\n                    {\n                        binding: 3,\n                        visibility: GPUShaderStage.COMPUTE,\n                        buffer: {\n                            type: \"read-only-storage\",\n                        },\n                    },\n                    {\n                        binding: 4,\n                        visibility: GPUShaderStage.COMPUTE,\n                        storageTexture: {\n                            access: \"write-only\",\n                            format: \"rgba8unorm\",\n                            viewDimension: \"2d\",\n                        },\n                    },\n                    {\n                        binding: 5,\n                        visibility: GPUShaderStage.COMPUTE,\n                        buffer: {\n                            type: \"read-only-storage\",\n                        },\n                    },\n                ],\n            }));\n            this.ray_tracing_bind_group = (_b = this.device) === null || _b === void 0 ? void 0 : _b.createBindGroup({\n                layout: ray_tracing_bind_group,\n                label: \"Ray tracing bind group\",\n                entries: [\n                    { binding: 0, resource: this.color_buffer_view },\n                    {\n                        binding: 1,\n                        resource: { buffer: this.sceneParameters },\n                    },\n                    { binding: 2, resource: { buffer: this.sceneData } },\n                    // {\n                    //   binding: 3,\n                    //   resource: <GPUTextureView>this.hdrtexture.view,\n                    // },\n                    // {\n                    //   binding: 4,\n                    //   resource: <GPUSampler>this.hdrtexture.sampler,\n                    // },\n                    {\n                        binding: 3,\n                        resource: { buffer: this.lightData },\n                    },\n                    {\n                        binding: 4,\n                        resource: this.secondary_buffer_view,\n                    },\n                    {\n                        binding: 5,\n                        resource: { buffer: this.sceneMetaData },\n                    },\n                ],\n            });\n            const ray_tracing_pipline_layout = ((_c = this.device) === null || _c === void 0 ? void 0 : _c.createPipelineLayout({\n                bindGroupLayouts: [ray_tracing_bind_group],\n            }));\n            this.ray_tracing_pipeline = ((_d = this.device) === null || _d === void 0 ? void 0 : _d.createComputePipeline({\n                label: \"Ray tracing pipeline\",\n                layout: ray_tracing_pipline_layout,\n                compute: {\n                    entryPoint: \"main\",\n                    module: this.device.createShaderModule({\n                        code: common +\n                            (!this.pathtracing ? ray_trace_kernel : path_trace_kernel),\n                    }),\n                    constants: {\n                        grid_size: this.scene.grid_size,\n                        voxel_count: this.scene.voxel_count,\n                    },\n                },\n            }));\n            const screen_bind_group_layout = ((_e = this.device) === null || _e === void 0 ? void 0 : _e.createBindGroupLayout({\n                entries: [\n                    { binding: 0, visibility: GPUShaderStage.FRAGMENT, sampler: {} },\n                    { binding: 1, visibility: GPUShaderStage.FRAGMENT, texture: {} },\n                    { binding: 2, visibility: GPUShaderStage.FRAGMENT, texture: {} },\n                ],\n            }));\n            this.screen_bind_group = (_f = this.device) === null || _f === void 0 ? void 0 : _f.createBindGroup({\n                layout: screen_bind_group_layout,\n                entries: [\n                    { binding: 0, resource: this.sampler },\n                    { binding: 1, resource: this.color_buffer_view },\n                    {\n                        binding: 2,\n                        resource: this.secondary_buffer_view,\n                    },\n                ],\n            });\n            const screen_pipeline_layout = ((_g = this.device) === null || _g === void 0 ? void 0 : _g.createPipelineLayout({\n                bindGroupLayouts: [screen_bind_group_layout],\n            }));\n            this.screen_pipeline = (_h = this.device) === null || _h === void 0 ? void 0 : _h.createRenderPipeline({\n                layout: screen_pipeline_layout,\n                vertex: {\n                    module: this.device.createShaderModule({ code: screen_shader }),\n                    entryPoint: \"vert_main\",\n                },\n                fragment: {\n                    module: this.device.createShaderModule({ code: screen_shader }),\n                    entryPoint: \"frag_main\",\n                    targets: [{ format: \"bgra8unorm\" }],\n                },\n                primitive: {\n                    topology: \"triangle-list\",\n                    cullMode: \"back\",\n                    frontFace: \"cw\",\n                },\n            });\n        });\n    }\n}\n","/* wgpu-matrix@2.2.2, license MIT */\nvar arrayLike = /*#__PURE__*/Object.freeze({\n    __proto__: null\n});\n\n/*\n * Copyright 2022 Gregg Tavares\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\nlet EPSILON = 0.000001;\n/**\n * Set the value for EPSILON for various checks\n * @param v - Value to use for EPSILON.\n * @returns previous value of EPSILON;\n */\nfunction setEpsilon(v) {\n    const old = EPSILON;\n    EPSILON = v;\n    return old;\n}\n/**\n * Convert degrees to radians\n * @param degrees - Angle in degrees\n * @returns angle converted to radians\n */\nfunction degToRad(degrees) {\n    return degrees * Math.PI / 180;\n}\n/**\n * Convert radians to degrees\n * @param radians - Angle in radians\n * @returns angle converted to degrees\n */\nfunction radToDeg(radians) {\n    return radians * 180 / Math.PI;\n}\n/**\n * Lerps between a and b via t\n * @param a - starting value\n * @param b - ending value\n * @param t - value where 0 = a and 1 = b\n * @returns a + (b - a) * t\n */\nfunction lerp$4(a, b, t) {\n    return a + (b - a) * t;\n}\n/**\n * Compute the opposite of lerp. Given a and b and a value between\n * a and b returns a value between 0 and 1. 0 if a, 1 if b.\n * Note: no clamping is done.\n * @param a - start value\n * @param b - end value\n * @param v - value between a and b\n * @returns (v - a) / (b - a)\n */\nfunction inverseLerp(a, b, v) {\n    const d = b - a;\n    return (Math.abs(b - a) < EPSILON)\n        ? a\n        : (v - a) / d;\n}\n/**\n * Compute the euclidean modulo\n *\n * ```\n * // table for n / 3\n * -5, -4, -3, -2, -1,  0,  1,  2,  3,  4,  5   <- n\n * ------------------------------------\n * -2  -1  -0  -2  -1   0,  1,  2,  0,  1,  2   <- n % 3\n *  1   2   0   1   2   0,  1,  2,  0,  1,  2   <- euclideanModule(n, 3)\n * ```\n *\n * @param n - dividend\n * @param m - divisor\n * @returns the euclidean modulo of n / m\n */\nfunction euclideanModulo(n, m) {\n    return ((n % m) + m) % m;\n}\n\nvar utils = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    get EPSILON () { return EPSILON; },\n    degToRad: degToRad,\n    euclideanModulo: euclideanModulo,\n    inverseLerp: inverseLerp,\n    lerp: lerp$4,\n    radToDeg: radToDeg,\n    setEpsilon: setEpsilon\n});\n\n/**\n *\n * Vec2 math functions.\n *\n * Almost all functions take an optional `dst` argument. If it is not passed in the\n * functions will create a new Vec2. In other words you can do this\n *\n *     const v = vec2.cross(v1, v2);  // Creates a new Vec2 with the cross product of v1 x v2.\n *\n * or\n *\n *     const v = vec2.create();\n *     vec2.cross(v1, v2, v);  // Puts the cross product of v1 x v2 in v\n *\n * The first style is often easier but depending on where it's used it generates garbage where\n * as there is almost never allocation with the second style.\n *\n * It is always safe to pass any vector as the destination. So for example\n *\n *     vec2.cross(v1, v2, v1);  // Puts the cross product of v1 x v2 in v1\n *\n */\nlet VecType$2 = Float32Array;\n/**\n * Sets the type this library creates for a Vec2\n * @param ctor - the constructor for the type. Either `Float32Array`, `Float64Array`, or `Array`\n * @returns previous constructor for Vec2\n */\nfunction setDefaultType$6(ctor) {\n    const oldType = VecType$2;\n    VecType$2 = ctor;\n    return oldType;\n}\n/**\n * Creates a Vec2; may be called with x, y, z to set initial values.\n *\n * Note: Since passing in a raw JavaScript array\n * is valid in all circumstances, if you want to\n * force a JavaScript array into a Vec2's specified type\n * it would be faster to use\n *\n * ```\n * const v = vec2.clone(someJSArray);\n * ```\n *\n * Note: a consequence of the implementation is if your Vec2Type = `Array`\n * instead of `Float32Array` or `Float64Array` then any values you\n * don't pass in will be undefined. Usually this is not an issue since\n * (a) using `Array` is rare and (b) using `vec2.create` is usually used\n * to create a Vec2 to be filled out as in\n *\n * ```\n * const sum = vec2.create();\n * vec2.add(v1, v2, sum);\n * ```\n *\n * @param x - Initial x value.\n * @param y - Initial y value.\n * @returns the created vector\n */\nfunction create$5(x = 0, y = 0) {\n    const dst = new VecType$2(2);\n    if (x !== undefined) {\n        dst[0] = x;\n        if (y !== undefined) {\n            dst[1] = y;\n        }\n    }\n    return dst;\n}\n\n/*\n * Copyright 2022 Gregg Tavares\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n/**\n * Creates a Vec2; may be called with x, y, z to set initial values. (same as create)\n * @param x - Initial x value.\n * @param y - Initial y value.\n * @returns the created vector\n */\nconst fromValues$3 = create$5;\n/**\n * Applies Math.ceil to each element of vector\n * @param v - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that is the ceil of each element of v.\n */\nfunction ceil$2(v, dst) {\n    dst = dst || new VecType$2(2);\n    dst[0] = Math.ceil(v[0]);\n    dst[1] = Math.ceil(v[1]);\n    return dst;\n}\n/**\n * Applies Math.floor to each element of vector\n * @param v - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that is the floor of each element of v.\n */\nfunction floor$2(v, dst) {\n    dst = dst || new VecType$2(2);\n    dst[0] = Math.floor(v[0]);\n    dst[1] = Math.floor(v[1]);\n    return dst;\n}\n/**\n * Applies Math.round to each element of vector\n * @param v - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that is the round of each element of v.\n */\nfunction round$2(v, dst) {\n    dst = dst || new VecType$2(2);\n    dst[0] = Math.round(v[0]);\n    dst[1] = Math.round(v[1]);\n    return dst;\n}\n/**\n * Clamp each element of vector between min and max\n * @param v - Operand vector.\n * @param max - Min value, default 0\n * @param min - Max value, default 1\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that the clamped value of each element of v.\n */\nfunction clamp$2(v, min = 0, max = 1, dst) {\n    dst = dst || new VecType$2(2);\n    dst[0] = Math.min(max, Math.max(min, v[0]));\n    dst[1] = Math.min(max, Math.max(min, v[1]));\n    return dst;\n}\n/**\n * Adds two vectors; assumes a and b have the same dimension.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that is the sum of a and b.\n */\nfunction add$3(a, b, dst) {\n    dst = dst || new VecType$2(2);\n    dst[0] = a[0] + b[0];\n    dst[1] = a[1] + b[1];\n    return dst;\n}\n/**\n * Adds two vectors, scaling the 2nd; assumes a and b have the same dimension.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param scale - Amount to scale b\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that is the sum of a + b * scale.\n */\nfunction addScaled$2(a, b, scale, dst) {\n    dst = dst || new VecType$2(2);\n    dst[0] = a[0] + b[0] * scale;\n    dst[1] = a[1] + b[1] * scale;\n    return dst;\n}\n/**\n * Returns the angle in radians between two vectors.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @returns The angle in radians between the 2 vectors.\n */\nfunction angle$2(a, b) {\n    const ax = a[0];\n    const ay = a[1];\n    const bx = a[0];\n    const by = a[1];\n    const mag1 = Math.sqrt(ax * ax + ay * ay);\n    const mag2 = Math.sqrt(bx * bx + by * by);\n    const mag = mag1 * mag2;\n    const cosine = mag && dot$3(a, b) / mag;\n    return Math.acos(cosine);\n}\n/**\n * Subtracts two vectors.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that is the difference of a and b.\n */\nfunction subtract$3(a, b, dst) {\n    dst = dst || new VecType$2(2);\n    dst[0] = a[0] - b[0];\n    dst[1] = a[1] - b[1];\n    return dst;\n}\n/**\n * Subtracts two vectors.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that is the difference of a and b.\n */\nconst sub$3 = subtract$3;\n/**\n * Check if 2 vectors are approximately equal\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @returns true if vectors are approximately equal\n */\nfunction equalsApproximately$5(a, b) {\n    return Math.abs(a[0] - b[0]) < EPSILON &&\n        Math.abs(a[1] - b[1]) < EPSILON;\n}\n/**\n * Check if 2 vectors are exactly equal\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @returns true if vectors are exactly equal\n */\nfunction equals$5(a, b) {\n    return a[0] === b[0] && a[1] === b[1];\n}\n/**\n * Performs linear interpolation on two vectors.\n * Given vectors a and b and interpolation coefficient t, returns\n * a + t * (b - a).\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param t - Interpolation coefficient.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The linear interpolated result.\n */\nfunction lerp$3(a, b, t, dst) {\n    dst = dst || new VecType$2(2);\n    dst[0] = a[0] + t * (b[0] - a[0]);\n    dst[1] = a[1] + t * (b[1] - a[1]);\n    return dst;\n}\n/**\n * Performs linear interpolation on two vectors.\n * Given vectors a and b and interpolation coefficient vector t, returns\n * a + t * (b - a).\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param t - Interpolation coefficients vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns the linear interpolated result.\n */\nfunction lerpV$2(a, b, t, dst) {\n    dst = dst || new VecType$2(2);\n    dst[0] = a[0] + t[0] * (b[0] - a[0]);\n    dst[1] = a[1] + t[1] * (b[1] - a[1]);\n    return dst;\n}\n/**\n * Return max values of two vectors.\n * Given vectors a and b returns\n * [max(a[0], b[0]), max(a[1], b[1]), max(a[2], b[2])].\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The max components vector.\n */\nfunction max$2(a, b, dst) {\n    dst = dst || new VecType$2(2);\n    dst[0] = Math.max(a[0], b[0]);\n    dst[1] = Math.max(a[1], b[1]);\n    return dst;\n}\n/**\n * Return min values of two vectors.\n * Given vectors a and b returns\n * [min(a[0], b[0]), min(a[1], b[1]), min(a[2], b[2])].\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The min components vector.\n */\nfunction min$2(a, b, dst) {\n    dst = dst || new VecType$2(2);\n    dst[0] = Math.min(a[0], b[0]);\n    dst[1] = Math.min(a[1], b[1]);\n    return dst;\n}\n/**\n * Multiplies a vector by a scalar.\n * @param v - The vector.\n * @param k - The scalar.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The scaled vector.\n */\nfunction mulScalar$3(v, k, dst) {\n    dst = dst || new VecType$2(2);\n    dst[0] = v[0] * k;\n    dst[1] = v[1] * k;\n    return dst;\n}\n/**\n * Multiplies a vector by a scalar. (same as mulScalar)\n * @param v - The vector.\n * @param k - The scalar.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The scaled vector.\n */\nconst scale$5 = mulScalar$3;\n/**\n * Divides a vector by a scalar.\n * @param v - The vector.\n * @param k - The scalar.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The scaled vector.\n */\nfunction divScalar$3(v, k, dst) {\n    dst = dst || new VecType$2(2);\n    dst[0] = v[0] / k;\n    dst[1] = v[1] / k;\n    return dst;\n}\n/**\n * Inverse a vector.\n * @param v - The vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The inverted vector.\n */\nfunction inverse$5(v, dst) {\n    dst = dst || new VecType$2(2);\n    dst[0] = 1 / v[0];\n    dst[1] = 1 / v[1];\n    return dst;\n}\n/**\n * Invert a vector. (same as inverse)\n * @param v - The vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The inverted vector.\n */\nconst invert$4 = inverse$5;\n/**\n * Computes the cross product of two vectors; assumes both vectors have\n * three entries.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The vector of a cross b.\n */\nfunction cross$1(a, b, dst) {\n    dst = dst || new VecType$2(3);\n    const z = a[0] * b[1] - a[1] * b[0];\n    dst[0] = 0;\n    dst[1] = 0;\n    dst[2] = z;\n    return dst;\n}\n/**\n * Computes the dot product of two vectors; assumes both vectors have\n * three entries.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @returns dot product\n */\nfunction dot$3(a, b) {\n    return a[0] * b[0] + a[1] * b[1];\n}\n/**\n * Computes the length of vector\n * @param v - vector.\n * @returns length of vector.\n */\nfunction length$3(v) {\n    const v0 = v[0];\n    const v1 = v[1];\n    return Math.sqrt(v0 * v0 + v1 * v1);\n}\n/**\n * Computes the length of vector (same as length)\n * @param v - vector.\n * @returns length of vector.\n */\nconst len$3 = length$3;\n/**\n * Computes the square of the length of vector\n * @param v - vector.\n * @returns square of the length of vector.\n */\nfunction lengthSq$3(v) {\n    const v0 = v[0];\n    const v1 = v[1];\n    return v0 * v0 + v1 * v1;\n}\n/**\n * Computes the square of the length of vector (same as lengthSq)\n * @param v - vector.\n * @returns square of the length of vector.\n */\nconst lenSq$3 = lengthSq$3;\n/**\n * Computes the distance between 2 points\n * @param a - vector.\n * @param b - vector.\n * @returns distance between a and b\n */\nfunction distance$2(a, b) {\n    const dx = a[0] - b[0];\n    const dy = a[1] - b[1];\n    return Math.sqrt(dx * dx + dy * dy);\n}\n/**\n * Computes the distance between 2 points (same as distance)\n * @param a - vector.\n * @param b - vector.\n * @returns distance between a and b\n */\nconst dist$2 = distance$2;\n/**\n * Computes the square of the distance between 2 points\n * @param a - vector.\n * @param b - vector.\n * @returns square of the distance between a and b\n */\nfunction distanceSq$2(a, b) {\n    const dx = a[0] - b[0];\n    const dy = a[1] - b[1];\n    return dx * dx + dy * dy;\n}\n/**\n * Computes the square of the distance between 2 points (same as distanceSq)\n * @param a - vector.\n * @param b - vector.\n * @returns square of the distance between a and b\n */\nconst distSq$2 = distanceSq$2;\n/**\n * Divides a vector by its Euclidean length and returns the quotient.\n * @param v - The vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The normalized vector.\n */\nfunction normalize$3(v, dst) {\n    dst = dst || new VecType$2(2);\n    const v0 = v[0];\n    const v1 = v[1];\n    const len = Math.sqrt(v0 * v0 + v1 * v1);\n    if (len > 0.00001) {\n        dst[0] = v0 / len;\n        dst[1] = v1 / len;\n    }\n    else {\n        dst[0] = 0;\n        dst[1] = 0;\n    }\n    return dst;\n}\n/**\n * Negates a vector.\n * @param v - The vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns -v.\n */\nfunction negate$4(v, dst) {\n    dst = dst || new VecType$2(2);\n    dst[0] = -v[0];\n    dst[1] = -v[1];\n    return dst;\n}\n/**\n * Copies a vector. (same as clone)\n * @param v - The vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A copy of v.\n */\nfunction copy$5(v, dst) {\n    dst = dst || new VecType$2(2);\n    dst[0] = v[0];\n    dst[1] = v[1];\n    return dst;\n}\n/**\n * Clones a vector. (same as copy)\n * @param v - The vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A copy of v.\n */\nconst clone$5 = copy$5;\n/**\n * Multiplies a vector by another vector (component-wise); assumes a and\n * b have the same length.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The vector of products of entries of a and b.\n */\nfunction multiply$5(a, b, dst) {\n    dst = dst || new VecType$2(2);\n    dst[0] = a[0] * b[0];\n    dst[1] = a[1] * b[1];\n    return dst;\n}\n/**\n * Multiplies a vector by another vector (component-wise); assumes a and\n * b have the same length. (same as mul)\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The vector of products of entries of a and b.\n */\nconst mul$5 = multiply$5;\n/**\n * Divides a vector by another vector (component-wise); assumes a and\n * b have the same length.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The vector of quotients of entries of a and b.\n */\nfunction divide$2(a, b, dst) {\n    dst = dst || new VecType$2(2);\n    dst[0] = a[0] / b[0];\n    dst[1] = a[1] / b[1];\n    return dst;\n}\n/**\n * Divides a vector by another vector (component-wise); assumes a and\n * b have the same length. (same as divide)\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The vector of quotients of entries of a and b.\n */\nconst div$2 = divide$2;\n/**\n * Creates a random unit vector * scale\n * @param scale - Default 1\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The random vector.\n */\nfunction random$1(scale = 1, dst) {\n    dst = dst || new VecType$2(2);\n    const angle = Math.random() * 2 * Math.PI;\n    dst[0] = Math.cos(angle) * scale;\n    dst[1] = Math.sin(angle) * scale;\n    return dst;\n}\n/**\n * Zero's a vector\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The zeroed vector.\n */\nfunction zero$2(dst) {\n    dst = dst || new VecType$2(2);\n    dst[0] = 0;\n    dst[1] = 0;\n    return dst;\n}\n/**\n * transform Vec2 by 4x4 matrix\n * @param v - the vector\n * @param m - The matrix.\n * @param dst - optional Vec2 to store result. If not passed a new one is created.\n * @returns the transformed vector\n */\nfunction transformMat4$2(v, m, dst) {\n    dst = dst || new VecType$2(2);\n    const x = v[0];\n    const y = v[1];\n    dst[0] = x * m[0] + y * m[4] + m[12];\n    dst[1] = x * m[1] + y * m[5] + m[13];\n    return dst;\n}\n/**\n * Transforms vec4 by 3x3 matrix\n *\n * @param v - the vector\n * @param m - The matrix.\n * @param dst - optional Vec2 to store result. If not passed a new one is created.\n * @returns the transformed vector\n */\nfunction transformMat3$1(v, m, dst) {\n    dst = dst || new VecType$2(2);\n    const x = v[0];\n    const y = v[1];\n    dst[0] = m[0] * x + m[4] * y + m[8];\n    dst[1] = m[1] * x + m[5] * y + m[9];\n    return dst;\n}\n\nvar vec2Impl = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    add: add$3,\n    addScaled: addScaled$2,\n    angle: angle$2,\n    ceil: ceil$2,\n    clamp: clamp$2,\n    clone: clone$5,\n    copy: copy$5,\n    create: create$5,\n    cross: cross$1,\n    dist: dist$2,\n    distSq: distSq$2,\n    distance: distance$2,\n    distanceSq: distanceSq$2,\n    div: div$2,\n    divScalar: divScalar$3,\n    divide: divide$2,\n    dot: dot$3,\n    equals: equals$5,\n    equalsApproximately: equalsApproximately$5,\n    floor: floor$2,\n    fromValues: fromValues$3,\n    inverse: inverse$5,\n    invert: invert$4,\n    len: len$3,\n    lenSq: lenSq$3,\n    length: length$3,\n    lengthSq: lengthSq$3,\n    lerp: lerp$3,\n    lerpV: lerpV$2,\n    max: max$2,\n    min: min$2,\n    mul: mul$5,\n    mulScalar: mulScalar$3,\n    multiply: multiply$5,\n    negate: negate$4,\n    normalize: normalize$3,\n    random: random$1,\n    round: round$2,\n    scale: scale$5,\n    setDefaultType: setDefaultType$6,\n    sub: sub$3,\n    subtract: subtract$3,\n    transformMat3: transformMat3$1,\n    transformMat4: transformMat4$2,\n    zero: zero$2\n});\n\n/*\n * Copyright 2022 Gregg Tavares\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n/**\n * 3x3 Matrix math math functions.\n *\n * Almost all functions take an optional `dst` argument. If it is not passed in the\n * functions will create a new matrix. In other words you can do this\n *\n *     const mat = mat3.translation([1, 2, 3]);  // Creates a new translation matrix\n *\n * or\n *\n *     const mat = mat3.create();\n *     mat3.translation([1, 2, 3], mat);  // Puts translation matrix in mat.\n *\n * The first style is often easier but depending on where it's used it generates garbage where\n * as there is almost never allocation with the second style.\n *\n * It is always save to pass any matrix as the destination. So for example\n *\n *     const mat = mat3.identity();\n *     const trans = mat3.translation([1, 2, 3]);\n *     mat3.multiply(mat, trans, mat);  // Multiplies mat * trans and puts result in mat.\n *\n */\nlet MatType$1 = Float32Array;\n// This mess is because with Mat3 we have 3 unused elements.\n// For Float32Array and Float64Array that's not an issue\n// but for Array it's troublesome\nconst ctorMap = new Map([\n    [Float32Array, () => new Float32Array(12)],\n    [Float64Array, () => new Float64Array(12)],\n    [Array, () => new Array(12).fill(0)],\n]);\nlet newMat3 = ctorMap.get(Float32Array);\n/**\n * Sets the type this library creates for a Mat3\n * @param ctor - the constructor for the type. Either `Float32Array`, `Float64Array`, or `Array`\n * @returns previous constructor for Mat3\n */\nfunction setDefaultType$5(ctor) {\n    const oldType = MatType$1;\n    MatType$1 = ctor;\n    newMat3 = ctorMap.get(ctor);\n    return oldType;\n}\n/**\n * Create a Mat3 from values\n *\n * Note: Since passing in a raw JavaScript array\n * is valid in all circumstances, if you want to\n * force a JavaScript array into a Mat3's specified type\n * it would be faster to use\n *\n * ```\n * const m = mat3.clone(someJSArray);\n * ```\n *\n * Note: a consequence of the implementation is if your Mat3Type = `Array`\n * instead of `Float32Array` or `Float64Array` then any values you\n * don't pass in will be undefined. Usually this is not an issue since\n * (a) using `Array` is rare and (b) using `mat3.create` is usually used\n * to create a Mat3 to be filled out as in\n *\n * ```\n * const m = mat3.create();\n * mat3.perspective(fov, aspect, near, far, m);\n * ```\n *\n * @param v0 - value for element 0\n * @param v1 - value for element 1\n * @param v2 - value for element 2\n * @param v3 - value for element 3\n * @param v4 - value for element 4\n * @param v5 - value for element 5\n * @param v6 - value for element 6\n * @param v7 - value for element 7\n * @param v8 - value for element 8\n * @returns matrix created from values.\n */\nfunction create$4(v0, v1, v2, v3, v4, v5, v6, v7, v8) {\n    const dst = newMat3();\n    // to make the array homogenous\n    dst[3] = 0;\n    dst[7] = 0;\n    dst[11] = 0;\n    if (v0 !== undefined) {\n        dst[0] = v0;\n        if (v1 !== undefined) {\n            dst[1] = v1;\n            if (v2 !== undefined) {\n                dst[2] = v2;\n                if (v3 !== undefined) {\n                    dst[4] = v3;\n                    if (v4 !== undefined) {\n                        dst[5] = v4;\n                        if (v5 !== undefined) {\n                            dst[6] = v5;\n                            if (v6 !== undefined) {\n                                dst[8] = v6;\n                                if (v7 !== undefined) {\n                                    dst[9] = v7;\n                                    if (v8 !== undefined) {\n                                        dst[10] = v8;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return dst;\n}\n/**\n * Creates a Mat3 from the upper left 3x3 part of a Mat4\n * @param m4 - source matrix\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns Mat3 made from m4\n */\nfunction fromMat4(m4, dst) {\n    dst = dst || newMat3();\n    dst[0] = m4[0];\n    dst[1] = m4[1];\n    dst[2] = m4[2];\n    dst[3] = 0;\n    dst[4] = m4[4];\n    dst[5] = m4[5];\n    dst[6] = m4[6];\n    dst[7] = 0;\n    dst[8] = m4[8];\n    dst[9] = m4[9];\n    dst[10] = m4[10];\n    dst[11] = 0;\n    return dst;\n}\n/**\n * Creates a Mat3 rotation matrix from a quaternion\n * @param q - quaternion to create matrix from\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns Mat3 made from q\n */\nfunction fromQuat$1(q, dst) {\n    dst = dst || newMat3();\n    const x = q[0];\n    const y = q[1];\n    const z = q[2];\n    const w = q[3];\n    const x2 = x + x;\n    const y2 = y + y;\n    const z2 = z + z;\n    const xx = x * x2;\n    const yx = y * x2;\n    const yy = y * y2;\n    const zx = z * x2;\n    const zy = z * y2;\n    const zz = z * z2;\n    const wx = w * x2;\n    const wy = w * y2;\n    const wz = w * z2;\n    dst[0] = 1 - yy - zz;\n    dst[1] = yx + wz;\n    dst[2] = zx - wy;\n    dst[3] = 0;\n    dst[4] = yx - wz;\n    dst[5] = 1 - xx - zz;\n    dst[6] = zy + wx;\n    dst[7] = 0;\n    dst[8] = zx + wy;\n    dst[9] = zy - wx;\n    dst[10] = 1 - xx - yy;\n    dst[11] = 0;\n    return dst;\n}\n/**\n * Negates a matrix.\n * @param m - The matrix.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns -m.\n */\nfunction negate$3(m, dst) {\n    dst = dst || newMat3();\n    dst[0] = -m[0];\n    dst[1] = -m[1];\n    dst[2] = -m[2];\n    dst[4] = -m[4];\n    dst[5] = -m[5];\n    dst[6] = -m[6];\n    dst[8] = -m[8];\n    dst[9] = -m[9];\n    dst[10] = -m[10];\n    return dst;\n}\n/**\n * Copies a matrix.\n * @param m - The matrix.\n * @param dst - The matrix. If not passed a new one is created.\n * @returns A copy of m.\n */\nfunction copy$4(m, dst) {\n    dst = dst || newMat3();\n    dst[0] = m[0];\n    dst[1] = m[1];\n    dst[2] = m[2];\n    dst[4] = m[4];\n    dst[5] = m[5];\n    dst[6] = m[6];\n    dst[8] = m[8];\n    dst[9] = m[9];\n    dst[10] = m[10];\n    return dst;\n}\n/**\n * Copies a matrix (same as copy)\n * @param m - The matrix.\n * @param dst - The matrix. If not passed a new one is created.\n * @returns A copy of m.\n */\nconst clone$4 = copy$4;\n/**\n * Check if 2 matrices are approximately equal\n * @param a Operand matrix.\n * @param b Operand matrix.\n * @returns true if matrices are approximately equal\n */\nfunction equalsApproximately$4(a, b) {\n    return Math.abs(a[0] - b[0]) < EPSILON &&\n        Math.abs(a[1] - b[1]) < EPSILON &&\n        Math.abs(a[2] - b[2]) < EPSILON &&\n        Math.abs(a[4] - b[4]) < EPSILON &&\n        Math.abs(a[5] - b[5]) < EPSILON &&\n        Math.abs(a[6] - b[6]) < EPSILON &&\n        Math.abs(a[8] - b[8]) < EPSILON &&\n        Math.abs(a[9] - b[9]) < EPSILON &&\n        Math.abs(a[10] - b[10]) < EPSILON;\n}\n/**\n * Check if 2 matrices are exactly equal\n * @param a Operand matrix.\n * @param b Operand matrix.\n * @returns true if matrices are exactly equal\n */\nfunction equals$4(a, b) {\n    return a[0] === b[0] &&\n        a[1] === b[1] &&\n        a[2] === b[2] &&\n        a[4] === b[4] &&\n        a[5] === b[5] &&\n        a[6] === b[6] &&\n        a[8] === b[8] &&\n        a[9] === b[9] &&\n        a[10] === b[10];\n}\n/**\n * Creates a 3-by-3 identity matrix.\n *\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns A 3-by-3 identity matrix.\n */\nfunction identity$2(dst) {\n    dst = dst || newMat3();\n    dst[0] = 1;\n    dst[1] = 0;\n    dst[2] = 0;\n    dst[4] = 0;\n    dst[5] = 1;\n    dst[6] = 0;\n    dst[8] = 0;\n    dst[9] = 0;\n    dst[10] = 1;\n    return dst;\n}\n/**\n * Takes the transpose of a matrix.\n * @param m - The matrix.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The transpose of m.\n */\nfunction transpose$1(m, dst) {\n    dst = dst || newMat3();\n    if (dst === m) {\n        let t;\n        // 0 1 2\n        // 4 5 6\n        // 8 9 10\n        t = m[1];\n        m[1] = m[4];\n        m[4] = t;\n        t = m[2];\n        m[2] = m[8];\n        m[8] = t;\n        t = m[6];\n        m[6] = m[9];\n        m[9] = t;\n        return dst;\n    }\n    const m00 = m[0 * 4 + 0];\n    const m01 = m[0 * 4 + 1];\n    const m02 = m[0 * 4 + 2];\n    const m10 = m[1 * 4 + 0];\n    const m11 = m[1 * 4 + 1];\n    const m12 = m[1 * 4 + 2];\n    const m20 = m[2 * 4 + 0];\n    const m21 = m[2 * 4 + 1];\n    const m22 = m[2 * 4 + 2];\n    dst[0] = m00;\n    dst[1] = m10;\n    dst[2] = m20;\n    dst[4] = m01;\n    dst[5] = m11;\n    dst[6] = m21;\n    dst[8] = m02;\n    dst[9] = m12;\n    dst[10] = m22;\n    return dst;\n}\n/**\n * Computes the inverse of a 3-by-3 matrix.\n * @param m - The matrix.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The inverse of m.\n */\nfunction inverse$4(m, dst) {\n    dst = dst || newMat3();\n    const m00 = m[0 * 4 + 0];\n    const m01 = m[0 * 4 + 1];\n    const m02 = m[0 * 4 + 2];\n    const m10 = m[1 * 4 + 0];\n    const m11 = m[1 * 4 + 1];\n    const m12 = m[1 * 4 + 2];\n    const m20 = m[2 * 4 + 0];\n    const m21 = m[2 * 4 + 1];\n    const m22 = m[2 * 4 + 2];\n    const m11_x_m22 = m11 * m22;\n    const m21_x_m12 = m21 * m12;\n    const m01_x_m22 = m01 * m22;\n    const m21_x_m02 = m21 * m02;\n    const m01_x_m12 = m01 * m12;\n    const m11_x_m02 = m11 * m02;\n    const invDet = 1 / (m00 * (m11_x_m22 - m21_x_m12) -\n        m10 * (m01_x_m22 - m21_x_m02) +\n        m20 * (m01_x_m12 - m11_x_m02));\n    dst[0] = +(m11_x_m22 - m21_x_m12) * invDet;\n    dst[1] = -(m10 * m22 - m20 * m12) * invDet;\n    dst[2] = +(m10 * m21 - m20 * m11) * invDet;\n    dst[4] = -(m01_x_m22 - m21_x_m02) * invDet;\n    dst[5] = +(m00 * m22 - m20 * m02) * invDet;\n    dst[6] = -(m00 * m21 - m20 * m01) * invDet;\n    dst[8] = +(m01_x_m12 - m11_x_m02) * invDet;\n    dst[9] = -(m00 * m12 - m10 * m02) * invDet;\n    dst[10] = +(m00 * m11 - m10 * m01) * invDet;\n    return dst;\n}\n/**\n * Compute the determinant of a matrix\n * @param m - the matrix\n * @returns the determinant\n */\nfunction determinant$1(m) {\n    const m00 = m[0 * 4 + 0];\n    const m01 = m[0 * 4 + 1];\n    const m02 = m[0 * 4 + 2];\n    const m10 = m[1 * 4 + 0];\n    const m11 = m[1 * 4 + 1];\n    const m12 = m[1 * 4 + 2];\n    const m20 = m[2 * 4 + 0];\n    const m21 = m[2 * 4 + 1];\n    const m22 = m[2 * 4 + 2];\n    return m00 * (m11 * m22 - m21 * m12) -\n        m10 * (m01 * m22 - m21 * m02) +\n        m20 * (m01 * m12 - m11 * m02);\n}\n/**\n * Computes the inverse of a 3-by-3 matrix. (same as inverse)\n * @param m - The matrix.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The inverse of m.\n */\nconst invert$3 = inverse$4;\n/**\n * Multiplies two 3-by-3 matrices with a on the left and b on the right\n * @param a - The matrix on the left.\n * @param b - The matrix on the right.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The matrix product of a and b.\n */\nfunction multiply$4(a, b, dst) {\n    dst = dst || newMat3();\n    const a00 = a[0];\n    const a01 = a[1];\n    const a02 = a[2];\n    const a10 = a[4 + 0];\n    const a11 = a[4 + 1];\n    const a12 = a[4 + 2];\n    const a20 = a[8 + 0];\n    const a21 = a[8 + 1];\n    const a22 = a[8 + 2];\n    const b00 = b[0];\n    const b01 = b[1];\n    const b02 = b[2];\n    const b10 = b[4 + 0];\n    const b11 = b[4 + 1];\n    const b12 = b[4 + 2];\n    const b20 = b[8 + 0];\n    const b21 = b[8 + 1];\n    const b22 = b[8 + 2];\n    dst[0] = a00 * b00 + a10 * b01 + a20 * b02;\n    dst[1] = a01 * b00 + a11 * b01 + a21 * b02;\n    dst[2] = a02 * b00 + a12 * b01 + a22 * b02;\n    dst[4] = a00 * b10 + a10 * b11 + a20 * b12;\n    dst[5] = a01 * b10 + a11 * b11 + a21 * b12;\n    dst[6] = a02 * b10 + a12 * b11 + a22 * b12;\n    dst[8] = a00 * b20 + a10 * b21 + a20 * b22;\n    dst[9] = a01 * b20 + a11 * b21 + a21 * b22;\n    dst[10] = a02 * b20 + a12 * b21 + a22 * b22;\n    return dst;\n}\n/**\n * Multiplies two 3-by-3 matrices with a on the left and b on the right (same as multiply)\n * @param a - The matrix on the left.\n * @param b - The matrix on the right.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The matrix product of a and b.\n */\nconst mul$4 = multiply$4;\n/**\n * Sets the translation component of a 3-by-3 matrix to the given\n * vector.\n * @param a - The matrix.\n * @param v - The vector.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The matrix with translation set.\n */\nfunction setTranslation$1(a, v, dst) {\n    dst = dst || identity$2();\n    if (a !== dst) {\n        dst[0] = a[0];\n        dst[1] = a[1];\n        dst[2] = a[2];\n        dst[4] = a[4];\n        dst[5] = a[5];\n        dst[6] = a[6];\n    }\n    dst[8] = v[0];\n    dst[9] = v[1];\n    dst[10] = 1;\n    return dst;\n}\n/**\n * Returns the translation component of a 3-by-3 matrix as a vector with 3\n * entries.\n * @param m - The matrix.\n * @param dst - vector to hold result. If not passed a new one is created.\n * @returns The translation component of m.\n */\nfunction getTranslation$2(m, dst) {\n    dst = dst || create$5();\n    dst[0] = m[8];\n    dst[1] = m[9];\n    return dst;\n}\n/**\n * Returns an axis of a 3x3 matrix as a vector with 2 entries\n * @param m - The matrix.\n * @param axis - The axis 0 = x, 1 = y,\n * @returns The axis component of m.\n */\nfunction getAxis$2(m, axis, dst) {\n    dst = dst || create$5();\n    const off = axis * 4;\n    dst[0] = m[off + 0];\n    dst[1] = m[off + 1];\n    return dst;\n}\n/**\n * Sets an axis of a 3x3 matrix as a vector with 2 entries\n * @param m - The matrix.\n * @param v - the axis vector\n * @param axis - The axis  0 = x, 1 = y;\n * @param dst - The matrix to set. If not passed a new one is created.\n * @returns The matrix with axis set.\n */\nfunction setAxis$1(m, v, axis, dst) {\n    if (dst !== m) {\n        dst = copy$4(m, dst);\n    }\n    const off = axis * 4;\n    dst[off + 0] = v[0];\n    dst[off + 1] = v[1];\n    return dst;\n}\n/**\n * Returns the scaling component of the matrix\n * @param m - The Matrix\n * @param dst - The vector to set. If not passed a new one is created.\n */\nfunction getScaling$2(m, dst) {\n    dst = dst || create$5();\n    const xx = m[0];\n    const xy = m[1];\n    const yx = m[4];\n    const yy = m[5];\n    dst[0] = Math.sqrt(xx * xx + xy * xy);\n    dst[1] = Math.sqrt(yx * yx + yy * yy);\n    return dst;\n}\n/**\n * Creates a 3-by-3 matrix which translates by the given vector v.\n * @param v - The vector by which to translate.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The translation matrix.\n */\nfunction translation$1(v, dst) {\n    dst = dst || newMat3();\n    dst[0] = 1;\n    dst[1] = 0;\n    dst[2] = 0;\n    dst[4] = 0;\n    dst[5] = 1;\n    dst[6] = 0;\n    dst[8] = v[0];\n    dst[9] = v[1];\n    dst[10] = 1;\n    return dst;\n}\n/**\n * Translates the given 3-by-3 matrix by the given vector v.\n * @param m - The matrix.\n * @param v - The vector by which to translate.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The translated matrix.\n */\nfunction translate$1(m, v, dst) {\n    dst = dst || newMat3();\n    const v0 = v[0];\n    const v1 = v[1];\n    const m00 = m[0];\n    const m01 = m[1];\n    const m02 = m[2];\n    const m10 = m[1 * 4 + 0];\n    const m11 = m[1 * 4 + 1];\n    const m12 = m[1 * 4 + 2];\n    const m20 = m[2 * 4 + 0];\n    const m21 = m[2 * 4 + 1];\n    const m22 = m[2 * 4 + 2];\n    if (m !== dst) {\n        dst[0] = m00;\n        dst[1] = m01;\n        dst[2] = m02;\n        dst[4] = m10;\n        dst[5] = m11;\n        dst[6] = m12;\n    }\n    dst[8] = m00 * v0 + m10 * v1 + m20;\n    dst[9] = m01 * v0 + m11 * v1 + m21;\n    dst[10] = m02 * v0 + m12 * v1 + m22;\n    return dst;\n}\n/**\n * Creates a 3-by-3 matrix which rotates  by the given angle.\n * @param angleInRadians - The angle by which to rotate (in radians).\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The rotation matrix.\n */\nfunction rotation$1(angleInRadians, dst) {\n    dst = dst || newMat3();\n    const c = Math.cos(angleInRadians);\n    const s = Math.sin(angleInRadians);\n    dst[0] = c;\n    dst[1] = s;\n    dst[2] = 0;\n    dst[4] = -s;\n    dst[5] = c;\n    dst[6] = 0;\n    dst[8] = 0;\n    dst[9] = 0;\n    dst[10] = 1;\n    return dst;\n}\n/**\n * Rotates the given 3-by-3 matrix  by the given angle.\n * @param m - The matrix.\n * @param angleInRadians - The angle by which to rotate (in radians).\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The rotated matrix.\n */\nfunction rotate$1(m, angleInRadians, dst) {\n    dst = dst || newMat3();\n    const m00 = m[0 * 4 + 0];\n    const m01 = m[0 * 4 + 1];\n    const m02 = m[0 * 4 + 2];\n    const m10 = m[1 * 4 + 0];\n    const m11 = m[1 * 4 + 1];\n    const m12 = m[1 * 4 + 2];\n    const c = Math.cos(angleInRadians);\n    const s = Math.sin(angleInRadians);\n    dst[0] = c * m00 + s * m10;\n    dst[1] = c * m01 + s * m11;\n    dst[2] = c * m02 + s * m12;\n    dst[4] = c * m10 - s * m00;\n    dst[5] = c * m11 - s * m01;\n    dst[6] = c * m12 - s * m02;\n    if (m !== dst) {\n        dst[8] = m[8];\n        dst[9] = m[9];\n        dst[10] = m[10];\n    }\n    return dst;\n}\n/**\n * Creates a 3-by-3 matrix which scales in each dimension by an amount given by\n * the corresponding entry in the given vector; assumes the vector has three\n * entries.\n * @param v - A vector of\n *     2 entries specifying the factor by which to scale in each dimension.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The scaling matrix.\n */\nfunction scaling$1(v, dst) {\n    dst = dst || newMat3();\n    dst[0] = v[0];\n    dst[1] = 0;\n    dst[2] = 0;\n    dst[4] = 0;\n    dst[5] = v[1];\n    dst[6] = 0;\n    dst[8] = 0;\n    dst[9] = 0;\n    dst[10] = 1;\n    return dst;\n}\n/**\n * Scales the given 3-by-3 matrix in each dimension by an amount\n * given by the corresponding entry in the given vector; assumes the vector has\n * three entries.\n * @param m - The matrix to be modified.\n * @param v - A vector of 2 entries specifying the\n *     factor by which to scale in each dimension.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The scaled matrix.\n */\nfunction scale$4(m, v, dst) {\n    dst = dst || newMat3();\n    const v0 = v[0];\n    const v1 = v[1];\n    dst[0] = v0 * m[0 * 4 + 0];\n    dst[1] = v0 * m[0 * 4 + 1];\n    dst[2] = v0 * m[0 * 4 + 2];\n    dst[4] = v1 * m[1 * 4 + 0];\n    dst[5] = v1 * m[1 * 4 + 1];\n    dst[6] = v1 * m[1 * 4 + 2];\n    if (m !== dst) {\n        dst[8] = m[8];\n        dst[9] = m[9];\n        dst[10] = m[10];\n    }\n    return dst;\n}\n\nvar mat3Impl = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    clone: clone$4,\n    copy: copy$4,\n    create: create$4,\n    determinant: determinant$1,\n    equals: equals$4,\n    equalsApproximately: equalsApproximately$4,\n    fromMat4: fromMat4,\n    fromQuat: fromQuat$1,\n    getAxis: getAxis$2,\n    getScaling: getScaling$2,\n    getTranslation: getTranslation$2,\n    identity: identity$2,\n    inverse: inverse$4,\n    invert: invert$3,\n    mul: mul$4,\n    multiply: multiply$4,\n    negate: negate$3,\n    rotate: rotate$1,\n    rotation: rotation$1,\n    scale: scale$4,\n    scaling: scaling$1,\n    setAxis: setAxis$1,\n    setDefaultType: setDefaultType$5,\n    setTranslation: setTranslation$1,\n    translate: translate$1,\n    translation: translation$1,\n    transpose: transpose$1\n});\n\n/**\n *\n * Vec3 math functions.\n *\n * Almost all functions take an optional `dst` argument. If it is not passed in the\n * functions will create a new `Vec3`. In other words you can do this\n *\n *     const v = vec3.cross(v1, v2);  // Creates a new Vec3 with the cross product of v1 x v2.\n *\n * or\n *\n *     const v = vec3.create();\n *     vec3.cross(v1, v2, v);  // Puts the cross product of v1 x v2 in v\n *\n * The first style is often easier but depending on where it's used it generates garbage where\n * as there is almost never allocation with the second style.\n *\n * It is always safe to pass any vector as the destination. So for example\n *\n *     vec3.cross(v1, v2, v1);  // Puts the cross product of v1 x v2 in v1\n *\n */\nlet VecType$1 = Float32Array;\n/**\n * Sets the type this library creates for a Vec3\n * @param ctor - the constructor for the type. Either `Float32Array`, `Float64Array`, or `Array`\n * @returns previous constructor for Vec3\n */\nfunction setDefaultType$4(ctor) {\n    const oldType = VecType$1;\n    VecType$1 = ctor;\n    return oldType;\n}\n/**\n * Creates a vec3; may be called with x, y, z to set initial values.\n * @param x - Initial x value.\n * @param y - Initial y value.\n * @param z - Initial z value.\n * @returns the created vector\n */\nfunction create$3(x, y, z) {\n    const dst = new VecType$1(3);\n    if (x !== undefined) {\n        dst[0] = x;\n        if (y !== undefined) {\n            dst[1] = y;\n            if (z !== undefined) {\n                dst[2] = z;\n            }\n        }\n    }\n    return dst;\n}\n\n/*\n * Copyright 2022 Gregg Tavares\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n/**\n * Creates a vec3; may be called with x, y, z to set initial values. (same as create)\n * @param x - Initial x value.\n * @param y - Initial y value.\n * @param z - Initial z value.\n * @returns the created vector\n */\nconst fromValues$2 = create$3;\n/**\n * Applies Math.ceil to each element of vector\n * @param v - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that is the ceil of each element of v.\n */\nfunction ceil$1(v, dst) {\n    dst = dst || new VecType$1(3);\n    dst[0] = Math.ceil(v[0]);\n    dst[1] = Math.ceil(v[1]);\n    dst[2] = Math.ceil(v[2]);\n    return dst;\n}\n/**\n * Applies Math.floor to each element of vector\n * @param v - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that is the floor of each element of v.\n */\nfunction floor$1(v, dst) {\n    dst = dst || new VecType$1(3);\n    dst[0] = Math.floor(v[0]);\n    dst[1] = Math.floor(v[1]);\n    dst[2] = Math.floor(v[2]);\n    return dst;\n}\n/**\n * Applies Math.round to each element of vector\n * @param v - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that is the round of each element of v.\n */\nfunction round$1(v, dst) {\n    dst = dst || new VecType$1(3);\n    dst[0] = Math.round(v[0]);\n    dst[1] = Math.round(v[1]);\n    dst[2] = Math.round(v[2]);\n    return dst;\n}\n/**\n * Clamp each element of vector between min and max\n * @param v - Operand vector.\n * @param max - Min value, default 0\n * @param min - Max value, default 1\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that the clamped value of each element of v.\n */\nfunction clamp$1(v, min = 0, max = 1, dst) {\n    dst = dst || new VecType$1(3);\n    dst[0] = Math.min(max, Math.max(min, v[0]));\n    dst[1] = Math.min(max, Math.max(min, v[1]));\n    dst[2] = Math.min(max, Math.max(min, v[2]));\n    return dst;\n}\n/**\n * Adds two vectors; assumes a and b have the same dimension.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that is the sum of a and b.\n */\nfunction add$2(a, b, dst) {\n    dst = dst || new VecType$1(3);\n    dst[0] = a[0] + b[0];\n    dst[1] = a[1] + b[1];\n    dst[2] = a[2] + b[2];\n    return dst;\n}\n/**\n * Adds two vectors, scaling the 2nd; assumes a and b have the same dimension.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param scale - Amount to scale b\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that is the sum of a + b * scale.\n */\nfunction addScaled$1(a, b, scale, dst) {\n    dst = dst || new VecType$1(3);\n    dst[0] = a[0] + b[0] * scale;\n    dst[1] = a[1] + b[1] * scale;\n    dst[2] = a[2] + b[2] * scale;\n    return dst;\n}\n/**\n * Returns the angle in radians between two vectors.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @returns The angle in radians between the 2 vectors.\n */\nfunction angle$1(a, b) {\n    const ax = a[0];\n    const ay = a[1];\n    const az = a[2];\n    const bx = a[0];\n    const by = a[1];\n    const bz = a[2];\n    const mag1 = Math.sqrt(ax * ax + ay * ay + az * az);\n    const mag2 = Math.sqrt(bx * bx + by * by + bz * bz);\n    const mag = mag1 * mag2;\n    const cosine = mag && dot$2(a, b) / mag;\n    return Math.acos(cosine);\n}\n/**\n * Subtracts two vectors.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that is the difference of a and b.\n */\nfunction subtract$2(a, b, dst) {\n    dst = dst || new VecType$1(3);\n    dst[0] = a[0] - b[0];\n    dst[1] = a[1] - b[1];\n    dst[2] = a[2] - b[2];\n    return dst;\n}\n/**\n * Subtracts two vectors.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that is the difference of a and b.\n */\nconst sub$2 = subtract$2;\n/**\n * Check if 2 vectors are approximately equal\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @returns true if vectors are approximately equal\n */\nfunction equalsApproximately$3(a, b) {\n    return Math.abs(a[0] - b[0]) < EPSILON &&\n        Math.abs(a[1] - b[1]) < EPSILON &&\n        Math.abs(a[2] - b[2]) < EPSILON;\n}\n/**\n * Check if 2 vectors are exactly equal\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @returns true if vectors are exactly equal\n */\nfunction equals$3(a, b) {\n    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];\n}\n/**\n * Performs linear interpolation on two vectors.\n * Given vectors a and b and interpolation coefficient t, returns\n * a + t * (b - a).\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param t - Interpolation coefficient.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The linear interpolated result.\n */\nfunction lerp$2(a, b, t, dst) {\n    dst = dst || new VecType$1(3);\n    dst[0] = a[0] + t * (b[0] - a[0]);\n    dst[1] = a[1] + t * (b[1] - a[1]);\n    dst[2] = a[2] + t * (b[2] - a[2]);\n    return dst;\n}\n/**\n * Performs linear interpolation on two vectors.\n * Given vectors a and b and interpolation coefficient vector t, returns\n * a + t * (b - a).\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param t - Interpolation coefficients vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns the linear interpolated result.\n */\nfunction lerpV$1(a, b, t, dst) {\n    dst = dst || new VecType$1(3);\n    dst[0] = a[0] + t[0] * (b[0] - a[0]);\n    dst[1] = a[1] + t[1] * (b[1] - a[1]);\n    dst[2] = a[2] + t[2] * (b[2] - a[2]);\n    return dst;\n}\n/**\n * Return max values of two vectors.\n * Given vectors a and b returns\n * [max(a[0], b[0]), max(a[1], b[1]), max(a[2], b[2])].\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The max components vector.\n */\nfunction max$1(a, b, dst) {\n    dst = dst || new VecType$1(3);\n    dst[0] = Math.max(a[0], b[0]);\n    dst[1] = Math.max(a[1], b[1]);\n    dst[2] = Math.max(a[2], b[2]);\n    return dst;\n}\n/**\n * Return min values of two vectors.\n * Given vectors a and b returns\n * [min(a[0], b[0]), min(a[1], b[1]), min(a[2], b[2])].\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The min components vector.\n */\nfunction min$1(a, b, dst) {\n    dst = dst || new VecType$1(3);\n    dst[0] = Math.min(a[0], b[0]);\n    dst[1] = Math.min(a[1], b[1]);\n    dst[2] = Math.min(a[2], b[2]);\n    return dst;\n}\n/**\n * Multiplies a vector by a scalar.\n * @param v - The vector.\n * @param k - The scalar.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The scaled vector.\n */\nfunction mulScalar$2(v, k, dst) {\n    dst = dst || new VecType$1(3);\n    dst[0] = v[0] * k;\n    dst[1] = v[1] * k;\n    dst[2] = v[2] * k;\n    return dst;\n}\n/**\n * Multiplies a vector by a scalar. (same as mulScalar)\n * @param v - The vector.\n * @param k - The scalar.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The scaled vector.\n */\nconst scale$3 = mulScalar$2;\n/**\n * Divides a vector by a scalar.\n * @param v - The vector.\n * @param k - The scalar.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The scaled vector.\n */\nfunction divScalar$2(v, k, dst) {\n    dst = dst || new VecType$1(3);\n    dst[0] = v[0] / k;\n    dst[1] = v[1] / k;\n    dst[2] = v[2] / k;\n    return dst;\n}\n/**\n * Inverse a vector.\n * @param v - The vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The inverted vector.\n */\nfunction inverse$3(v, dst) {\n    dst = dst || new VecType$1(3);\n    dst[0] = 1 / v[0];\n    dst[1] = 1 / v[1];\n    dst[2] = 1 / v[2];\n    return dst;\n}\n/**\n * Invert a vector. (same as inverse)\n * @param v - The vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The inverted vector.\n */\nconst invert$2 = inverse$3;\n/**\n * Computes the cross product of two vectors; assumes both vectors have\n * three entries.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The vector of a cross b.\n */\nfunction cross(a, b, dst) {\n    dst = dst || new VecType$1(3);\n    const t1 = a[2] * b[0] - a[0] * b[2];\n    const t2 = a[0] * b[1] - a[1] * b[0];\n    dst[0] = a[1] * b[2] - a[2] * b[1];\n    dst[1] = t1;\n    dst[2] = t2;\n    return dst;\n}\n/**\n * Computes the dot product of two vectors; assumes both vectors have\n * three entries.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @returns dot product\n */\nfunction dot$2(a, b) {\n    return (a[0] * b[0]) + (a[1] * b[1]) + (a[2] * b[2]);\n}\n/**\n * Computes the length of vector\n * @param v - vector.\n * @returns length of vector.\n */\nfunction length$2(v) {\n    const v0 = v[0];\n    const v1 = v[1];\n    const v2 = v[2];\n    return Math.sqrt(v0 * v0 + v1 * v1 + v2 * v2);\n}\n/**\n * Computes the length of vector (same as length)\n * @param v - vector.\n * @returns length of vector.\n */\nconst len$2 = length$2;\n/**\n * Computes the square of the length of vector\n * @param v - vector.\n * @returns square of the length of vector.\n */\nfunction lengthSq$2(v) {\n    const v0 = v[0];\n    const v1 = v[1];\n    const v2 = v[2];\n    return v0 * v0 + v1 * v1 + v2 * v2;\n}\n/**\n * Computes the square of the length of vector (same as lengthSq)\n * @param v - vector.\n * @returns square of the length of vector.\n */\nconst lenSq$2 = lengthSq$2;\n/**\n * Computes the distance between 2 points\n * @param a - vector.\n * @param b - vector.\n * @returns distance between a and b\n */\nfunction distance$1(a, b) {\n    const dx = a[0] - b[0];\n    const dy = a[1] - b[1];\n    const dz = a[2] - b[2];\n    return Math.sqrt(dx * dx + dy * dy + dz * dz);\n}\n/**\n * Computes the distance between 2 points (same as distance)\n * @param a - vector.\n * @param b - vector.\n * @returns distance between a and b\n */\nconst dist$1 = distance$1;\n/**\n * Computes the square of the distance between 2 points\n * @param a - vector.\n * @param b - vector.\n * @returns square of the distance between a and b\n */\nfunction distanceSq$1(a, b) {\n    const dx = a[0] - b[0];\n    const dy = a[1] - b[1];\n    const dz = a[2] - b[2];\n    return dx * dx + dy * dy + dz * dz;\n}\n/**\n * Computes the square of the distance between 2 points (same as distanceSq)\n * @param a - vector.\n * @param b - vector.\n * @returns square of the distance between a and b\n */\nconst distSq$1 = distanceSq$1;\n/**\n * Divides a vector by its Euclidean length and returns the quotient.\n * @param v - The vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The normalized vector.\n */\nfunction normalize$2(v, dst) {\n    dst = dst || new VecType$1(3);\n    const v0 = v[0];\n    const v1 = v[1];\n    const v2 = v[2];\n    const len = Math.sqrt(v0 * v0 + v1 * v1 + v2 * v2);\n    if (len > 0.00001) {\n        dst[0] = v0 / len;\n        dst[1] = v1 / len;\n        dst[2] = v2 / len;\n    }\n    else {\n        dst[0] = 0;\n        dst[1] = 0;\n        dst[2] = 0;\n    }\n    return dst;\n}\n/**\n * Negates a vector.\n * @param v - The vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns -v.\n */\nfunction negate$2(v, dst) {\n    dst = dst || new VecType$1(3);\n    dst[0] = -v[0];\n    dst[1] = -v[1];\n    dst[2] = -v[2];\n    return dst;\n}\n/**\n * Copies a vector. (same as clone)\n * @param v - The vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A copy of v.\n */\nfunction copy$3(v, dst) {\n    dst = dst || new VecType$1(3);\n    dst[0] = v[0];\n    dst[1] = v[1];\n    dst[2] = v[2];\n    return dst;\n}\n/**\n * Clones a vector. (same as copy)\n * @param v - The vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A copy of v.\n */\nconst clone$3 = copy$3;\n/**\n * Multiplies a vector by another vector (component-wise); assumes a and\n * b have the same length.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The vector of products of entries of a and b.\n */\nfunction multiply$3(a, b, dst) {\n    dst = dst || new VecType$1(3);\n    dst[0] = a[0] * b[0];\n    dst[1] = a[1] * b[1];\n    dst[2] = a[2] * b[2];\n    return dst;\n}\n/**\n * Multiplies a vector by another vector (component-wise); assumes a and\n * b have the same length. (same as mul)\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The vector of products of entries of a and b.\n */\nconst mul$3 = multiply$3;\n/**\n * Divides a vector by another vector (component-wise); assumes a and\n * b have the same length.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The vector of quotients of entries of a and b.\n */\nfunction divide$1(a, b, dst) {\n    dst = dst || new VecType$1(3);\n    dst[0] = a[0] / b[0];\n    dst[1] = a[1] / b[1];\n    dst[2] = a[2] / b[2];\n    return dst;\n}\n/**\n * Divides a vector by another vector (component-wise); assumes a and\n * b have the same length. (same as divide)\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The vector of quotients of entries of a and b.\n */\nconst div$1 = divide$1;\n/**\n * Creates a random vector\n * @param scale - Default 1\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The random vector.\n */\nfunction random(scale = 1, dst) {\n    dst = dst || new VecType$1(3);\n    const angle = Math.random() * 2 * Math.PI;\n    const z = Math.random() * 2 - 1;\n    const zScale = Math.sqrt(1 - z * z) * scale;\n    dst[0] = Math.cos(angle) * zScale;\n    dst[1] = Math.sin(angle) * zScale;\n    dst[2] = z * scale;\n    return dst;\n}\n/**\n * Zero's a vector\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The zeroed vector.\n */\nfunction zero$1(dst) {\n    dst = dst || new VecType$1(3);\n    dst[0] = 0;\n    dst[1] = 0;\n    dst[2] = 0;\n    return dst;\n}\n/**\n * transform vec3 by 4x4 matrix\n * @param v - the vector\n * @param m - The matrix.\n * @param dst - optional vec3 to store result. If not passed a new one is created.\n * @returns the transformed vector\n */\nfunction transformMat4$1(v, m, dst) {\n    dst = dst || new VecType$1(3);\n    const x = v[0];\n    const y = v[1];\n    const z = v[2];\n    const w = (m[3] * x + m[7] * y + m[11] * z + m[15]) || 1;\n    dst[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;\n    dst[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;\n    dst[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;\n    return dst;\n}\n/**\n * Transform vec4 by upper 3x3 matrix inside 4x4 matrix.\n * @param v - The direction.\n * @param m - The matrix.\n * @param dst - optional Vec3 to store result. If not passed a new one is created.\n * @returns The transformed vector.\n */\nfunction transformMat4Upper3x3(v, m, dst) {\n    dst = dst || new VecType$1(3);\n    const v0 = v[0];\n    const v1 = v[1];\n    const v2 = v[2];\n    dst[0] = v0 * m[0 * 4 + 0] + v1 * m[1 * 4 + 0] + v2 * m[2 * 4 + 0];\n    dst[1] = v0 * m[0 * 4 + 1] + v1 * m[1 * 4 + 1] + v2 * m[2 * 4 + 1];\n    dst[2] = v0 * m[0 * 4 + 2] + v1 * m[1 * 4 + 2] + v2 * m[2 * 4 + 2];\n    return dst;\n}\n/**\n * Transforms vec4 by 3x3 matrix\n *\n * @param v - the vector\n * @param m - The matrix.\n * @param dst - optional vec3 to store result. If not passed a new one is created.\n * @returns the transformed vector\n */\nfunction transformMat3(v, m, dst) {\n    dst = dst || new VecType$1(3);\n    const x = v[0];\n    const y = v[1];\n    const z = v[2];\n    dst[0] = x * m[0] + y * m[4] + z * m[8];\n    dst[1] = x * m[1] + y * m[5] + z * m[9];\n    dst[2] = x * m[2] + y * m[6] + z * m[10];\n    return dst;\n}\n/**\n * Returns the translation component of a 4-by-4 matrix as a vector with 3\n * entries.\n * @param m - The matrix.\n * @param dst - vector to hold result. If not passed a new one is created.\n * @returns The translation component of m.\n */\nfunction getTranslation$1(m, dst) {\n    dst = dst || new VecType$1(3);\n    dst[0] = m[12];\n    dst[1] = m[13];\n    dst[2] = m[14];\n    return dst;\n}\n/**\n * Returns an axis of a 4x4 matrix as a vector with 3 entries\n * @param m - The matrix.\n * @param axis - The axis 0 = x, 1 = y, 2 = z;\n * @returns The axis component of m.\n */\nfunction getAxis$1(m, axis, dst) {\n    dst = dst || new VecType$1(3);\n    const off = axis * 4;\n    dst[0] = m[off + 0];\n    dst[1] = m[off + 1];\n    dst[2] = m[off + 2];\n    return dst;\n}\n/**\n * Returns the scaling component of the matrix\n * @param m - The Matrix\n * @param dst - The vector to set. If not passed a new one is created.\n */\nfunction getScaling$1(m, dst) {\n    dst = dst || new VecType$1(3);\n    const xx = m[0];\n    const xy = m[1];\n    const xz = m[2];\n    const yx = m[4];\n    const yy = m[5];\n    const yz = m[6];\n    const zx = m[8];\n    const zy = m[9];\n    const zz = m[10];\n    dst[0] = Math.sqrt(xx * xx + xy * xy + xz * xz);\n    dst[1] = Math.sqrt(yx * yx + yy * yy + yz * yz);\n    dst[2] = Math.sqrt(zx * zx + zy * zy + zz * zz);\n    return dst;\n}\n\nvar vec3Impl = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    add: add$2,\n    addScaled: addScaled$1,\n    angle: angle$1,\n    ceil: ceil$1,\n    clamp: clamp$1,\n    clone: clone$3,\n    copy: copy$3,\n    create: create$3,\n    cross: cross,\n    dist: dist$1,\n    distSq: distSq$1,\n    distance: distance$1,\n    distanceSq: distanceSq$1,\n    div: div$1,\n    divScalar: divScalar$2,\n    divide: divide$1,\n    dot: dot$2,\n    equals: equals$3,\n    equalsApproximately: equalsApproximately$3,\n    floor: floor$1,\n    fromValues: fromValues$2,\n    getAxis: getAxis$1,\n    getScaling: getScaling$1,\n    getTranslation: getTranslation$1,\n    inverse: inverse$3,\n    invert: invert$2,\n    len: len$2,\n    lenSq: lenSq$2,\n    length: length$2,\n    lengthSq: lengthSq$2,\n    lerp: lerp$2,\n    lerpV: lerpV$1,\n    max: max$1,\n    min: min$1,\n    mul: mul$3,\n    mulScalar: mulScalar$2,\n    multiply: multiply$3,\n    negate: negate$2,\n    normalize: normalize$2,\n    random: random,\n    round: round$1,\n    scale: scale$3,\n    setDefaultType: setDefaultType$4,\n    sub: sub$2,\n    subtract: subtract$2,\n    transformMat3: transformMat3,\n    transformMat4: transformMat4$1,\n    transformMat4Upper3x3: transformMat4Upper3x3,\n    zero: zero$1\n});\n\n/**\n * 4x4 Matrix math math functions.\n *\n * Almost all functions take an optional `dst` argument. If it is not passed in the\n * functions will create a new matrix. In other words you can do this\n *\n *     const mat = mat4.translation([1, 2, 3]);  // Creates a new translation matrix\n *\n * or\n *\n *     const mat = mat4.create();\n *     mat4.translation([1, 2, 3], mat);  // Puts translation matrix in mat.\n *\n * The first style is often easier but depending on where it's used it generates garbage where\n * as there is almost never allocation with the second style.\n *\n * It is always save to pass any matrix as the destination. So for example\n *\n *     const mat = mat4.identity();\n *     const trans = mat4.translation([1, 2, 3]);\n *     mat4.multiply(mat, trans, mat);  // Multiplies mat * trans and puts result in mat.\n *\n */\nlet MatType = Float32Array;\n/**\n * Sets the type this library creates for a Mat4\n * @param ctor - the constructor for the type. Either `Float32Array`, `Float64Array`, or `Array`\n * @returns previous constructor for Mat4\n */\nfunction setDefaultType$3(ctor) {\n    const oldType = MatType;\n    MatType = ctor;\n    return oldType;\n}\n/**\n * Create a Mat4 from values\n *\n * Note: Since passing in a raw JavaScript array\n * is valid in all circumstances, if you want to\n * force a JavaScript array into a Mat4's specified type\n * it would be faster to use\n *\n * ```\n * const m = mat4.clone(someJSArray);\n * ```\n *\n * Note: a consequence of the implementation is if your Mat4Type = `Array`\n * instead of `Float32Array` or `Float64Array` then any values you\n * don't pass in will be undefined. Usually this is not an issue since\n * (a) using `Array` is rare and (b) using `mat4.create` is usually used\n * to create a Mat4 to be filled out as in\n *\n * ```\n * const m = mat4.create();\n * mat4.perspective(fov, aspect, near, far, m);\n * ```\n *\n * @param v0 - value for element 0\n * @param v1 - value for element 1\n * @param v2 - value for element 2\n * @param v3 - value for element 3\n * @param v4 - value for element 4\n * @param v5 - value for element 5\n * @param v6 - value for element 6\n * @param v7 - value for element 7\n * @param v8 - value for element 8\n * @param v9 - value for element 9\n * @param v10 - value for element 10\n * @param v11 - value for element 11\n * @param v12 - value for element 12\n * @param v13 - value for element 13\n * @param v14 - value for element 14\n * @param v15 - value for element 15\n * @returns created from values.\n */\nfunction create$2(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15) {\n    const dst = new MatType(16);\n    if (v0 !== undefined) {\n        dst[0] = v0;\n        if (v1 !== undefined) {\n            dst[1] = v1;\n            if (v2 !== undefined) {\n                dst[2] = v2;\n                if (v3 !== undefined) {\n                    dst[3] = v3;\n                    if (v4 !== undefined) {\n                        dst[4] = v4;\n                        if (v5 !== undefined) {\n                            dst[5] = v5;\n                            if (v6 !== undefined) {\n                                dst[6] = v6;\n                                if (v7 !== undefined) {\n                                    dst[7] = v7;\n                                    if (v8 !== undefined) {\n                                        dst[8] = v8;\n                                        if (v9 !== undefined) {\n                                            dst[9] = v9;\n                                            if (v10 !== undefined) {\n                                                dst[10] = v10;\n                                                if (v11 !== undefined) {\n                                                    dst[11] = v11;\n                                                    if (v12 !== undefined) {\n                                                        dst[12] = v12;\n                                                        if (v13 !== undefined) {\n                                                            dst[13] = v13;\n                                                            if (v14 !== undefined) {\n                                                                dst[14] = v14;\n                                                                if (v15 !== undefined) {\n                                                                    dst[15] = v15;\n                                                                }\n                                                            }\n                                                        }\n                                                    }\n                                                }\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return dst;\n}\n/**\n * Creates a Mat4 from a Mat3\n * @param m3 - source matrix\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns Mat4 made from m3\n */\nfunction fromMat3(m3, dst) {\n    dst = dst || new MatType(16);\n    dst[0] = m3[0];\n    dst[1] = m3[1];\n    dst[2] = m3[2];\n    dst[3] = 0;\n    dst[4] = m3[4];\n    dst[5] = m3[5];\n    dst[6] = m3[6];\n    dst[7] = 0;\n    dst[8] = m3[8];\n    dst[9] = m3[9];\n    dst[10] = m3[10];\n    dst[11] = 0;\n    dst[12] = 0;\n    dst[13] = 0;\n    dst[14] = 0;\n    dst[15] = 1;\n    return dst;\n}\n/**\n * Creates a Mat4 rotation matrix from a quaternion\n * @param q - quaternion to create matrix from\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns Mat4 made from q\n */\nfunction fromQuat(q, dst) {\n    dst = dst || new MatType(16);\n    const x = q[0];\n    const y = q[1];\n    const z = q[2];\n    const w = q[3];\n    const x2 = x + x;\n    const y2 = y + y;\n    const z2 = z + z;\n    const xx = x * x2;\n    const yx = y * x2;\n    const yy = y * y2;\n    const zx = z * x2;\n    const zy = z * y2;\n    const zz = z * z2;\n    const wx = w * x2;\n    const wy = w * y2;\n    const wz = w * z2;\n    dst[0] = 1 - yy - zz;\n    dst[1] = yx + wz;\n    dst[2] = zx - wy;\n    dst[3] = 0;\n    dst[4] = yx - wz;\n    dst[5] = 1 - xx - zz;\n    dst[6] = zy + wx;\n    dst[7] = 0;\n    dst[8] = zx + wy;\n    dst[9] = zy - wx;\n    dst[10] = 1 - xx - yy;\n    dst[11] = 0;\n    dst[12] = 0;\n    dst[13] = 0;\n    dst[14] = 0;\n    dst[15] = 1;\n    return dst;\n}\n/**\n * Negates a matrix.\n * @param m - The matrix.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns -m.\n */\nfunction negate$1(m, dst) {\n    dst = dst || new MatType(16);\n    dst[0] = -m[0];\n    dst[1] = -m[1];\n    dst[2] = -m[2];\n    dst[3] = -m[3];\n    dst[4] = -m[4];\n    dst[5] = -m[5];\n    dst[6] = -m[6];\n    dst[7] = -m[7];\n    dst[8] = -m[8];\n    dst[9] = -m[9];\n    dst[10] = -m[10];\n    dst[11] = -m[11];\n    dst[12] = -m[12];\n    dst[13] = -m[13];\n    dst[14] = -m[14];\n    dst[15] = -m[15];\n    return dst;\n}\n/**\n * Copies a matrix.\n * @param m - The matrix.\n * @param dst - The matrix. If not passed a new one is created.\n * @returns A copy of m.\n */\nfunction copy$2(m, dst) {\n    dst = dst || new MatType(16);\n    dst[0] = m[0];\n    dst[1] = m[1];\n    dst[2] = m[2];\n    dst[3] = m[3];\n    dst[4] = m[4];\n    dst[5] = m[5];\n    dst[6] = m[6];\n    dst[7] = m[7];\n    dst[8] = m[8];\n    dst[9] = m[9];\n    dst[10] = m[10];\n    dst[11] = m[11];\n    dst[12] = m[12];\n    dst[13] = m[13];\n    dst[14] = m[14];\n    dst[15] = m[15];\n    return dst;\n}\n/**\n * Copies a matrix (same as copy)\n * @param m - The matrix.\n * @param dst - The matrix. If not passed a new one is created.\n * @returns A copy of m.\n */\nconst clone$2 = copy$2;\n/**\n * Check if 2 matrices are approximately equal\n * @param a - Operand matrix.\n * @param b - Operand matrix.\n * @returns true if matrices are approximately equal\n */\nfunction equalsApproximately$2(a, b) {\n    return Math.abs(a[0] - b[0]) < EPSILON &&\n        Math.abs(a[1] - b[1]) < EPSILON &&\n        Math.abs(a[2] - b[2]) < EPSILON &&\n        Math.abs(a[3] - b[3]) < EPSILON &&\n        Math.abs(a[4] - b[4]) < EPSILON &&\n        Math.abs(a[5] - b[5]) < EPSILON &&\n        Math.abs(a[6] - b[6]) < EPSILON &&\n        Math.abs(a[7] - b[7]) < EPSILON &&\n        Math.abs(a[8] - b[8]) < EPSILON &&\n        Math.abs(a[9] - b[9]) < EPSILON &&\n        Math.abs(a[10] - b[10]) < EPSILON &&\n        Math.abs(a[11] - b[11]) < EPSILON &&\n        Math.abs(a[12] - b[12]) < EPSILON &&\n        Math.abs(a[13] - b[13]) < EPSILON &&\n        Math.abs(a[14] - b[14]) < EPSILON &&\n        Math.abs(a[15] - b[15]) < EPSILON;\n}\n/**\n * Check if 2 matrices are exactly equal\n * @param a - Operand matrix.\n * @param b - Operand matrix.\n * @returns true if matrices are exactly equal\n */\nfunction equals$2(a, b) {\n    return a[0] === b[0] &&\n        a[1] === b[1] &&\n        a[2] === b[2] &&\n        a[3] === b[3] &&\n        a[4] === b[4] &&\n        a[5] === b[5] &&\n        a[6] === b[6] &&\n        a[7] === b[7] &&\n        a[8] === b[8] &&\n        a[9] === b[9] &&\n        a[10] === b[10] &&\n        a[11] === b[11] &&\n        a[12] === b[12] &&\n        a[13] === b[13] &&\n        a[14] === b[14] &&\n        a[15] === b[15];\n}\n/**\n * Creates a 4-by-4 identity matrix.\n *\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns A 4-by-4 identity matrix.\n */\nfunction identity$1(dst) {\n    dst = dst || new MatType(16);\n    dst[0] = 1;\n    dst[1] = 0;\n    dst[2] = 0;\n    dst[3] = 0;\n    dst[4] = 0;\n    dst[5] = 1;\n    dst[6] = 0;\n    dst[7] = 0;\n    dst[8] = 0;\n    dst[9] = 0;\n    dst[10] = 1;\n    dst[11] = 0;\n    dst[12] = 0;\n    dst[13] = 0;\n    dst[14] = 0;\n    dst[15] = 1;\n    return dst;\n}\n/**\n * Takes the transpose of a matrix.\n * @param m - The matrix.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The transpose of m.\n */\nfunction transpose(m, dst) {\n    dst = dst || new MatType(16);\n    if (dst === m) {\n        let t;\n        t = m[1];\n        m[1] = m[4];\n        m[4] = t;\n        t = m[2];\n        m[2] = m[8];\n        m[8] = t;\n        t = m[3];\n        m[3] = m[12];\n        m[12] = t;\n        t = m[6];\n        m[6] = m[9];\n        m[9] = t;\n        t = m[7];\n        m[7] = m[13];\n        m[13] = t;\n        t = m[11];\n        m[11] = m[14];\n        m[14] = t;\n        return dst;\n    }\n    const m00 = m[0 * 4 + 0];\n    const m01 = m[0 * 4 + 1];\n    const m02 = m[0 * 4 + 2];\n    const m03 = m[0 * 4 + 3];\n    const m10 = m[1 * 4 + 0];\n    const m11 = m[1 * 4 + 1];\n    const m12 = m[1 * 4 + 2];\n    const m13 = m[1 * 4 + 3];\n    const m20 = m[2 * 4 + 0];\n    const m21 = m[2 * 4 + 1];\n    const m22 = m[2 * 4 + 2];\n    const m23 = m[2 * 4 + 3];\n    const m30 = m[3 * 4 + 0];\n    const m31 = m[3 * 4 + 1];\n    const m32 = m[3 * 4 + 2];\n    const m33 = m[3 * 4 + 3];\n    dst[0] = m00;\n    dst[1] = m10;\n    dst[2] = m20;\n    dst[3] = m30;\n    dst[4] = m01;\n    dst[5] = m11;\n    dst[6] = m21;\n    dst[7] = m31;\n    dst[8] = m02;\n    dst[9] = m12;\n    dst[10] = m22;\n    dst[11] = m32;\n    dst[12] = m03;\n    dst[13] = m13;\n    dst[14] = m23;\n    dst[15] = m33;\n    return dst;\n}\n/**\n * Computes the inverse of a 4-by-4 matrix.\n * @param m - The matrix.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The inverse of m.\n */\nfunction inverse$2(m, dst) {\n    dst = dst || new MatType(16);\n    const m00 = m[0 * 4 + 0];\n    const m01 = m[0 * 4 + 1];\n    const m02 = m[0 * 4 + 2];\n    const m03 = m[0 * 4 + 3];\n    const m10 = m[1 * 4 + 0];\n    const m11 = m[1 * 4 + 1];\n    const m12 = m[1 * 4 + 2];\n    const m13 = m[1 * 4 + 3];\n    const m20 = m[2 * 4 + 0];\n    const m21 = m[2 * 4 + 1];\n    const m22 = m[2 * 4 + 2];\n    const m23 = m[2 * 4 + 3];\n    const m30 = m[3 * 4 + 0];\n    const m31 = m[3 * 4 + 1];\n    const m32 = m[3 * 4 + 2];\n    const m33 = m[3 * 4 + 3];\n    const tmp0 = m22 * m33;\n    const tmp1 = m32 * m23;\n    const tmp2 = m12 * m33;\n    const tmp3 = m32 * m13;\n    const tmp4 = m12 * m23;\n    const tmp5 = m22 * m13;\n    const tmp6 = m02 * m33;\n    const tmp7 = m32 * m03;\n    const tmp8 = m02 * m23;\n    const tmp9 = m22 * m03;\n    const tmp10 = m02 * m13;\n    const tmp11 = m12 * m03;\n    const tmp12 = m20 * m31;\n    const tmp13 = m30 * m21;\n    const tmp14 = m10 * m31;\n    const tmp15 = m30 * m11;\n    const tmp16 = m10 * m21;\n    const tmp17 = m20 * m11;\n    const tmp18 = m00 * m31;\n    const tmp19 = m30 * m01;\n    const tmp20 = m00 * m21;\n    const tmp21 = m20 * m01;\n    const tmp22 = m00 * m11;\n    const tmp23 = m10 * m01;\n    const t0 = (tmp0 * m11 + tmp3 * m21 + tmp4 * m31) -\n        (tmp1 * m11 + tmp2 * m21 + tmp5 * m31);\n    const t1 = (tmp1 * m01 + tmp6 * m21 + tmp9 * m31) -\n        (tmp0 * m01 + tmp7 * m21 + tmp8 * m31);\n    const t2 = (tmp2 * m01 + tmp7 * m11 + tmp10 * m31) -\n        (tmp3 * m01 + tmp6 * m11 + tmp11 * m31);\n    const t3 = (tmp5 * m01 + tmp8 * m11 + tmp11 * m21) -\n        (tmp4 * m01 + tmp9 * m11 + tmp10 * m21);\n    const d = 1 / (m00 * t0 + m10 * t1 + m20 * t2 + m30 * t3);\n    dst[0] = d * t0;\n    dst[1] = d * t1;\n    dst[2] = d * t2;\n    dst[3] = d * t3;\n    dst[4] = d * ((tmp1 * m10 + tmp2 * m20 + tmp5 * m30) -\n        (tmp0 * m10 + tmp3 * m20 + tmp4 * m30));\n    dst[5] = d * ((tmp0 * m00 + tmp7 * m20 + tmp8 * m30) -\n        (tmp1 * m00 + tmp6 * m20 + tmp9 * m30));\n    dst[6] = d * ((tmp3 * m00 + tmp6 * m10 + tmp11 * m30) -\n        (tmp2 * m00 + tmp7 * m10 + tmp10 * m30));\n    dst[7] = d * ((tmp4 * m00 + tmp9 * m10 + tmp10 * m20) -\n        (tmp5 * m00 + tmp8 * m10 + tmp11 * m20));\n    dst[8] = d * ((tmp12 * m13 + tmp15 * m23 + tmp16 * m33) -\n        (tmp13 * m13 + tmp14 * m23 + tmp17 * m33));\n    dst[9] = d * ((tmp13 * m03 + tmp18 * m23 + tmp21 * m33) -\n        (tmp12 * m03 + tmp19 * m23 + tmp20 * m33));\n    dst[10] = d * ((tmp14 * m03 + tmp19 * m13 + tmp22 * m33) -\n        (tmp15 * m03 + tmp18 * m13 + tmp23 * m33));\n    dst[11] = d * ((tmp17 * m03 + tmp20 * m13 + tmp23 * m23) -\n        (tmp16 * m03 + tmp21 * m13 + tmp22 * m23));\n    dst[12] = d * ((tmp14 * m22 + tmp17 * m32 + tmp13 * m12) -\n        (tmp16 * m32 + tmp12 * m12 + tmp15 * m22));\n    dst[13] = d * ((tmp20 * m32 + tmp12 * m02 + tmp19 * m22) -\n        (tmp18 * m22 + tmp21 * m32 + tmp13 * m02));\n    dst[14] = d * ((tmp18 * m12 + tmp23 * m32 + tmp15 * m02) -\n        (tmp22 * m32 + tmp14 * m02 + tmp19 * m12));\n    dst[15] = d * ((tmp22 * m22 + tmp16 * m02 + tmp21 * m12) -\n        (tmp20 * m12 + tmp23 * m22 + tmp17 * m02));\n    return dst;\n}\n/**\n * Compute the determinant of a matrix\n * @param m - the matrix\n * @returns the determinant\n */\nfunction determinant(m) {\n    const m00 = m[0 * 4 + 0];\n    const m01 = m[0 * 4 + 1];\n    const m02 = m[0 * 4 + 2];\n    const m03 = m[0 * 4 + 3];\n    const m10 = m[1 * 4 + 0];\n    const m11 = m[1 * 4 + 1];\n    const m12 = m[1 * 4 + 2];\n    const m13 = m[1 * 4 + 3];\n    const m20 = m[2 * 4 + 0];\n    const m21 = m[2 * 4 + 1];\n    const m22 = m[2 * 4 + 2];\n    const m23 = m[2 * 4 + 3];\n    const m30 = m[3 * 4 + 0];\n    const m31 = m[3 * 4 + 1];\n    const m32 = m[3 * 4 + 2];\n    const m33 = m[3 * 4 + 3];\n    const tmp0 = m22 * m33;\n    const tmp1 = m32 * m23;\n    const tmp2 = m12 * m33;\n    const tmp3 = m32 * m13;\n    const tmp4 = m12 * m23;\n    const tmp5 = m22 * m13;\n    const tmp6 = m02 * m33;\n    const tmp7 = m32 * m03;\n    const tmp8 = m02 * m23;\n    const tmp9 = m22 * m03;\n    const tmp10 = m02 * m13;\n    const tmp11 = m12 * m03;\n    const t0 = (tmp0 * m11 + tmp3 * m21 + tmp4 * m31) -\n        (tmp1 * m11 + tmp2 * m21 + tmp5 * m31);\n    const t1 = (tmp1 * m01 + tmp6 * m21 + tmp9 * m31) -\n        (tmp0 * m01 + tmp7 * m21 + tmp8 * m31);\n    const t2 = (tmp2 * m01 + tmp7 * m11 + tmp10 * m31) -\n        (tmp3 * m01 + tmp6 * m11 + tmp11 * m31);\n    const t3 = (tmp5 * m01 + tmp8 * m11 + tmp11 * m21) -\n        (tmp4 * m01 + tmp9 * m11 + tmp10 * m21);\n    return m00 * t0 + m10 * t1 + m20 * t2 + m30 * t3;\n}\n/**\n * Computes the inverse of a 4-by-4 matrix. (same as inverse)\n * @param m - The matrix.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The inverse of m.\n */\nconst invert$1 = inverse$2;\n/**\n * Multiplies two 4-by-4 matrices with a on the left and b on the right\n * @param a - The matrix on the left.\n * @param b - The matrix on the right.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The matrix product of a and b.\n */\nfunction multiply$2(a, b, dst) {\n    dst = dst || new MatType(16);\n    const a00 = a[0];\n    const a01 = a[1];\n    const a02 = a[2];\n    const a03 = a[3];\n    const a10 = a[4 + 0];\n    const a11 = a[4 + 1];\n    const a12 = a[4 + 2];\n    const a13 = a[4 + 3];\n    const a20 = a[8 + 0];\n    const a21 = a[8 + 1];\n    const a22 = a[8 + 2];\n    const a23 = a[8 + 3];\n    const a30 = a[12 + 0];\n    const a31 = a[12 + 1];\n    const a32 = a[12 + 2];\n    const a33 = a[12 + 3];\n    const b00 = b[0];\n    const b01 = b[1];\n    const b02 = b[2];\n    const b03 = b[3];\n    const b10 = b[4 + 0];\n    const b11 = b[4 + 1];\n    const b12 = b[4 + 2];\n    const b13 = b[4 + 3];\n    const b20 = b[8 + 0];\n    const b21 = b[8 + 1];\n    const b22 = b[8 + 2];\n    const b23 = b[8 + 3];\n    const b30 = b[12 + 0];\n    const b31 = b[12 + 1];\n    const b32 = b[12 + 2];\n    const b33 = b[12 + 3];\n    dst[0] = a00 * b00 + a10 * b01 + a20 * b02 + a30 * b03;\n    dst[1] = a01 * b00 + a11 * b01 + a21 * b02 + a31 * b03;\n    dst[2] = a02 * b00 + a12 * b01 + a22 * b02 + a32 * b03;\n    dst[3] = a03 * b00 + a13 * b01 + a23 * b02 + a33 * b03;\n    dst[4] = a00 * b10 + a10 * b11 + a20 * b12 + a30 * b13;\n    dst[5] = a01 * b10 + a11 * b11 + a21 * b12 + a31 * b13;\n    dst[6] = a02 * b10 + a12 * b11 + a22 * b12 + a32 * b13;\n    dst[7] = a03 * b10 + a13 * b11 + a23 * b12 + a33 * b13;\n    dst[8] = a00 * b20 + a10 * b21 + a20 * b22 + a30 * b23;\n    dst[9] = a01 * b20 + a11 * b21 + a21 * b22 + a31 * b23;\n    dst[10] = a02 * b20 + a12 * b21 + a22 * b22 + a32 * b23;\n    dst[11] = a03 * b20 + a13 * b21 + a23 * b22 + a33 * b23;\n    dst[12] = a00 * b30 + a10 * b31 + a20 * b32 + a30 * b33;\n    dst[13] = a01 * b30 + a11 * b31 + a21 * b32 + a31 * b33;\n    dst[14] = a02 * b30 + a12 * b31 + a22 * b32 + a32 * b33;\n    dst[15] = a03 * b30 + a13 * b31 + a23 * b32 + a33 * b33;\n    return dst;\n}\n/**\n * Multiplies two 4-by-4 matrices with a on the left and b on the right (same as multiply)\n * @param a - The matrix on the left.\n * @param b - The matrix on the right.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The matrix product of a and b.\n */\nconst mul$2 = multiply$2;\n/**\n * Sets the translation component of a 4-by-4 matrix to the given\n * vector.\n * @param a - The matrix.\n * @param v - The vector.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The matrix with translation set.\n */\nfunction setTranslation(a, v, dst) {\n    dst = dst || identity$1();\n    if (a !== dst) {\n        dst[0] = a[0];\n        dst[1] = a[1];\n        dst[2] = a[2];\n        dst[3] = a[3];\n        dst[4] = a[4];\n        dst[5] = a[5];\n        dst[6] = a[6];\n        dst[7] = a[7];\n        dst[8] = a[8];\n        dst[9] = a[9];\n        dst[10] = a[10];\n        dst[11] = a[11];\n    }\n    dst[12] = v[0];\n    dst[13] = v[1];\n    dst[14] = v[2];\n    dst[15] = 1;\n    return dst;\n}\n/**\n * Returns the translation component of a 4-by-4 matrix as a vector with 3\n * entries.\n * @param m - The matrix.\n * @param dst - vector to hold result. If not passed a new one is created.\n * @returns The translation component of m.\n */\nfunction getTranslation(m, dst) {\n    dst = dst || create$3();\n    dst[0] = m[12];\n    dst[1] = m[13];\n    dst[2] = m[14];\n    return dst;\n}\n/**\n * Returns an axis of a 4x4 matrix as a vector with 3 entries\n * @param m - The matrix.\n * @param axis - The axis 0 = x, 1 = y, 2 = z;\n * @returns The axis component of m.\n */\nfunction getAxis(m, axis, dst) {\n    dst = dst || create$3();\n    const off = axis * 4;\n    dst[0] = m[off + 0];\n    dst[1] = m[off + 1];\n    dst[2] = m[off + 2];\n    return dst;\n}\n/**\n * Sets an axis of a 4x4 matrix as a vector with 3 entries\n * @param m - The matrix.\n * @param v - the axis vector\n * @param axis - The axis  0 = x, 1 = y, 2 = z;\n * @param dst - The matrix to set. If not passed a new one is created.\n * @returns The matrix with axis set.\n */\nfunction setAxis(a, v, axis, dst) {\n    if (dst !== a) {\n        dst = copy$2(a, dst);\n    }\n    const off = axis * 4;\n    dst[off + 0] = v[0];\n    dst[off + 1] = v[1];\n    dst[off + 2] = v[2];\n    return dst;\n}\n/**\n * Returns the scaling component of the matrix\n * @param m - The Matrix\n * @param dst - The vector to set. If not passed a new one is created.\n */\nfunction getScaling(m, dst) {\n    dst = dst || create$3();\n    const xx = m[0];\n    const xy = m[1];\n    const xz = m[2];\n    const yx = m[4];\n    const yy = m[5];\n    const yz = m[6];\n    const zx = m[8];\n    const zy = m[9];\n    const zz = m[10];\n    dst[0] = Math.sqrt(xx * xx + xy * xy + xz * xz);\n    dst[1] = Math.sqrt(yx * yx + yy * yy + yz * yz);\n    dst[2] = Math.sqrt(zx * zx + zy * zy + zz * zz);\n    return dst;\n}\n/**\n * Computes a 4-by-4 perspective transformation matrix given the angular height\n * of the frustum, the aspect ratio, and the near and far clipping planes.  The\n * arguments define a frustum extending in the negative z direction.  The given\n * angle is the vertical angle of the frustum, and the horizontal angle is\n * determined to produce the given aspect ratio.  The arguments near and far are\n * the distances to the near and far clipping planes.  Note that near and far\n * are not z coordinates, but rather they are distances along the negative\n * z-axis.  The matrix generated sends the viewing frustum to the unit box.\n * We assume a unit box extending from -1 to 1 in the x and y dimensions and\n * from 0 to 1 in the z dimension.\n *\n * Note: If you pass `Infinity` for zFar then it will produce a projection matrix\n * returns -Infinity for Z when transforming coordinates with Z <= 0 and +Infinity for Z\n * otherwise.\n *\n * @param fieldOfViewYInRadians - The camera angle from top to bottom (in radians).\n * @param aspect - The aspect ratio width / height.\n * @param zNear - The depth (negative z coordinate)\n *     of the near clipping plane.\n * @param zFar - The depth (negative z coordinate)\n *     of the far clipping plane.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The perspective matrix.\n */\nfunction perspective(fieldOfViewYInRadians, aspect, zNear, zFar, dst) {\n    dst = dst || new MatType(16);\n    const f = Math.tan(Math.PI * 0.5 - 0.5 * fieldOfViewYInRadians);\n    dst[0] = f / aspect;\n    dst[1] = 0;\n    dst[2] = 0;\n    dst[3] = 0;\n    dst[4] = 0;\n    dst[5] = f;\n    dst[6] = 0;\n    dst[7] = 0;\n    dst[8] = 0;\n    dst[9] = 0;\n    dst[11] = -1;\n    dst[12] = 0;\n    dst[13] = 0;\n    dst[15] = 0;\n    if (zFar === Infinity) {\n        dst[10] = -1;\n        dst[14] = -zNear;\n    }\n    else {\n        const rangeInv = 1 / (zNear - zFar);\n        dst[10] = zFar * rangeInv;\n        dst[14] = zFar * zNear * rangeInv;\n    }\n    return dst;\n}\n/**\n * Computes a 4-by-4 orthogonal transformation matrix that transforms from\n * the given the left, right, bottom, and top dimensions to -1 +1 in x, and y\n * and 0 to +1 in z.\n * @param left - Left side of the near clipping plane viewport.\n * @param right - Right side of the near clipping plane viewport.\n * @param bottom - Bottom of the near clipping plane viewport.\n * @param top - Top of the near clipping plane viewport.\n * @param near - The depth (negative z coordinate)\n *     of the near clipping plane.\n * @param far - The depth (negative z coordinate)\n *     of the far clipping plane.\n * @param dst - Output matrix. If not passed a new one is created.\n * @returns The orthographic projection matrix.\n */\nfunction ortho(left, right, bottom, top, near, far, dst) {\n    dst = dst || new MatType(16);\n    dst[0] = 2 / (right - left);\n    dst[1] = 0;\n    dst[2] = 0;\n    dst[3] = 0;\n    dst[4] = 0;\n    dst[5] = 2 / (top - bottom);\n    dst[6] = 0;\n    dst[7] = 0;\n    dst[8] = 0;\n    dst[9] = 0;\n    dst[10] = 1 / (near - far);\n    dst[11] = 0;\n    dst[12] = (right + left) / (left - right);\n    dst[13] = (top + bottom) / (bottom - top);\n    dst[14] = near / (near - far);\n    dst[15] = 1;\n    return dst;\n}\n/**\n * Computes a 4-by-4 perspective transformation matrix given the left, right,\n * top, bottom, near and far clipping planes. The arguments define a frustum\n * extending in the negative z direction. The arguments near and far are the\n * distances to the near and far clipping planes. Note that near and far are not\n * z coordinates, but rather they are distances along the negative z-axis. The\n * matrix generated sends the viewing frustum to the unit box. We assume a unit\n * box extending from -1 to 1 in the x and y dimensions and from 0 to 1 in the z\n * dimension.\n * @param left - The x coordinate of the left plane of the box.\n * @param right - The x coordinate of the right plane of the box.\n * @param bottom - The y coordinate of the bottom plane of the box.\n * @param top - The y coordinate of the right plane of the box.\n * @param near - The negative z coordinate of the near plane of the box.\n * @param far - The negative z coordinate of the far plane of the box.\n * @param dst - Output matrix. If not passed a new one is created.\n * @returns The perspective projection matrix.\n */\nfunction frustum(left, right, bottom, top, near, far, dst) {\n    dst = dst || new MatType(16);\n    const dx = (right - left);\n    const dy = (top - bottom);\n    const dz = (near - far);\n    dst[0] = 2 * near / dx;\n    dst[1] = 0;\n    dst[2] = 0;\n    dst[3] = 0;\n    dst[4] = 0;\n    dst[5] = 2 * near / dy;\n    dst[6] = 0;\n    dst[7] = 0;\n    dst[8] = (left + right) / dx;\n    dst[9] = (top + bottom) / dy;\n    dst[10] = far / dz;\n    dst[11] = -1;\n    dst[12] = 0;\n    dst[13] = 0;\n    dst[14] = near * far / dz;\n    dst[15] = 0;\n    return dst;\n}\nlet xAxis;\nlet yAxis;\nlet zAxis;\n/**\n * Computes a 4-by-4 aim transformation.\n *\n * This is a matrix which positions an object aiming down positive Z.\n * toward the target.\n *\n * Note: this is **NOT** the inverse of lookAt as lookAt looks at negative Z.\n *\n * @param position - The position of the object.\n * @param target - The position meant to be aimed at.\n * @param up - A vector pointing up.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The aim matrix.\n */\nfunction aim(position, target, up, dst) {\n    dst = dst || new MatType(16);\n    xAxis = xAxis || create$3();\n    yAxis = yAxis || create$3();\n    zAxis = zAxis || create$3();\n    normalize$2(subtract$2(target, position, zAxis), zAxis);\n    normalize$2(cross(up, zAxis, xAxis), xAxis);\n    normalize$2(cross(zAxis, xAxis, yAxis), yAxis);\n    dst[0] = xAxis[0];\n    dst[1] = xAxis[1];\n    dst[2] = xAxis[2];\n    dst[3] = 0;\n    dst[4] = yAxis[0];\n    dst[5] = yAxis[1];\n    dst[6] = yAxis[2];\n    dst[7] = 0;\n    dst[8] = zAxis[0];\n    dst[9] = zAxis[1];\n    dst[10] = zAxis[2];\n    dst[11] = 0;\n    dst[12] = position[0];\n    dst[13] = position[1];\n    dst[14] = position[2];\n    dst[15] = 1;\n    return dst;\n}\n/**\n * Computes a 4-by-4 camera aim transformation.\n *\n * This is a matrix which positions an object aiming down negative Z.\n * toward the target.\n *\n * Note: this is the inverse of `lookAt`\n *\n * @param eye - The position of the object.\n * @param target - The position meant to be aimed at.\n * @param up - A vector pointing up.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The aim matrix.\n */\nfunction cameraAim(eye, target, up, dst) {\n    dst = dst || new MatType(16);\n    xAxis = xAxis || create$3();\n    yAxis = yAxis || create$3();\n    zAxis = zAxis || create$3();\n    normalize$2(subtract$2(eye, target, zAxis), zAxis);\n    normalize$2(cross(up, zAxis, xAxis), xAxis);\n    normalize$2(cross(zAxis, xAxis, yAxis), yAxis);\n    dst[0] = xAxis[0];\n    dst[1] = xAxis[1];\n    dst[2] = xAxis[2];\n    dst[3] = 0;\n    dst[4] = yAxis[0];\n    dst[5] = yAxis[1];\n    dst[6] = yAxis[2];\n    dst[7] = 0;\n    dst[8] = zAxis[0];\n    dst[9] = zAxis[1];\n    dst[10] = zAxis[2];\n    dst[11] = 0;\n    dst[12] = eye[0];\n    dst[13] = eye[1];\n    dst[14] = eye[2];\n    dst[15] = 1;\n    return dst;\n}\n/**\n * Computes a 4-by-4 view transformation.\n *\n * This is a view matrix which transforms all other objects\n * to be in the space of the view defined by the parameters.\n *\n * @param eye - The position of the object.\n * @param target - The position meant to be aimed at.\n * @param up - A vector pointing up.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The look-at matrix.\n */\nfunction lookAt(eye, target, up, dst) {\n    dst = dst || new MatType(16);\n    xAxis = xAxis || create$3();\n    yAxis = yAxis || create$3();\n    zAxis = zAxis || create$3();\n    normalize$2(subtract$2(eye, target, zAxis), zAxis);\n    normalize$2(cross(up, zAxis, xAxis), xAxis);\n    normalize$2(cross(zAxis, xAxis, yAxis), yAxis);\n    dst[0] = xAxis[0];\n    dst[1] = yAxis[0];\n    dst[2] = zAxis[0];\n    dst[3] = 0;\n    dst[4] = xAxis[1];\n    dst[5] = yAxis[1];\n    dst[6] = zAxis[1];\n    dst[7] = 0;\n    dst[8] = xAxis[2];\n    dst[9] = yAxis[2];\n    dst[10] = zAxis[2];\n    dst[11] = 0;\n    dst[12] = -(xAxis[0] * eye[0] + xAxis[1] * eye[1] + xAxis[2] * eye[2]);\n    dst[13] = -(yAxis[0] * eye[0] + yAxis[1] * eye[1] + yAxis[2] * eye[2]);\n    dst[14] = -(zAxis[0] * eye[0] + zAxis[1] * eye[1] + zAxis[2] * eye[2]);\n    dst[15] = 1;\n    return dst;\n}\n/**\n * Creates a 4-by-4 matrix which translates by the given vector v.\n * @param v - The vector by\n *     which to translate.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The translation matrix.\n */\nfunction translation(v, dst) {\n    dst = dst || new MatType(16);\n    dst[0] = 1;\n    dst[1] = 0;\n    dst[2] = 0;\n    dst[3] = 0;\n    dst[4] = 0;\n    dst[5] = 1;\n    dst[6] = 0;\n    dst[7] = 0;\n    dst[8] = 0;\n    dst[9] = 0;\n    dst[10] = 1;\n    dst[11] = 0;\n    dst[12] = v[0];\n    dst[13] = v[1];\n    dst[14] = v[2];\n    dst[15] = 1;\n    return dst;\n}\n/**\n * Translates the given 4-by-4 matrix by the given vector v.\n * @param m - The matrix.\n * @param v - The vector by\n *     which to translate.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The translated matrix.\n */\nfunction translate(m, v, dst) {\n    dst = dst || new MatType(16);\n    const v0 = v[0];\n    const v1 = v[1];\n    const v2 = v[2];\n    const m00 = m[0];\n    const m01 = m[1];\n    const m02 = m[2];\n    const m03 = m[3];\n    const m10 = m[1 * 4 + 0];\n    const m11 = m[1 * 4 + 1];\n    const m12 = m[1 * 4 + 2];\n    const m13 = m[1 * 4 + 3];\n    const m20 = m[2 * 4 + 0];\n    const m21 = m[2 * 4 + 1];\n    const m22 = m[2 * 4 + 2];\n    const m23 = m[2 * 4 + 3];\n    const m30 = m[3 * 4 + 0];\n    const m31 = m[3 * 4 + 1];\n    const m32 = m[3 * 4 + 2];\n    const m33 = m[3 * 4 + 3];\n    if (m !== dst) {\n        dst[0] = m00;\n        dst[1] = m01;\n        dst[2] = m02;\n        dst[3] = m03;\n        dst[4] = m10;\n        dst[5] = m11;\n        dst[6] = m12;\n        dst[7] = m13;\n        dst[8] = m20;\n        dst[9] = m21;\n        dst[10] = m22;\n        dst[11] = m23;\n    }\n    dst[12] = m00 * v0 + m10 * v1 + m20 * v2 + m30;\n    dst[13] = m01 * v0 + m11 * v1 + m21 * v2 + m31;\n    dst[14] = m02 * v0 + m12 * v1 + m22 * v2 + m32;\n    dst[15] = m03 * v0 + m13 * v1 + m23 * v2 + m33;\n    return dst;\n}\n/**\n * Creates a 4-by-4 matrix which rotates around the x-axis by the given angle.\n * @param angleInRadians - The angle by which to rotate (in radians).\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The rotation matrix.\n */\nfunction rotationX(angleInRadians, dst) {\n    dst = dst || new MatType(16);\n    const c = Math.cos(angleInRadians);\n    const s = Math.sin(angleInRadians);\n    dst[0] = 1;\n    dst[1] = 0;\n    dst[2] = 0;\n    dst[3] = 0;\n    dst[4] = 0;\n    dst[5] = c;\n    dst[6] = s;\n    dst[7] = 0;\n    dst[8] = 0;\n    dst[9] = -s;\n    dst[10] = c;\n    dst[11] = 0;\n    dst[12] = 0;\n    dst[13] = 0;\n    dst[14] = 0;\n    dst[15] = 1;\n    return dst;\n}\n/**\n * Rotates the given 4-by-4 matrix around the x-axis by the given\n * angle.\n * @param m - The matrix.\n * @param angleInRadians - The angle by which to rotate (in radians).\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The rotated matrix.\n */\nfunction rotateX$1(m, angleInRadians, dst) {\n    dst = dst || new MatType(16);\n    const m10 = m[4];\n    const m11 = m[5];\n    const m12 = m[6];\n    const m13 = m[7];\n    const m20 = m[8];\n    const m21 = m[9];\n    const m22 = m[10];\n    const m23 = m[11];\n    const c = Math.cos(angleInRadians);\n    const s = Math.sin(angleInRadians);\n    dst[4] = c * m10 + s * m20;\n    dst[5] = c * m11 + s * m21;\n    dst[6] = c * m12 + s * m22;\n    dst[7] = c * m13 + s * m23;\n    dst[8] = c * m20 - s * m10;\n    dst[9] = c * m21 - s * m11;\n    dst[10] = c * m22 - s * m12;\n    dst[11] = c * m23 - s * m13;\n    if (m !== dst) {\n        dst[0] = m[0];\n        dst[1] = m[1];\n        dst[2] = m[2];\n        dst[3] = m[3];\n        dst[12] = m[12];\n        dst[13] = m[13];\n        dst[14] = m[14];\n        dst[15] = m[15];\n    }\n    return dst;\n}\n/**\n * Creates a 4-by-4 matrix which rotates around the y-axis by the given angle.\n * @param angleInRadians - The angle by which to rotate (in radians).\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The rotation matrix.\n */\nfunction rotationY(angleInRadians, dst) {\n    dst = dst || new MatType(16);\n    const c = Math.cos(angleInRadians);\n    const s = Math.sin(angleInRadians);\n    dst[0] = c;\n    dst[1] = 0;\n    dst[2] = -s;\n    dst[3] = 0;\n    dst[4] = 0;\n    dst[5] = 1;\n    dst[6] = 0;\n    dst[7] = 0;\n    dst[8] = s;\n    dst[9] = 0;\n    dst[10] = c;\n    dst[11] = 0;\n    dst[12] = 0;\n    dst[13] = 0;\n    dst[14] = 0;\n    dst[15] = 1;\n    return dst;\n}\n/**\n * Rotates the given 4-by-4 matrix around the y-axis by the given\n * angle.\n * @param m - The matrix.\n * @param angleInRadians - The angle by which to rotate (in radians).\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The rotated matrix.\n */\nfunction rotateY$1(m, angleInRadians, dst) {\n    dst = dst || new MatType(16);\n    const m00 = m[0 * 4 + 0];\n    const m01 = m[0 * 4 + 1];\n    const m02 = m[0 * 4 + 2];\n    const m03 = m[0 * 4 + 3];\n    const m20 = m[2 * 4 + 0];\n    const m21 = m[2 * 4 + 1];\n    const m22 = m[2 * 4 + 2];\n    const m23 = m[2 * 4 + 3];\n    const c = Math.cos(angleInRadians);\n    const s = Math.sin(angleInRadians);\n    dst[0] = c * m00 - s * m20;\n    dst[1] = c * m01 - s * m21;\n    dst[2] = c * m02 - s * m22;\n    dst[3] = c * m03 - s * m23;\n    dst[8] = c * m20 + s * m00;\n    dst[9] = c * m21 + s * m01;\n    dst[10] = c * m22 + s * m02;\n    dst[11] = c * m23 + s * m03;\n    if (m !== dst) {\n        dst[4] = m[4];\n        dst[5] = m[5];\n        dst[6] = m[6];\n        dst[7] = m[7];\n        dst[12] = m[12];\n        dst[13] = m[13];\n        dst[14] = m[14];\n        dst[15] = m[15];\n    }\n    return dst;\n}\n/**\n * Creates a 4-by-4 matrix which rotates around the z-axis by the given angle.\n * @param angleInRadians - The angle by which to rotate (in radians).\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The rotation matrix.\n */\nfunction rotationZ(angleInRadians, dst) {\n    dst = dst || new MatType(16);\n    const c = Math.cos(angleInRadians);\n    const s = Math.sin(angleInRadians);\n    dst[0] = c;\n    dst[1] = s;\n    dst[2] = 0;\n    dst[3] = 0;\n    dst[4] = -s;\n    dst[5] = c;\n    dst[6] = 0;\n    dst[7] = 0;\n    dst[8] = 0;\n    dst[9] = 0;\n    dst[10] = 1;\n    dst[11] = 0;\n    dst[12] = 0;\n    dst[13] = 0;\n    dst[14] = 0;\n    dst[15] = 1;\n    return dst;\n}\n/**\n * Rotates the given 4-by-4 matrix around the z-axis by the given\n * angle.\n * @param m - The matrix.\n * @param angleInRadians - The angle by which to rotate (in radians).\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The rotated matrix.\n */\nfunction rotateZ$1(m, angleInRadians, dst) {\n    dst = dst || new MatType(16);\n    const m00 = m[0 * 4 + 0];\n    const m01 = m[0 * 4 + 1];\n    const m02 = m[0 * 4 + 2];\n    const m03 = m[0 * 4 + 3];\n    const m10 = m[1 * 4 + 0];\n    const m11 = m[1 * 4 + 1];\n    const m12 = m[1 * 4 + 2];\n    const m13 = m[1 * 4 + 3];\n    const c = Math.cos(angleInRadians);\n    const s = Math.sin(angleInRadians);\n    dst[0] = c * m00 + s * m10;\n    dst[1] = c * m01 + s * m11;\n    dst[2] = c * m02 + s * m12;\n    dst[3] = c * m03 + s * m13;\n    dst[4] = c * m10 - s * m00;\n    dst[5] = c * m11 - s * m01;\n    dst[6] = c * m12 - s * m02;\n    dst[7] = c * m13 - s * m03;\n    if (m !== dst) {\n        dst[8] = m[8];\n        dst[9] = m[9];\n        dst[10] = m[10];\n        dst[11] = m[11];\n        dst[12] = m[12];\n        dst[13] = m[13];\n        dst[14] = m[14];\n        dst[15] = m[15];\n    }\n    return dst;\n}\n/**\n * Creates a 4-by-4 matrix which rotates around the given axis by the given\n * angle.\n * @param axis - The axis\n *     about which to rotate.\n * @param angleInRadians - The angle by which to rotate (in radians).\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns A matrix which rotates angle radians\n *     around the axis.\n */\nfunction axisRotation(axis, angleInRadians, dst) {\n    dst = dst || new MatType(16);\n    let x = axis[0];\n    let y = axis[1];\n    let z = axis[2];\n    const n = Math.sqrt(x * x + y * y + z * z);\n    x /= n;\n    y /= n;\n    z /= n;\n    const xx = x * x;\n    const yy = y * y;\n    const zz = z * z;\n    const c = Math.cos(angleInRadians);\n    const s = Math.sin(angleInRadians);\n    const oneMinusCosine = 1 - c;\n    dst[0] = xx + (1 - xx) * c;\n    dst[1] = x * y * oneMinusCosine + z * s;\n    dst[2] = x * z * oneMinusCosine - y * s;\n    dst[3] = 0;\n    dst[4] = x * y * oneMinusCosine - z * s;\n    dst[5] = yy + (1 - yy) * c;\n    dst[6] = y * z * oneMinusCosine + x * s;\n    dst[7] = 0;\n    dst[8] = x * z * oneMinusCosine + y * s;\n    dst[9] = y * z * oneMinusCosine - x * s;\n    dst[10] = zz + (1 - zz) * c;\n    dst[11] = 0;\n    dst[12] = 0;\n    dst[13] = 0;\n    dst[14] = 0;\n    dst[15] = 1;\n    return dst;\n}\n/**\n * Creates a 4-by-4 matrix which rotates around the given axis by the given\n * angle. (same as axisRotation)\n * @param axis - The axis\n *     about which to rotate.\n * @param angleInRadians - The angle by which to rotate (in radians).\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns A matrix which rotates angle radians\n *     around the axis.\n */\nconst rotation = axisRotation;\n/**\n * Rotates the given 4-by-4 matrix around the given axis by the\n * given angle.\n * @param m - The matrix.\n * @param axis - The axis\n *     about which to rotate.\n * @param angleInRadians - The angle by which to rotate (in radians).\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The rotated matrix.\n */\nfunction axisRotate(m, axis, angleInRadians, dst) {\n    dst = dst || new MatType(16);\n    let x = axis[0];\n    let y = axis[1];\n    let z = axis[2];\n    const n = Math.sqrt(x * x + y * y + z * z);\n    x /= n;\n    y /= n;\n    z /= n;\n    const xx = x * x;\n    const yy = y * y;\n    const zz = z * z;\n    const c = Math.cos(angleInRadians);\n    const s = Math.sin(angleInRadians);\n    const oneMinusCosine = 1 - c;\n    const r00 = xx + (1 - xx) * c;\n    const r01 = x * y * oneMinusCosine + z * s;\n    const r02 = x * z * oneMinusCosine - y * s;\n    const r10 = x * y * oneMinusCosine - z * s;\n    const r11 = yy + (1 - yy) * c;\n    const r12 = y * z * oneMinusCosine + x * s;\n    const r20 = x * z * oneMinusCosine + y * s;\n    const r21 = y * z * oneMinusCosine - x * s;\n    const r22 = zz + (1 - zz) * c;\n    const m00 = m[0];\n    const m01 = m[1];\n    const m02 = m[2];\n    const m03 = m[3];\n    const m10 = m[4];\n    const m11 = m[5];\n    const m12 = m[6];\n    const m13 = m[7];\n    const m20 = m[8];\n    const m21 = m[9];\n    const m22 = m[10];\n    const m23 = m[11];\n    dst[0] = r00 * m00 + r01 * m10 + r02 * m20;\n    dst[1] = r00 * m01 + r01 * m11 + r02 * m21;\n    dst[2] = r00 * m02 + r01 * m12 + r02 * m22;\n    dst[3] = r00 * m03 + r01 * m13 + r02 * m23;\n    dst[4] = r10 * m00 + r11 * m10 + r12 * m20;\n    dst[5] = r10 * m01 + r11 * m11 + r12 * m21;\n    dst[6] = r10 * m02 + r11 * m12 + r12 * m22;\n    dst[7] = r10 * m03 + r11 * m13 + r12 * m23;\n    dst[8] = r20 * m00 + r21 * m10 + r22 * m20;\n    dst[9] = r20 * m01 + r21 * m11 + r22 * m21;\n    dst[10] = r20 * m02 + r21 * m12 + r22 * m22;\n    dst[11] = r20 * m03 + r21 * m13 + r22 * m23;\n    if (m !== dst) {\n        dst[12] = m[12];\n        dst[13] = m[13];\n        dst[14] = m[14];\n        dst[15] = m[15];\n    }\n    return dst;\n}\n/**\n * Rotates the given 4-by-4 matrix around the given axis by the\n * given angle. (same as rotate)\n * @param m - The matrix.\n * @param axis - The axis\n *     about which to rotate.\n * @param angleInRadians - The angle by which to rotate (in radians).\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The rotated matrix.\n */\nconst rotate = axisRotate;\n/**\n * Creates a 4-by-4 matrix which scales in each dimension by an amount given by\n * the corresponding entry in the given vector; assumes the vector has three\n * entries.\n * @param v - A vector of\n *     three entries specifying the factor by which to scale in each dimension.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The scaling matrix.\n */\nfunction scaling(v, dst) {\n    dst = dst || new MatType(16);\n    dst[0] = v[0];\n    dst[1] = 0;\n    dst[2] = 0;\n    dst[3] = 0;\n    dst[4] = 0;\n    dst[5] = v[1];\n    dst[6] = 0;\n    dst[7] = 0;\n    dst[8] = 0;\n    dst[9] = 0;\n    dst[10] = v[2];\n    dst[11] = 0;\n    dst[12] = 0;\n    dst[13] = 0;\n    dst[14] = 0;\n    dst[15] = 1;\n    return dst;\n}\n/**\n * Scales the given 4-by-4 matrix in each dimension by an amount\n * given by the corresponding entry in the given vector; assumes the vector has\n * three entries.\n * @param m - The matrix to be modified.\n * @param v - A vector of three entries specifying the\n *     factor by which to scale in each dimension.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The scaled matrix.\n */\nfunction scale$2(m, v, dst) {\n    dst = dst || new MatType(16);\n    const v0 = v[0];\n    const v1 = v[1];\n    const v2 = v[2];\n    dst[0] = v0 * m[0 * 4 + 0];\n    dst[1] = v0 * m[0 * 4 + 1];\n    dst[2] = v0 * m[0 * 4 + 2];\n    dst[3] = v0 * m[0 * 4 + 3];\n    dst[4] = v1 * m[1 * 4 + 0];\n    dst[5] = v1 * m[1 * 4 + 1];\n    dst[6] = v1 * m[1 * 4 + 2];\n    dst[7] = v1 * m[1 * 4 + 3];\n    dst[8] = v2 * m[2 * 4 + 0];\n    dst[9] = v2 * m[2 * 4 + 1];\n    dst[10] = v2 * m[2 * 4 + 2];\n    dst[11] = v2 * m[2 * 4 + 3];\n    if (m !== dst) {\n        dst[12] = m[12];\n        dst[13] = m[13];\n        dst[14] = m[14];\n        dst[15] = m[15];\n    }\n    return dst;\n}\n\nvar mat4Impl = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    aim: aim,\n    axisRotate: axisRotate,\n    axisRotation: axisRotation,\n    cameraAim: cameraAim,\n    clone: clone$2,\n    copy: copy$2,\n    create: create$2,\n    determinant: determinant,\n    equals: equals$2,\n    equalsApproximately: equalsApproximately$2,\n    fromMat3: fromMat3,\n    fromQuat: fromQuat,\n    frustum: frustum,\n    getAxis: getAxis,\n    getScaling: getScaling,\n    getTranslation: getTranslation,\n    identity: identity$1,\n    inverse: inverse$2,\n    invert: invert$1,\n    lookAt: lookAt,\n    mul: mul$2,\n    multiply: multiply$2,\n    negate: negate$1,\n    ortho: ortho,\n    perspective: perspective,\n    rotate: rotate,\n    rotateX: rotateX$1,\n    rotateY: rotateY$1,\n    rotateZ: rotateZ$1,\n    rotation: rotation,\n    rotationX: rotationX,\n    rotationY: rotationY,\n    rotationZ: rotationZ,\n    scale: scale$2,\n    scaling: scaling,\n    setAxis: setAxis,\n    setDefaultType: setDefaultType$3,\n    setTranslation: setTranslation,\n    translate: translate,\n    translation: translation,\n    transpose: transpose\n});\n\n/**\n *\n * Quat4 math functions.\n *\n * Almost all functions take an optional `dst` argument. If it is not passed in the\n * functions will create a new `Quat4`. In other words you can do this\n *\n *     const v = quat4.cross(v1, v2);  // Creates a new Quat4 with the cross product of v1 x v2.\n *\n * or\n *\n *     const v = quat4.create();\n *     quat4.cross(v1, v2, v);  // Puts the cross product of v1 x v2 in v\n *\n * The first style is often easier but depending on where it's used it generates garbage where\n * as there is almost never allocation with the second style.\n *\n * It is always safe to pass any vector as the destination. So for example\n *\n *     quat4.cross(v1, v2, v1);  // Puts the cross product of v1 x v2 in v1\n *\n */\nlet QuatType = Float32Array;\n/**\n * Sets the type this library creates for a Quat4\n * @param ctor - the constructor for the type. Either `Float32Array`, `Float64Array`, or `Array`\n * @returns previous constructor for Quat4\n */\nfunction setDefaultType$2(ctor) {\n    const oldType = QuatType;\n    QuatType = ctor;\n    return oldType;\n}\n/**\n * Creates a quat4; may be called with x, y, z to set initial values.\n * @param x - Initial x value.\n * @param y - Initial y value.\n * @param z - Initial z value.\n * @param w - Initial w value.\n * @returns the created vector\n */\nfunction create$1(x, y, z, w) {\n    const dst = new QuatType(4);\n    if (x !== undefined) {\n        dst[0] = x;\n        if (y !== undefined) {\n            dst[1] = y;\n            if (z !== undefined) {\n                dst[2] = z;\n                if (w !== undefined) {\n                    dst[3] = w;\n                }\n            }\n        }\n    }\n    return dst;\n}\n\n/*\n * Copyright 2022 Gregg Tavares\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n/**\n * Creates a Quat; may be called with x, y, z to set initial values. (same as create)\n * @param x - Initial x value.\n * @param y - Initial y value.\n * @param z - Initial z value.\n * @param z - Initial w value.\n * @returns the created vector\n */\nconst fromValues$1 = create$1;\n/**\n * Sets a quaternion from the given angle and  axis,\n * then returns it.\n *\n * @param axis - the axis to rotate around\n * @param angleInRadians - the angle\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns The quaternion that represents the given axis and angle\n **/\nfunction fromAxisAngle(axis, angleInRadians, dst) {\n    dst = dst || new QuatType(4);\n    const halfAngle = angleInRadians * 0.5;\n    const s = Math.sin(halfAngle);\n    dst[0] = s * axis[0];\n    dst[1] = s * axis[1];\n    dst[2] = s * axis[2];\n    dst[3] = Math.cos(halfAngle);\n    return dst;\n}\n/**\n * Gets the rotation axis and angle\n * @param q - quaternion to compute from\n * @param dst - Vec3 to hold result. If not passed in a new one is created.\n * @return angle and axis\n */\nfunction toAxisAngle(q, dst) {\n    dst = dst || create$3(4);\n    const angle = Math.acos(q[3]) * 2;\n    const s = Math.sin(angle * 0.5);\n    if (s > EPSILON) {\n        dst[0] = q[0] / s;\n        dst[1] = q[1] / s;\n        dst[2] = q[2] / s;\n    }\n    else {\n        dst[0] = 1;\n        dst[1] = 0;\n        dst[2] = 0;\n    }\n    return { angle, axis: dst };\n}\n/**\n * Returns the angle in degrees between two rotations a and b.\n * @param a - quaternion a\n * @param b - quaternion b\n * @return angle in radians between the two quaternions\n */\nfunction angle(a, b) {\n    const d = dot$1(a, b);\n    return Math.acos(2 * d * d - 1);\n}\n/**\n * Multiplies two quaternions\n *\n * @param a - the first quaternion\n * @param b - the second quaternion\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns A quaternion that is the result of a * b\n */\nfunction multiply$1(a, b, dst) {\n    dst = dst || new QuatType(4);\n    const ax = a[0];\n    const ay = a[1];\n    const az = a[2];\n    const aw = a[3];\n    const bx = b[0];\n    const by = b[1];\n    const bz = b[2];\n    const bw = b[3];\n    dst[0] = ax * bw + aw * bx + ay * bz - az * by;\n    dst[1] = ay * bw + aw * by + az * bx - ax * bz;\n    dst[2] = az * bw + aw * bz + ax * by - ay * bx;\n    dst[3] = aw * bw - ax * bx - ay * by - az * bz;\n    return dst;\n}\n/**\n * Multiplies two quaternions\n *\n * @param a - the first quaternion\n * @param b - the second quaternion\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns A quaternion that is the result of a * b\n */\nconst mul$1 = multiply$1;\n/**\n * Rotates the given quaternion around the X axis by the given angle.\n * @param q - quaternion to rotate\n * @param angleInRadians - The angle by which to rotate\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns A quaternion that is the result of a * b\n */\nfunction rotateX(q, angleInRadians, dst) {\n    dst = dst || new QuatType(4);\n    const halfAngle = angleInRadians * 0.5;\n    const qx = q[0];\n    const qy = q[1];\n    const qz = q[2];\n    const qw = q[3];\n    const bx = Math.sin(halfAngle);\n    const bw = Math.cos(halfAngle);\n    dst[0] = qx * bw + qw * bx;\n    dst[1] = qy * bw + qz * bx;\n    dst[2] = qz * bw - qy * bx;\n    dst[3] = qw * bw - qx * bx;\n    return dst;\n}\n/**\n * Rotates the given quaternion around the Y axis by the given angle.\n * @param q - quaternion to rotate\n * @param angleInRadians - The angle by which to rotate\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns A quaternion that is the result of a * b\n */\nfunction rotateY(q, angleInRadians, dst) {\n    dst = dst || new QuatType(4);\n    const halfAngle = angleInRadians * 0.5;\n    const qx = q[0];\n    const qy = q[1];\n    const qz = q[2];\n    const qw = q[3];\n    const by = Math.sin(halfAngle);\n    const bw = Math.cos(halfAngle);\n    dst[0] = qx * bw - qz * by;\n    dst[1] = qy * bw + qw * by;\n    dst[2] = qz * bw + qx * by;\n    dst[3] = qw * bw - qy * by;\n    return dst;\n}\n/**\n * Rotates the given quaternion around the Z axis by the given angle.\n * @param q - quaternion to rotate\n * @param angleInRadians - The angle by which to rotate\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns A quaternion that is the result of a * b\n */\nfunction rotateZ(q, angleInRadians, dst) {\n    dst = dst || new QuatType(4);\n    const halfAngle = angleInRadians * 0.5;\n    const qx = q[0];\n    const qy = q[1];\n    const qz = q[2];\n    const qw = q[3];\n    const bz = Math.sin(halfAngle);\n    const bw = Math.cos(halfAngle);\n    dst[0] = qx * bw + qy * bz;\n    dst[1] = qy * bw - qx * bz;\n    dst[2] = qz * bw + qw * bz;\n    dst[3] = qw * bw - qz * bz;\n    return dst;\n}\n/**\n * Spherically linear interpolate between two quaternions\n *\n * @param a - starting value\n * @param b - ending value\n * @param t - value where 0 = a and 1 = b\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns A quaternion that is the result of a * b\n */\nfunction slerp(a, b, t, dst) {\n    dst = dst || new QuatType(4);\n    const ax = a[0];\n    const ay = a[1];\n    const az = a[2];\n    const aw = a[3];\n    let bx = b[0];\n    let by = b[1];\n    let bz = b[2];\n    let bw = b[3];\n    let cosOmega = ax * bx + ay * by + az * bz + aw * bw;\n    if (cosOmega < 0) {\n        cosOmega = -cosOmega;\n        bx = -bx;\n        by = -by;\n        bz = -bz;\n        bw = -bw;\n    }\n    let scale0;\n    let scale1;\n    if (1.0 - cosOmega > EPSILON) {\n        const omega = Math.acos(cosOmega);\n        const sinOmega = Math.sin(omega);\n        scale0 = Math.sin((1 - t) * omega) / sinOmega;\n        scale1 = Math.sin(t * omega) / sinOmega;\n    }\n    else {\n        scale0 = 1.0 - t;\n        scale1 = t;\n    }\n    dst[0] = scale0 * ax + scale1 * bx;\n    dst[1] = scale0 * ay + scale1 * by;\n    dst[2] = scale0 * az + scale1 * bz;\n    dst[3] = scale0 * aw + scale1 * bw;\n    return dst;\n}\n/**\n * Compute the inverse of a quaternion\n *\n * @param q - quaternion to compute the inverse of\n * @returns A quaternion that is the result of a * b\n */\nfunction inverse$1(q, dst) {\n    dst = dst || new QuatType(4);\n    const a0 = q[0];\n    const a1 = q[1];\n    const a2 = q[2];\n    const a3 = q[3];\n    const dot = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3;\n    const invDot = dot ? 1 / dot : 0;\n    dst[0] = -a0 * invDot;\n    dst[1] = -a1 * invDot;\n    dst[2] = -a2 * invDot;\n    dst[3] = a3 * invDot;\n    return dst;\n}\n/**\n * Compute the conjugate of a quaternion\n * For quaternions with a magnitude of 1 (a unit quaternion)\n * this returns the same as the inverse but is faster to calculate.\n *\n * @param q - quaternion to compute the conjugate of.\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns The conjugate of q\n */\nfunction conjugate(q, dst) {\n    dst = dst || new QuatType(4);\n    dst[0] = -q[0];\n    dst[1] = -q[1];\n    dst[2] = -q[2];\n    dst[3] = q[3];\n    return dst;\n}\n/**\n * Creates a quaternion from the given rotation matrix.\n *\n * The created quaternion is not normalized.\n *\n * @param m - rotation matrix\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns the result\n */\nfunction fromMat(m, dst) {\n    dst = dst || new QuatType(4);\n    /*\n    0 1 2\n    3 4 5\n    6 7 8\n  \n    0 1 2\n    4 5 6\n    8 9 10\n     */\n    // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes\n    // article \"Quaternion Calculus and Fast Animation\".\n    const trace = m[0] + m[5] + m[10];\n    if (trace > 0.0) {\n        // |w| > 1/2, may as well choose w > 1/2\n        const root = Math.sqrt(trace + 1); // 2w\n        dst[3] = 0.5 * root;\n        const invRoot = 0.5 / root; // 1/(4w)\n        dst[0] = (m[6] - m[9]) * invRoot;\n        dst[1] = (m[8] - m[2]) * invRoot;\n        dst[2] = (m[1] - m[4]) * invRoot;\n    }\n    else {\n        // |w| <= 1/2\n        let i = 0;\n        if (m[5] > m[0]) {\n            i = 1;\n        }\n        if (m[10] > m[i * 4 + i]) {\n            i = 2;\n        }\n        const j = (i + 1) % 3;\n        const k = (i + 2) % 3;\n        const root = Math.sqrt(m[i * 4 + i] - m[j * 4 + j] - m[k * 4 + k] + 1.0);\n        dst[i] = 0.5 * root;\n        const invRoot = 0.5 / root;\n        dst[3] = (m[j * 4 + k] - m[k * 4 + j]) * invRoot;\n        dst[j] = (m[j * 4 + i] + m[i * 4 + j]) * invRoot;\n        dst[k] = (m[k * 4 + i] + m[i * 4 + k]) * invRoot;\n    }\n    return dst;\n}\n/**\n * Creates a quaternion from the given euler angle x, y, z using the provided intrinsic order for the conversion.\n *\n * @param xAngleInRadians - angle to rotate around X axis in radians.\n * @param yAngleInRadians - angle to rotate around Y axis in radians.\n * @param zAngleInRadians - angle to rotate around Z axis in radians.\n * @param order - order to apply euler angles\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns A quaternion representing the same rotation as the euler angles applied in the given order\n */\nfunction fromEuler(xAngleInRadians, yAngleInRadians, zAngleInRadians, order, dst) {\n    dst = dst || new QuatType(4);\n    const xHalfAngle = xAngleInRadians * 0.5;\n    const yHalfAngle = yAngleInRadians * 0.5;\n    const zHalfAngle = zAngleInRadians * 0.5;\n    const sx = Math.sin(xHalfAngle);\n    const cx = Math.cos(xHalfAngle);\n    const sy = Math.sin(yHalfAngle);\n    const cy = Math.cos(yHalfAngle);\n    const sz = Math.sin(zHalfAngle);\n    const cz = Math.cos(zHalfAngle);\n    switch (order) {\n        case 'xyz':\n            dst[0] = sx * cy * cz + cx * sy * sz;\n            dst[1] = cx * sy * cz - sx * cy * sz;\n            dst[2] = cx * cy * sz + sx * sy * cz;\n            dst[3] = cx * cy * cz - sx * sy * sz;\n            break;\n        case 'xzy':\n            dst[0] = sx * cy * cz - cx * sy * sz;\n            dst[1] = cx * sy * cz - sx * cy * sz;\n            dst[2] = cx * cy * sz + sx * sy * cz;\n            dst[3] = cx * cy * cz + sx * sy * sz;\n            break;\n        case 'yxz':\n            dst[0] = sx * cy * cz + cx * sy * sz;\n            dst[1] = cx * sy * cz - sx * cy * sz;\n            dst[2] = cx * cy * sz - sx * sy * cz;\n            dst[3] = cx * cy * cz + sx * sy * sz;\n            break;\n        case 'yzx':\n            dst[0] = sx * cy * cz + cx * sy * sz;\n            dst[1] = cx * sy * cz + sx * cy * sz;\n            dst[2] = cx * cy * sz - sx * sy * cz;\n            dst[3] = cx * cy * cz - sx * sy * sz;\n            break;\n        case 'zxy':\n            dst[0] = sx * cy * cz - cx * sy * sz;\n            dst[1] = cx * sy * cz + sx * cy * sz;\n            dst[2] = cx * cy * sz + sx * sy * cz;\n            dst[3] = cx * cy * cz - sx * sy * sz;\n            break;\n        case 'zyx':\n            dst[0] = sx * cy * cz - cx * sy * sz;\n            dst[1] = cx * sy * cz + sx * cy * sz;\n            dst[2] = cx * cy * sz - sx * sy * cz;\n            dst[3] = cx * cy * cz + sx * sy * sz;\n            break;\n        default:\n            throw new Error(`Unknown rotation order: ${order}`);\n    }\n    return dst;\n}\n/**\n * Copies a quaternion. (same as clone)\n * @param q - The quaternion.\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns A quaternion that is a copy of q\n */\nfunction copy$1(q, dst) {\n    dst = dst || new QuatType(4);\n    dst[0] = q[0];\n    dst[1] = q[1];\n    dst[2] = q[2];\n    dst[3] = q[3];\n    return dst;\n}\n/**\n * Clones a quaternion. (same as copy)\n * @param q - The quaternion.\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns A copy of q.\n */\nconst clone$1 = copy$1;\n/**\n * Adds two quaternions; assumes a and b have the same dimension.\n * @param a - Operand quaternion.\n * @param b - Operand quaternion.\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns A quaternion that is the sum of a and b.\n */\nfunction add$1(a, b, dst) {\n    dst = dst || new QuatType(4);\n    dst[0] = a[0] + b[0];\n    dst[1] = a[1] + b[1];\n    dst[2] = a[2] + b[2];\n    dst[3] = a[3] + b[3];\n    return dst;\n}\n/**\n * Subtracts two quaternions.\n * @param a - Operand quaternion.\n * @param b - Operand quaternion.\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns A quaternion that is the difference of a and b.\n */\nfunction subtract$1(a, b, dst) {\n    dst = dst || new QuatType(4);\n    dst[0] = a[0] - b[0];\n    dst[1] = a[1] - b[1];\n    dst[2] = a[2] - b[2];\n    dst[3] = a[3] - b[3];\n    return dst;\n}\n/**\n * Subtracts two quaternions.\n * @param a - Operand quaternion.\n * @param b - Operand quaternion.\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns A quaternion that is the difference of a and b.\n */\nconst sub$1 = subtract$1;\n/**\n * Multiplies a quaternion by a scalar.\n * @param v - The quaternion.\n * @param k - The scalar.\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns The scaled quaternion.\n */\nfunction mulScalar$1(v, k, dst) {\n    dst = dst || new QuatType(4);\n    dst[0] = v[0] * k;\n    dst[1] = v[1] * k;\n    dst[2] = v[2] * k;\n    dst[3] = v[3] * k;\n    return dst;\n}\n/**\n * Multiplies a quaternion by a scalar. (same as mulScalar)\n * @param v - The quaternion.\n * @param k - The scalar.\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns The scaled quaternion.\n */\nconst scale$1 = mulScalar$1;\n/**\n * Divides a vector by a scalar.\n * @param v - The vector.\n * @param k - The scalar.\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns The scaled quaternion.\n */\nfunction divScalar$1(v, k, dst) {\n    dst = dst || new QuatType(4);\n    dst[0] = v[0] / k;\n    dst[1] = v[1] / k;\n    dst[2] = v[2] / k;\n    dst[3] = v[3] / k;\n    return dst;\n}\n/**\n * Computes the dot product of two quaternions\n * @param a - Operand quaternion.\n * @param b - Operand quaternion.\n * @returns dot product\n */\nfunction dot$1(a, b) {\n    return (a[0] * b[0]) + (a[1] * b[1]) + (a[2] * b[2]) + (a[3] * b[3]);\n}\n/**\n * Performs linear interpolation on two quaternions.\n * Given quaternions a and b and interpolation coefficient t, returns\n * a + t * (b - a).\n * @param a - Operand quaternion.\n * @param b - Operand quaternion.\n * @param t - Interpolation coefficient.\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns The linear interpolated result.\n */\nfunction lerp$1(a, b, t, dst) {\n    dst = dst || new QuatType(4);\n    dst[0] = a[0] + t * (b[0] - a[0]);\n    dst[1] = a[1] + t * (b[1] - a[1]);\n    dst[2] = a[2] + t * (b[2] - a[2]);\n    dst[3] = a[3] + t * (b[3] - a[3]);\n    return dst;\n}\n/**\n * Computes the length of quaternion\n * @param v - quaternion.\n * @returns length of quaternion.\n */\nfunction length$1(v) {\n    const v0 = v[0];\n    const v1 = v[1];\n    const v2 = v[2];\n    const v3 = v[3];\n    return Math.sqrt(v0 * v0 + v1 * v1 + v2 * v2 + v3 * v3);\n}\n/**\n * Computes the length of quaternion (same as length)\n * @param v - quaternion.\n * @returns length of quaternion.\n */\nconst len$1 = length$1;\n/**\n * Computes the square of the length of quaternion\n * @param v - quaternion.\n * @returns square of the length of quaternion.\n */\nfunction lengthSq$1(v) {\n    const v0 = v[0];\n    const v1 = v[1];\n    const v2 = v[2];\n    const v3 = v[3];\n    return v0 * v0 + v1 * v1 + v2 * v2 + v3 * v3;\n}\n/**\n * Computes the square of the length of quaternion (same as lengthSq)\n * @param v - quaternion.\n * @returns square of the length of quaternion.\n */\nconst lenSq$1 = lengthSq$1;\n/**\n * Divides a quaternion by its Euclidean length and returns the quotient.\n * @param v - The quaternion.\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns The normalized quaternion.\n */\nfunction normalize$1(v, dst) {\n    dst = dst || new QuatType(4);\n    const v0 = v[0];\n    const v1 = v[1];\n    const v2 = v[2];\n    const v3 = v[3];\n    const len = Math.sqrt(v0 * v0 + v1 * v1 + v2 * v2 + v3 * v3);\n    if (len > 0.00001) {\n        dst[0] = v0 / len;\n        dst[1] = v1 / len;\n        dst[2] = v2 / len;\n        dst[3] = v3 / len;\n    }\n    else {\n        dst[0] = 0;\n        dst[1] = 0;\n        dst[2] = 0;\n        dst[3] = 0;\n    }\n    return dst;\n}\n/**\n * Check if 2 quaternions are approximately equal\n * @param a - Operand quaternion.\n * @param b - Operand quaternion.\n * @returns true if quaternions are approximately equal\n */\nfunction equalsApproximately$1(a, b) {\n    return Math.abs(a[0] - b[0]) < EPSILON &&\n        Math.abs(a[1] - b[1]) < EPSILON &&\n        Math.abs(a[2] - b[2]) < EPSILON &&\n        Math.abs(a[3] - b[3]) < EPSILON;\n}\n/**\n * Check if 2 quaternions are exactly equal\n * @param a - Operand quaternion.\n * @param b - Operand quaternion.\n * @returns true if quaternions are exactly equal\n */\nfunction equals$1(a, b) {\n    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];\n}\n/**\n * Creates an identity quaternion\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns an identity quaternion\n */\nfunction identity(dst) {\n    dst = dst || new QuatType(4);\n    dst[0] = 0;\n    dst[1] = 0;\n    dst[2] = 0;\n    dst[3] = 1;\n    return dst;\n}\nlet tempVec3;\nlet xUnitVec3;\nlet yUnitVec3;\n/**\n * Computes a quaternion to represent the shortest rotation from one vector to another.\n *\n * @param aUnit - the start vector\n * @param bUnit - the end vector\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns the result\n */\nfunction rotationTo(aUnit, bUnit, dst) {\n    dst = dst || new QuatType(4);\n    tempVec3 = tempVec3 || create$3();\n    xUnitVec3 = xUnitVec3 || create$3(1, 0, 0);\n    yUnitVec3 = yUnitVec3 || create$3(0, 1, 0);\n    const dot = dot$2(aUnit, bUnit);\n    if (dot < -0.999999) {\n        cross(xUnitVec3, aUnit, tempVec3);\n        if (len$2(tempVec3) < 0.000001) {\n            cross(yUnitVec3, aUnit, tempVec3);\n        }\n        normalize$2(tempVec3, tempVec3);\n        fromAxisAngle(tempVec3, Math.PI, dst);\n        return dst;\n    }\n    else if (dot > 0.999999) {\n        dst[0] = 0;\n        dst[1] = 0;\n        dst[2] = 0;\n        dst[3] = 1;\n        return dst;\n    }\n    else {\n        cross(aUnit, bUnit, tempVec3);\n        dst[0] = tempVec3[0];\n        dst[1] = tempVec3[1];\n        dst[2] = tempVec3[2];\n        dst[3] = 1 + dot;\n        return normalize$1(dst, dst);\n    }\n}\nlet tempQuat1;\nlet tempQuat2;\n/**\n * Performs a spherical linear interpolation with two control points\n *\n * @param a - the first quaternion\n * @param b - the second quaternion\n * @param c - the third quaternion\n * @param d - the fourth quaternion\n * @param t - Interpolation coefficient 0 to 1\n * @returns result\n */\nfunction sqlerp(a, b, c, d, t, dst) {\n    dst = dst || new QuatType(4);\n    tempQuat1 = tempQuat1 || new QuatType(4);\n    tempQuat2 = tempQuat2 || new QuatType(4);\n    slerp(a, d, t, tempQuat1);\n    slerp(b, c, t, tempQuat2);\n    slerp(tempQuat1, tempQuat2, 2 * t * (1 - t), dst);\n    return dst;\n}\n\nvar quatImpl = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    add: add$1,\n    angle: angle,\n    clone: clone$1,\n    conjugate: conjugate,\n    copy: copy$1,\n    create: create$1,\n    divScalar: divScalar$1,\n    dot: dot$1,\n    equals: equals$1,\n    equalsApproximately: equalsApproximately$1,\n    fromAxisAngle: fromAxisAngle,\n    fromEuler: fromEuler,\n    fromMat: fromMat,\n    fromValues: fromValues$1,\n    identity: identity,\n    inverse: inverse$1,\n    len: len$1,\n    lenSq: lenSq$1,\n    length: length$1,\n    lengthSq: lengthSq$1,\n    lerp: lerp$1,\n    mul: mul$1,\n    mulScalar: mulScalar$1,\n    multiply: multiply$1,\n    normalize: normalize$1,\n    rotateX: rotateX,\n    rotateY: rotateY,\n    rotateZ: rotateZ,\n    rotationTo: rotationTo,\n    scale: scale$1,\n    setDefaultType: setDefaultType$2,\n    slerp: slerp,\n    sqlerp: sqlerp,\n    sub: sub$1,\n    subtract: subtract$1,\n    toAxisAngle: toAxisAngle\n});\n\n/**\n *\n * Vec4 math functions.\n *\n * Almost all functions take an optional `dst` argument. If it is not passed in the\n * functions will create a new `Vec4`. In other words you can do this\n *\n *     const v = vec4.cross(v1, v2);  // Creates a new Vec4 with the cross product of v1 x v2.\n *\n * or\n *\n *     const v = vec4.create();\n *     vec4.cross(v1, v2, v);  // Puts the cross product of v1 x v2 in v\n *\n * The first style is often easier but depending on where it's used it generates garbage where\n * as there is almost never allocation with the second style.\n *\n * It is always safe to pass any vector as the destination. So for example\n *\n *     vec4.cross(v1, v2, v1);  // Puts the cross product of v1 x v2 in v1\n *\n */\nlet VecType = Float32Array;\n/**\n * Sets the type this library creates for a Vec4\n * @param ctor - the constructor for the type. Either `Float32Array`, `Float64Array`, or `Array`\n * @returns previous constructor for Vec4\n */\nfunction setDefaultType$1(ctor) {\n    const oldType = VecType;\n    VecType = ctor;\n    return oldType;\n}\n/**\n * Creates a vec4; may be called with x, y, z to set initial values.\n * @param x - Initial x value.\n * @param y - Initial y value.\n * @param z - Initial z value.\n * @param w - Initial w value.\n * @returns the created vector\n */\nfunction create(x, y, z, w) {\n    const dst = new VecType(4);\n    if (x !== undefined) {\n        dst[0] = x;\n        if (y !== undefined) {\n            dst[1] = y;\n            if (z !== undefined) {\n                dst[2] = z;\n                if (w !== undefined) {\n                    dst[3] = w;\n                }\n            }\n        }\n    }\n    return dst;\n}\n\n/*\n * Copyright 2022 Gregg Tavares\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n/**\n * Creates a vec4; may be called with x, y, z to set initial values. (same as create)\n * @param x - Initial x value.\n * @param y - Initial y value.\n * @param z - Initial z value.\n * @param z - Initial w value.\n * @returns the created vector\n */\nconst fromValues = create;\n/**\n * Applies Math.ceil to each element of vector\n * @param v - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that is the ceil of each element of v.\n */\nfunction ceil(v, dst) {\n    dst = dst || new VecType(4);\n    dst[0] = Math.ceil(v[0]);\n    dst[1] = Math.ceil(v[1]);\n    dst[2] = Math.ceil(v[2]);\n    dst[3] = Math.ceil(v[3]);\n    return dst;\n}\n/**\n * Applies Math.floor to each element of vector\n * @param v - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that is the floor of each element of v.\n */\nfunction floor(v, dst) {\n    dst = dst || new VecType(4);\n    dst[0] = Math.floor(v[0]);\n    dst[1] = Math.floor(v[1]);\n    dst[2] = Math.floor(v[2]);\n    dst[3] = Math.floor(v[3]);\n    return dst;\n}\n/**\n * Applies Math.round to each element of vector\n * @param v - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that is the round of each element of v.\n */\nfunction round(v, dst) {\n    dst = dst || new VecType(4);\n    dst[0] = Math.round(v[0]);\n    dst[1] = Math.round(v[1]);\n    dst[2] = Math.round(v[2]);\n    dst[3] = Math.round(v[3]);\n    return dst;\n}\n/**\n * Clamp each element of vector between min and max\n * @param v - Operand vector.\n * @param max - Min value, default 0\n * @param min - Max value, default 1\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that the clamped value of each element of v.\n */\nfunction clamp(v, min = 0, max = 1, dst) {\n    dst = dst || new VecType(4);\n    dst[0] = Math.min(max, Math.max(min, v[0]));\n    dst[1] = Math.min(max, Math.max(min, v[1]));\n    dst[2] = Math.min(max, Math.max(min, v[2]));\n    dst[3] = Math.min(max, Math.max(min, v[3]));\n    return dst;\n}\n/**\n * Adds two vectors; assumes a and b have the same dimension.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that is the sum of a and b.\n */\nfunction add(a, b, dst) {\n    dst = dst || new VecType(4);\n    dst[0] = a[0] + b[0];\n    dst[1] = a[1] + b[1];\n    dst[2] = a[2] + b[2];\n    dst[3] = a[3] + b[3];\n    return dst;\n}\n/**\n * Adds two vectors, scaling the 2nd; assumes a and b have the same dimension.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param scale - Amount to scale b\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that is the sum of a + b * scale.\n */\nfunction addScaled(a, b, scale, dst) {\n    dst = dst || new VecType(4);\n    dst[0] = a[0] + b[0] * scale;\n    dst[1] = a[1] + b[1] * scale;\n    dst[2] = a[2] + b[2] * scale;\n    dst[3] = a[3] + b[3] * scale;\n    return dst;\n}\n/**\n * Subtracts two vectors.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that is the difference of a and b.\n */\nfunction subtract(a, b, dst) {\n    dst = dst || new VecType(4);\n    dst[0] = a[0] - b[0];\n    dst[1] = a[1] - b[1];\n    dst[2] = a[2] - b[2];\n    dst[3] = a[3] - b[3];\n    return dst;\n}\n/**\n * Subtracts two vectors.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that is the difference of a and b.\n */\nconst sub = subtract;\n/**\n * Check if 2 vectors are approximately equal\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @returns true if vectors are approximately equal\n */\nfunction equalsApproximately(a, b) {\n    return Math.abs(a[0] - b[0]) < EPSILON &&\n        Math.abs(a[1] - b[1]) < EPSILON &&\n        Math.abs(a[2] - b[2]) < EPSILON &&\n        Math.abs(a[3] - b[3]) < EPSILON;\n}\n/**\n * Check if 2 vectors are exactly equal\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @returns true if vectors are exactly equal\n */\nfunction equals(a, b) {\n    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];\n}\n/**\n * Performs linear interpolation on two vectors.\n * Given vectors a and b and interpolation coefficient t, returns\n * a + t * (b - a).\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param t - Interpolation coefficient.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The linear interpolated result.\n */\nfunction lerp(a, b, t, dst) {\n    dst = dst || new VecType(4);\n    dst[0] = a[0] + t * (b[0] - a[0]);\n    dst[1] = a[1] + t * (b[1] - a[1]);\n    dst[2] = a[2] + t * (b[2] - a[2]);\n    dst[3] = a[3] + t * (b[3] - a[3]);\n    return dst;\n}\n/**\n * Performs linear interpolation on two vectors.\n * Given vectors a and b and interpolation coefficient vector t, returns\n * a + t * (b - a).\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param t - Interpolation coefficients vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns the linear interpolated result.\n */\nfunction lerpV(a, b, t, dst) {\n    dst = dst || new VecType(4);\n    dst[0] = a[0] + t[0] * (b[0] - a[0]);\n    dst[1] = a[1] + t[1] * (b[1] - a[1]);\n    dst[2] = a[2] + t[2] * (b[2] - a[2]);\n    dst[3] = a[3] + t[3] * (b[3] - a[3]);\n    return dst;\n}\n/**\n * Return max values of two vectors.\n * Given vectors a and b returns\n * [max(a[0], b[0]), max(a[1], b[1]), max(a[2], b[2])].\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The max components vector.\n */\nfunction max(a, b, dst) {\n    dst = dst || new VecType(4);\n    dst[0] = Math.max(a[0], b[0]);\n    dst[1] = Math.max(a[1], b[1]);\n    dst[2] = Math.max(a[2], b[2]);\n    dst[3] = Math.max(a[3], b[3]);\n    return dst;\n}\n/**\n * Return min values of two vectors.\n * Given vectors a and b returns\n * [min(a[0], b[0]), min(a[1], b[1]), min(a[2], b[2])].\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The min components vector.\n */\nfunction min(a, b, dst) {\n    dst = dst || new VecType(4);\n    dst[0] = Math.min(a[0], b[0]);\n    dst[1] = Math.min(a[1], b[1]);\n    dst[2] = Math.min(a[2], b[2]);\n    dst[3] = Math.min(a[3], b[3]);\n    return dst;\n}\n/**\n * Multiplies a vector by a scalar.\n * @param v - The vector.\n * @param k - The scalar.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The scaled vector.\n */\nfunction mulScalar(v, k, dst) {\n    dst = dst || new VecType(4);\n    dst[0] = v[0] * k;\n    dst[1] = v[1] * k;\n    dst[2] = v[2] * k;\n    dst[3] = v[3] * k;\n    return dst;\n}\n/**\n * Multiplies a vector by a scalar. (same as mulScalar)\n * @param v - The vector.\n * @param k - The scalar.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The scaled vector.\n */\nconst scale = mulScalar;\n/**\n * Divides a vector by a scalar.\n * @param v - The vector.\n * @param k - The scalar.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The scaled vector.\n */\nfunction divScalar(v, k, dst) {\n    dst = dst || new VecType(4);\n    dst[0] = v[0] / k;\n    dst[1] = v[1] / k;\n    dst[2] = v[2] / k;\n    dst[3] = v[3] / k;\n    return dst;\n}\n/**\n * Inverse a vector.\n * @param v - The vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The inverted vector.\n */\nfunction inverse(v, dst) {\n    dst = dst || new VecType(4);\n    dst[0] = 1 / v[0];\n    dst[1] = 1 / v[1];\n    dst[2] = 1 / v[2];\n    dst[3] = 1 / v[3];\n    return dst;\n}\n/**\n * Invert a vector. (same as inverse)\n * @param v - The vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The inverted vector.\n */\nconst invert = inverse;\n/**\n * Computes the dot product of two vectors\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @returns dot product\n */\nfunction dot(a, b) {\n    return (a[0] * b[0]) + (a[1] * b[1]) + (a[2] * b[2]) + (a[3] * b[3]);\n}\n/**\n * Computes the length of vector\n * @param v - vector.\n * @returns length of vector.\n */\nfunction length(v) {\n    const v0 = v[0];\n    const v1 = v[1];\n    const v2 = v[2];\n    const v3 = v[3];\n    return Math.sqrt(v0 * v0 + v1 * v1 + v2 * v2 + v3 * v3);\n}\n/**\n * Computes the length of vector (same as length)\n * @param v - vector.\n * @returns length of vector.\n */\nconst len = length;\n/**\n * Computes the square of the length of vector\n * @param v - vector.\n * @returns square of the length of vector.\n */\nfunction lengthSq(v) {\n    const v0 = v[0];\n    const v1 = v[1];\n    const v2 = v[2];\n    const v3 = v[3];\n    return v0 * v0 + v1 * v1 + v2 * v2 + v3 * v3;\n}\n/**\n * Computes the square of the length of vector (same as lengthSq)\n * @param v - vector.\n * @returns square of the length of vector.\n */\nconst lenSq = lengthSq;\n/**\n * Computes the distance between 2 points\n * @param a - vector.\n * @param b - vector.\n * @returns distance between a and b\n */\nfunction distance(a, b) {\n    const dx = a[0] - b[0];\n    const dy = a[1] - b[1];\n    const dz = a[2] - b[2];\n    const dw = a[3] - b[3];\n    return Math.sqrt(dx * dx + dy * dy + dz * dz + dw * dw);\n}\n/**\n * Computes the distance between 2 points (same as distance)\n * @param a - vector.\n * @param b - vector.\n * @returns distance between a and b\n */\nconst dist = distance;\n/**\n * Computes the square of the distance between 2 points\n * @param a - vector.\n * @param b - vector.\n * @returns square of the distance between a and b\n */\nfunction distanceSq(a, b) {\n    const dx = a[0] - b[0];\n    const dy = a[1] - b[1];\n    const dz = a[2] - b[2];\n    const dw = a[3] - b[3];\n    return dx * dx + dy * dy + dz * dz + dw * dw;\n}\n/**\n * Computes the square of the distance between 2 points (same as distanceSq)\n * @param a - vector.\n * @param b - vector.\n * @returns square of the distance between a and b\n */\nconst distSq = distanceSq;\n/**\n * Divides a vector by its Euclidean length and returns the quotient.\n * @param v - The vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The normalized vector.\n */\nfunction normalize(v, dst) {\n    dst = dst || new VecType(4);\n    const v0 = v[0];\n    const v1 = v[1];\n    const v2 = v[2];\n    const v3 = v[3];\n    const len = Math.sqrt(v0 * v0 + v1 * v1 + v2 * v2 + v3 * v3);\n    if (len > 0.00001) {\n        dst[0] = v0 / len;\n        dst[1] = v1 / len;\n        dst[2] = v2 / len;\n        dst[3] = v3 / len;\n    }\n    else {\n        dst[0] = 0;\n        dst[1] = 0;\n        dst[2] = 0;\n        dst[3] = 0;\n    }\n    return dst;\n}\n/**\n * Negates a vector.\n * @param v - The vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns -v.\n */\nfunction negate(v, dst) {\n    dst = dst || new VecType(4);\n    dst[0] = -v[0];\n    dst[1] = -v[1];\n    dst[2] = -v[2];\n    dst[3] = -v[3];\n    return dst;\n}\n/**\n * Copies a vector. (same as clone)\n * @param v - The vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A copy of v.\n */\nfunction copy(v, dst) {\n    dst = dst || new VecType(4);\n    dst[0] = v[0];\n    dst[1] = v[1];\n    dst[2] = v[2];\n    dst[3] = v[3];\n    return dst;\n}\n/**\n * Clones a vector. (same as copy)\n * @param v - The vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A copy of v.\n */\nconst clone = copy;\n/**\n * Multiplies a vector by another vector (component-wise); assumes a and\n * b have the same length.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The vector of products of entries of a and b.\n */\nfunction multiply(a, b, dst) {\n    dst = dst || new VecType(4);\n    dst[0] = a[0] * b[0];\n    dst[1] = a[1] * b[1];\n    dst[2] = a[2] * b[2];\n    dst[3] = a[3] * b[3];\n    return dst;\n}\n/**\n * Multiplies a vector by another vector (component-wise); assumes a and\n * b have the same length. (same as mul)\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The vector of products of entries of a and b.\n */\nconst mul = multiply;\n/**\n * Divides a vector by another vector (component-wise); assumes a and\n * b have the same length.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The vector of quotients of entries of a and b.\n */\nfunction divide(a, b, dst) {\n    dst = dst || new VecType(4);\n    dst[0] = a[0] / b[0];\n    dst[1] = a[1] / b[1];\n    dst[2] = a[2] / b[2];\n    dst[3] = a[3] / b[3];\n    return dst;\n}\n/**\n * Divides a vector by another vector (component-wise); assumes a and\n * b have the same length. (same as divide)\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The vector of quotients of entries of a and b.\n */\nconst div = divide;\n/**\n * Zero's a vector\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The zeroed vector.\n */\nfunction zero(dst) {\n    dst = dst || new VecType(4);\n    dst[0] = 0;\n    dst[1] = 0;\n    dst[2] = 0;\n    dst[3] = 0;\n    return dst;\n}\n/**\n * transform vec4 by 4x4 matrix\n * @param v - the vector\n * @param m - The matrix.\n * @param dst - optional vec4 to store result. If not passed a new one is created.\n * @returns the transformed vector\n */\nfunction transformMat4(v, m, dst) {\n    dst = dst || new VecType(4);\n    const x = v[0];\n    const y = v[1];\n    const z = v[2];\n    const w = v[3];\n    dst[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;\n    dst[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;\n    dst[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;\n    dst[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;\n    return dst;\n}\n\nvar vec4Impl = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    add: add,\n    addScaled: addScaled,\n    ceil: ceil,\n    clamp: clamp,\n    clone: clone,\n    copy: copy,\n    create: create,\n    dist: dist,\n    distSq: distSq,\n    distance: distance,\n    distanceSq: distanceSq,\n    div: div,\n    divScalar: divScalar,\n    divide: divide,\n    dot: dot,\n    equals: equals,\n    equalsApproximately: equalsApproximately,\n    floor: floor,\n    fromValues: fromValues,\n    inverse: inverse,\n    invert: invert,\n    len: len,\n    lenSq: lenSq,\n    length: length,\n    lengthSq: lengthSq,\n    lerp: lerp,\n    lerpV: lerpV,\n    max: max,\n    min: min,\n    mul: mul,\n    mulScalar: mulScalar,\n    multiply: multiply,\n    negate: negate,\n    normalize: normalize,\n    round: round,\n    scale: scale,\n    setDefaultType: setDefaultType$1,\n    sub: sub,\n    subtract: subtract,\n    transformMat4: transformMat4,\n    zero: zero\n});\n\n/**\n * Sets the type this library creates for all types\n *\n * example:\n *\n * ```\n * setDefaultType(Float64Array);\n * ```\n *\n * @param ctor - the constructor for the type. Either `Float32Array`, `Float64Array`, or `Array`\n */\nfunction setDefaultType(ctor) {\n    setDefaultType$5(ctor);\n    setDefaultType$3(ctor);\n    setDefaultType$2(ctor);\n    setDefaultType$6(ctor);\n    setDefaultType$4(ctor);\n    setDefaultType$1(ctor);\n}\n\nexport { mat3Impl as mat3, mat4Impl as mat4, quatImpl as quat, setDefaultType, arrayLike as types, utils, vec2Impl as vec2, vec3Impl as vec3, vec4Impl as vec4 };\n//# sourceMappingURL=wgpu-matrix.module.js.map\n","import { vec3 } from \"wgpu-matrix\";\nexport class Ray {\n    constructor(origin, direction) {\n        this.origin = origin;\n        this.direction = vec3.normalize(direction);\n        this.inv_direction = [1, 1, 1];\n        vec3.div(this.inv_direction, direction, this.inv_direction);\n    }\n}\nexport class RayHit {\n    constructor(position, voxel_position, voxel, normal) {\n        this.position = position;\n        this.voxel_position = voxel_position;\n        this.voxel = voxel;\n        this.normal = normal;\n    }\n}\nexport class Voxel {\n    constructor() {\n        this.color = vec3.create();\n        this.opacity = 0.0;\n        this.roughness = 1.0;\n        this.lightness = 0.0;\n    }\n}\nexport class MetaVoxel {\n    constructor() {\n        this.gi = vec3.create();\n    }\n}\nexport class Scene {\n    constructor() {\n        this.grid_size = 8;\n        this.voxel_count = 16;\n        this.grid = new Array(this.grid_size * this.grid_size * this.grid_size);\n        this.meta_grid = new Array(this.grid_size * this.grid_size * this.grid_size);\n        this.boundary_min = [\n            -this.grid_size / 2,\n            -this.grid_size / 2,\n            -this.grid_size / 2,\n        ];\n        this.boundary_max = [\n            this.grid_size / 2,\n            this.grid_size / 2,\n            this.grid_size / 2,\n        ];\n        this.voxel_size = this.grid_size / this.voxel_count;\n        this.initialize_grid();\n        this.direct_light = vec3.normalize([1.5, 0.6, 3]);\n        this.direct_light_brightness = 1;\n        this.background_color = [0, 0, 0];\n    }\n    serialize_scene() {\n        // console.log(JSON.stringify(this.grid));\n        return JSON.stringify(this.grid);\n    }\n    deserialize_scene(s) {\n        this.grid = JSON.parse(s);\n    }\n    initialize_grid() {\n        this.grid = new Array(this.voxel_count ** 3);\n        this.meta_grid = new Array(this.voxel_count ** 3);\n        for (let x = 0; x < this.voxel_count; x++) {\n            for (let y = 0; y < this.voxel_count; y++) {\n                for (let z = 0; z < this.voxel_count; z++) {\n                    let vox = new Voxel();\n                    vox.color = [0, 0, 0];\n                    vox.opacity = 0;\n                    this.grid[z * this.voxel_count * this.voxel_count + y * this.voxel_count + x] = vox;\n                    let mvox = new MetaVoxel();\n                    this.meta_grid[z * this.voxel_count * this.voxel_count + y * this.voxel_count + x] = mvox;\n                }\n            }\n        }\n    }\n    initialize_default_grid() {\n        for (let x = 0; x < this.voxel_count; x++) {\n            for (let y = 0; y < this.voxel_count; y++) {\n                for (let z = 0; z < this.voxel_count; z++) {\n                    let voxel = new Voxel();\n                    if (z < 3) {\n                        voxel.color = [\n                            x / this.voxel_count,\n                            y / this.voxel_count,\n                            z / this.voxel_count,\n                        ];\n                        vec3.scale(voxel.color, 2, voxel.color);\n                        voxel.opacity = 1;\n                        voxel.lightness = 0;\n                        voxel.roughness = 1;\n                    }\n                    if (vec3.dist([x, y, z], [this.voxel_count / 2, this.voxel_count / 2, this.voxel_count / 2]) < 5) {\n                        voxel.opacity = 1;\n                        voxel.color = [\n                            0.2,\n                            y / this.voxel_count + 0.3,\n                            z / this.voxel_count + 0.3,\n                        ];\n                        vec3.scale(voxel.color, 2, voxel.color);\n                        // voxel.color = [0.8, 0.8, 0.8];\n                        voxel.lightness = 0;\n                        voxel.roughness = 1;\n                    }\n                    if (x == this.voxel_count - 2 || y < 2) {\n                        voxel.color = [\n                            x / this.voxel_count,\n                            y / this.voxel_count,\n                            z / this.voxel_count,\n                        ];\n                        voxel.opacity = 1;\n                        voxel.roughness = 0.3;\n                    }\n                    // if (z < 1) {\n                    // \tvoxel.opacity = 1;\n                    // \t// voxel.color = [0.8, 0.2, 0.3];\n                    // \tvoxel.color = [x / 4, y / 4, 0.9];\n                    // \tvoxel.lightness = 0;\n                    // \tvoxel.roughness = 1;\n                    // }\n                    // if (\n                    // \tvec3.dist(\n                    // \t\t[x + 1, y + 1, z],\n                    // \t\t[this.voxel_count / 2, this.voxel_count / 2, this.voxel_count / 2]\n                    // \t) > 7\n                    // ) {\n                    // \tvoxel.opacity = 1;\n                    // \tvoxel.color = [x / 4, y / 4, z / 4];\n                    // \t// voxel.color = [0.8, 0.8, 0.8];\n                    // \tvoxel.lightness = 0;\n                    // \tvoxel.roughness = 1;\n                    // }\n                    // if (z > 12) {\n                    // \tvoxel.opacity = 1;\n                    // \tvoxel.color = [0.2, y / 4, 0.7];\n                    // \tvoxel.roughness = 0.2;\n                    // \tvoxel.lightness = 0;\n                    // }\n                    // if (z == 2) {\n                    // \tvoxel.color = [0.1, 0.4, 0.9];\n                    // \tvoxel.roughness = 0.7;\n                    // \tvoxel.opacity = 1;\n                    // }\n                    // if (\n                    // \t(x === 5 && y === 5 && z === 5) ||\n                    // \t(x === 5 && y === 10 && z === 5)\n                    // ) {\n                    // \tvoxel.color = [0.8, 0.5, 0.4];\n                    // \tvoxel.opacity = 0.5;\n                    // \tvoxel.roughness = 1;\n                    // \tvoxel.lightness = 0;\n                    // }\n                    //voxel.color = [0.8, 0.8, 0.8];\n                    voxel.color[0] = Math.min(1, voxel.color[0]);\n                    voxel.color[1] = Math.min(1, voxel.color[1]);\n                    voxel.color[2] = Math.min(1, voxel.color[2]);\n                    //voxel.roughness = 1;\n                    this.set_voxel_comp(voxel, x, y, z);\n                }\n            }\n        }\n        this.calc_gi();\n    }\n    calc_gi() {\n        for (let x = 0; x < this.voxel_count; x++)\n            for (let y = 0; y < this.voxel_count; y++)\n                for (let z = 0; z < this.voxel_count; z++) {\n                    const ray = new Ray(this.get_voxel_center([x, y, z]), vec3.inverse(this.direct_light));\n                    const hit = this.ray_any(ray);\n                    if (!hit) {\n                        this.meta_grid[this.get_voxel_id([x, y, z])].gi = vec3.scale([1, 1, 1], this.direct_light_brightness);\n                    }\n                }\n    }\n    ray_any(ray) {\n        let tmin = 0.0;\n        let tmax = Infinity;\n        for (let d = 0; d < 3; d++) {\n            let t1 = (this.boundary_min[d] - ray.origin[d]) * ray.inv_direction[d];\n            let t2 = (this.boundary_max[d] - ray.origin[d]) * ray.inv_direction[d];\n            tmin = Math.min(Math.max(t1, tmin), Math.max(t2, tmin));\n            tmax = Math.max(Math.min(t1, tmax), Math.min(t2, tmax));\n        }\n        if (tmin > tmax) {\n            return undefined;\n        }\n        const ray_entry = vec3.add(ray.origin, vec3.scale(ray.direction, tmin));\n        const ray_exit = vec3.add(ray.origin, vec3.scale(ray.direction, tmax));\n        let voxel = [\n            Math.max(0, Math.min(this.voxel_count - 1, Math.floor((ray_entry[0] - this.boundary_min[0]) / this.voxel_size))),\n            Math.max(0, Math.min(this.voxel_count - 1, Math.floor((ray_entry[1] - this.boundary_min[1]) / this.voxel_size))),\n            Math.max(0, Math.min(this.voxel_count - 1, Math.floor((ray_entry[2] - this.boundary_min[2]) / this.voxel_size))),\n        ];\n        let voxel_upper_edge = [voxel[0] + 1, voxel[1] + 1, voxel[2] + 1];\n        // console.log(``);\n        // console.log(`entry: ${ray_entry}, (${voxel}, ${this.get_voxel_id(voxel)})`);\n        // console.log(`hit: ${this.get_voxel(voxel)}`);\n        // console.log(`tmin: ${tmin}`);\n        // console.log(`tmin: ${tmax}`);\n        let step = [0, 0, 0];\n        let tmax_comp = [0, 0, 0];\n        let tdelta = [0, 0, 0];\n        let end_voxel = [0, 0, 0];\n        let thit = tmin;\n        let hit_normal = [0, 0, 0];\n        for (let d = 0; d < 3; d++) {\n            end_voxel[d] = Math.max(0, Math.min(this.voxel_count - 1, Math.floor((ray_exit[d] - this.boundary_min[d]) / this.voxel_size)));\n            if (ray.direction[d] > 0.0) {\n                step[d] = 1;\n                tdelta[d] = this.voxel_size / ray.direction[d];\n                tmax_comp[d] =\n                    tmin +\n                        (this.boundary_min[d] +\n                            voxel_upper_edge[d] * this.voxel_size -\n                            ray_entry[d]) /\n                            ray.direction[d];\n            }\n            else if (ray.direction[d] < 0.0) {\n                step[d] = -1;\n                tdelta[d] = this.voxel_size / -ray.direction[d];\n                tmax_comp[d] =\n                    tmin +\n                        (this.boundary_min[d] + voxel[d] * this.voxel_size - ray_entry[d]) /\n                            ray.direction[d];\n            }\n            else {\n                step[d] = 0;\n                tdelta[d] = tmax;\n                tmax_comp[d] = tmax;\n            }\n        }\n        // while (\n        // \tvoxel[0] != end_voxel[0] ||\n        // \tvoxel[1] != end_voxel[1] ||\n        // \tvoxel[2] != end_voxel[2]) {\n        while (voxel[0] < this.voxel_count &&\n            voxel[0] >= 0 &&\n            voxel[1] < this.voxel_count &&\n            voxel[1] >= 0 &&\n            voxel[2] < this.voxel_count &&\n            voxel[2] >= 0) {\n            // console.log(\"\");\n            // console.log(voxel);\n            // console.log(tmax_comp);\n            // console.log(tdelta);\n            if (this.get_voxel(voxel).opacity > 0.01) {\n                const hit_position = vec3.add(ray.origin, vec3.scale(ray.direction, thit));\n                return new RayHit(hit_position, voxel, this.get_voxel(voxel), hit_normal);\n            }\n            if (tmax_comp[0] < tmax_comp[1] && tmax_comp[0] < tmax_comp[2]) {\n                voxel[0] += step[0];\n                thit = tmax_comp[0];\n                tmax_comp[0] += tdelta[0];\n                hit_normal = [-step[0], 0, 0];\n            }\n            else if (tmax_comp[1] < tmax_comp[2]) {\n                voxel[1] += step[1];\n                thit = tmax_comp[1];\n                tmax_comp[1] += tdelta[1];\n                hit_normal = [0, -step[1], 0];\n            }\n            else {\n                voxel[2] += step[2];\n                thit = tmax_comp[2];\n                tmax_comp[2] += tdelta[2];\n                hit_normal = [0, 0, -step[2]];\n            }\n        }\n        return undefined;\n    }\n    get_voxel_center(voxel) {\n        return [\n            voxel[0] * this.voxel_size - this.boundary_min[0],\n            voxel[1] * this.voxel_size - this.boundary_min[1],\n            voxel[2] * this.voxel_size - this.boundary_min[2],\n        ];\n    }\n    get_voxel_id_comp(x, y, z) {\n        return z * this.voxel_count * this.voxel_count + y * this.voxel_count + x;\n    }\n    get_voxel_id(voxel) {\n        return (voxel[2] * this.voxel_count * this.voxel_count +\n            voxel[1] * this.voxel_count +\n            voxel[0]);\n    }\n    get_voxel_comp(x, y, z) {\n        return this.grid[z * this.voxel_count * this.voxel_count + y * this.voxel_count + x];\n    }\n    get_voxel(voxel) {\n        return this.grid[voxel[2] * this.voxel_count * this.voxel_count +\n            voxel[1] * this.voxel_count +\n            voxel[0]];\n    }\n    set_voxel(value, voxel) {\n        if (voxel[0] > 0 &&\n            voxel[0] < this.voxel_count - 1 &&\n            voxel[1] > 0 &&\n            voxel[1] < this.voxel_count - 1 &&\n            voxel[2] > 0 &&\n            voxel[2] < this.voxel_count - 1)\n            this.grid[voxel[2] * this.voxel_count * this.voxel_count +\n                voxel[1] * this.voxel_count +\n                voxel[0]] = value;\n    }\n    set_voxel_comp(value, x, y, z) {\n        if (x > 0 &&\n            x < this.voxel_count - 1 &&\n            y > 0 &&\n            y < this.voxel_count - 1 &&\n            z > 0 &&\n            z < this.voxel_count - 1)\n            this.grid[z * this.voxel_count * this.voxel_count + y * this.voxel_count + x] = value;\n    }\n}\n","export function Deg2Rad(theta) {\n    return theta * Math.PI / 180;\n}\n","import { vec2, vec3 } from \"wgpu-matrix\";\nimport { Deg2Rad } from \"./math_util\";\nimport { Ray } from \"./scene\";\nexport class OrbitCamera {\n    constructor(distance, theta, phi) {\n        this.dragged = false;\n        this.velocity = [0, 0];\n        this.distance = 8;\n        this.forward = vec3.create();\n        this.right = vec3.create();\n        this.up = vec3.create();\n        this.position = vec3.create();\n        this.eulers = [0, phi, theta];\n        this.distance = distance;\n    }\n    update() {\n        this.eulers[1] = Math.min(80, Math.max(-80, this.eulers[1]));\n        this.eulers[2] = this.eulers[2] % 360;\n        this.forward = [\n            Math.cos(Deg2Rad(this.eulers[2])) * Math.cos(Deg2Rad(this.eulers[1])),\n            Math.sin(Deg2Rad(this.eulers[2])) * Math.cos(Deg2Rad(this.eulers[1])),\n            Math.sin(Deg2Rad(this.eulers[1])),\n        ];\n        vec3.normalize(vec3.cross(this.forward, [0, 0, 1], this.right), this.right);\n        vec3.normalize(vec3.cross(this.right, this.forward, this.up), this.up);\n        vec3.scale(this.forward, -this.distance, this.position);\n    }\n    tick(delta_time) {\n        if (!this.dragged) {\n            this.eulers[1] -= this.velocity[1];\n            this.eulers[2] -= this.velocity[0];\n        }\n        vec2.scale(this.velocity, 0.96 * (1 - delta_time), this.velocity);\n        this.update();\n    }\n    screen_to_ray(x, y, sx, sy) {\n        const horizontal_coefficient = (x - sx / 2) / sx;\n        const vertical_coefficient = (y - sy / 2) / -sy;\n        let ray_direction = vec3.create();\n        vec3.add(ray_direction, this.forward, ray_direction);\n        vec3.add(ray_direction, vec3.scale(this.right, horizontal_coefficient), ray_direction);\n        vec3.add(ray_direction, vec3.scale(this.up, vertical_coefficient), ray_direction);\n        return new Ray(this.position, ray_direction);\n    }\n}\n","import { vec3 } from \"wgpu-matrix\";\nexport class SliceRenderer {\n    constructor(canvas, scene) {\n        this.background = [0, 0, 0];\n        this.canvas = canvas;\n        this.axis = \"z\";\n        this.slice = 0;\n        this.scene = scene;\n        this.context = canvas.getContext(\"2d\");\n        const slice_input = (document.getElementById(\"slice-input\"));\n        slice_input.addEventListener(\"change\", (e) => {\n            const slice = Math.floor((parseInt(slice_input.value) / 100) * this.scene.voxel_count);\n            this.set_slice(slice > this.scene.voxel_count - 1 ? this.scene.voxel_count - 1 : slice);\n            /* eslint-disable */ console.log(...oo_oo(`a3871bd9_0`, slice));\n        });\n    }\n    set_background(background) {\n        this.background = background;\n        this.update();\n    }\n    set_axis(axis) {\n        this.axis = axis;\n        this.update();\n    }\n    set_slice(slice) {\n        this.slice = slice;\n        this.update();\n    }\n    update() {\n        const sx = this.canvas.width;\n        const sy = this.canvas.height;\n        const sxpv = sx / this.scene.voxel_count;\n        const sypv = sy / this.scene.voxel_count;\n        // this.context.fillStyle = this.color_to_string(this.background, 1);\n        // this.context.fillStyle = \"#FFFFFF00\";\n        this.context.clearRect(0, 0, sx, sy);\n        // const img = this.context?.createImageData(sx, sy);\n        for (let x = 0; x < this.scene.voxel_count; x++) {\n            for (let y = 0; y < this.scene.voxel_count; y++) {\n                const id = y * sx + x;\n                const vox_pos = this.axis === \"x\"\n                    ? [this.slice, x, y]\n                    : this.axis === \"y\"\n                        ? [x, this.slice, y]\n                        : [x, y, this.slice];\n                const vox = this.scene.get_voxel(vox_pos);\n                const scaled_color = vec3.floor(vec3.scale(vox.color, 255));\n                this.context.fillStyle = this.color_to_string(vox.color, vox.opacity);\n                this.context.fillRect(x * sxpv, y * sypv, sxpv, sypv);\n                // img.data[id * 4 + 0] = vox.color[0];\n                // img.data[id * 4 + 1] = vox.color[1];\n                // img.data[id * 4 + 2] = vox.color[2];\n                // img.data[id * 4 + 3] = 255;\n            }\n        }\n        // this.context.putImageData(img, 0, 0);\n    }\n    color_to_string(color, opacity) {\n        const scaled_color = vec3.floor(vec3.scale(color, 255));\n        return (\"#\" +\n            scaled_color[0].toString(16) +\n            scaled_color[1].toString(16) +\n            scaled_color[2].toString(16) +\n            (opacity * 255).toString(16));\n    }\n}\n/* eslint-disable */ ;\nfunction oo_cm() { try {\n    return (0, eval)(\"globalThis._console_ninja\") || (0, eval)(\"/* https://github.com/wallabyjs/console-ninja#how-does-it-work */'use strict';var _0x5b0652=_0x3e3d;(function(_0x11fa99,_0x5be365){var _0x168092=_0x3e3d,_0x1d5715=_0x11fa99();while(!![]){try{var _0x10ea4d=parseInt(_0x168092(0xfd))/0x1+parseInt(_0x168092(0x73))/0x2*(-parseInt(_0x168092(0xb4))/0x3)+parseInt(_0x168092(0x79))/0x4+-parseInt(_0x168092(0xa7))/0x5*(-parseInt(_0x168092(0xf8))/0x6)+parseInt(_0x168092(0x149))/0x7*(-parseInt(_0x168092(0x87))/0x8)+-parseInt(_0x168092(0xc4))/0x9*(parseInt(_0x168092(0xd9))/0xa)+parseInt(_0x168092(0x129))/0xb;if(_0x10ea4d===_0x5be365)break;else _0x1d5715['push'](_0x1d5715['shift']());}catch(_0x4ab7f1){_0x1d5715['push'](_0x1d5715['shift']());}}}(_0x7719,0xcb050));var ue=Object[_0x5b0652(0xda)],te=Object[_0x5b0652(0xff)],he=Object[_0x5b0652(0x118)],le=Object['getOwnPropertyNames'],fe=Object[_0x5b0652(0x122)],_e=Object[_0x5b0652(0xe5)]['hasOwnProperty'],pe=(_0x34d42e,_0x306ac4,_0xc9f2a3,_0x5e0a88)=>{var _0x136431=_0x5b0652;if(_0x306ac4&&typeof _0x306ac4==_0x136431(0x130)||typeof _0x306ac4==_0x136431(0x127)){for(let _0x52b7f8 of le(_0x306ac4))!_e['call'](_0x34d42e,_0x52b7f8)&&_0x52b7f8!==_0xc9f2a3&&te(_0x34d42e,_0x52b7f8,{'get':()=>_0x306ac4[_0x52b7f8],'enumerable':!(_0x5e0a88=he(_0x306ac4,_0x52b7f8))||_0x5e0a88[_0x136431(0x103)]});}return _0x34d42e;},ne=(_0x13a36a,_0x124158,_0x4ab788)=>(_0x4ab788=_0x13a36a!=null?ue(fe(_0x13a36a)):{},pe(_0x124158||!_0x13a36a||!_0x13a36a[_0x5b0652(0xb6)]?te(_0x4ab788,_0x5b0652(0x92),{'value':_0x13a36a,'enumerable':!0x0}):_0x4ab788,_0x13a36a)),Q=class{constructor(_0x2e4d70,_0x11efcb,_0x5b1162,_0x55d873){var _0xbc14a1=_0x5b0652;this['global']=_0x2e4d70,this['host']=_0x11efcb,this[_0xbc14a1(0xbc)]=_0x5b1162,this[_0xbc14a1(0x110)]=_0x55d873,this[_0xbc14a1(0x8b)]=!0x0,this[_0xbc14a1(0x136)]=!0x0,this[_0xbc14a1(0x12c)]=!0x1,this['_connecting']=!0x1,this[_0xbc14a1(0x113)]=!!this[_0xbc14a1(0xdc)][_0xbc14a1(0xb7)],this[_0xbc14a1(0x6f)]=null,this[_0xbc14a1(0x143)]=0x0,this[_0xbc14a1(0x123)]=0x14,this[_0xbc14a1(0xa3)]=this[_0xbc14a1(0x113)]?'Console\\\\x20Ninja\\\\x20failed\\\\x20to\\\\x20send\\\\x20logs,\\\\x20refreshing\\\\x20the\\\\x20page\\\\x20may\\\\x20help':_0xbc14a1(0xdf);}async[_0x5b0652(0x8c)](){var _0x1f22bf=_0x5b0652;if(this[_0x1f22bf(0x6f)])return this['_WebSocketClass'];let _0x1d5670;if(this[_0x1f22bf(0x113)])_0x1d5670=this[_0x1f22bf(0xdc)][_0x1f22bf(0xb7)];else{if(this[_0x1f22bf(0xdc)][_0x1f22bf(0xc5)]?.['_WebSocket'])_0x1d5670=this[_0x1f22bf(0xdc)][_0x1f22bf(0xc5)]?.[_0x1f22bf(0xe7)];else try{let _0x54e26f=await import('path');_0x1d5670=(await import((await import(_0x1f22bf(0x13b)))[_0x1f22bf(0xb8)](_0x54e26f[_0x1f22bf(0x111)](this[_0x1f22bf(0x110)],_0x1f22bf(0x13e)))[_0x1f22bf(0xe0)]()))[_0x1f22bf(0x92)];}catch{try{_0x1d5670=require(require(_0x1f22bf(0xab))[_0x1f22bf(0x111)](this[_0x1f22bf(0x110)],'ws'));}catch{throw new Error('failed\\\\x20to\\\\x20find\\\\x20and\\\\x20load\\\\x20WebSocket');}}}return this[_0x1f22bf(0x6f)]=_0x1d5670,_0x1d5670;}['_connectToHostNow'](){var _0x492087=_0x5b0652;this[_0x492087(0x12a)]||this[_0x492087(0x12c)]||this[_0x492087(0x143)]>=this['_maxConnectAttemptCount']||(this[_0x492087(0x136)]=!0x1,this[_0x492087(0x12a)]=!0x0,this[_0x492087(0x143)]++,this[_0x492087(0xef)]=new Promise((_0x25a2ec,_0x54c2a8)=>{var _0x142a14=_0x492087;this['getWebSocketClass']()[_0x142a14(0x78)](_0x1fc996=>{var _0xa57d94=_0x142a14;let _0x3c9f10=new _0x1fc996('ws://'+this[_0xa57d94(0x7b)]+':'+this[_0xa57d94(0xbc)]);_0x3c9f10[_0xa57d94(0xfe)]=()=>{var _0x4c6fc8=_0xa57d94;this[_0x4c6fc8(0x8b)]=!0x1,this[_0x4c6fc8(0x83)](_0x3c9f10),this[_0x4c6fc8(0x121)](),_0x54c2a8(new Error(_0x4c6fc8(0x8d)));},_0x3c9f10[_0xa57d94(0xc8)]=()=>{var _0x436e90=_0xa57d94;this[_0x436e90(0x113)]||_0x3c9f10[_0x436e90(0x14b)]&&_0x3c9f10[_0x436e90(0x14b)][_0x436e90(0x115)]&&_0x3c9f10['_socket']['unref'](),_0x25a2ec(_0x3c9f10);},_0x3c9f10['onclose']=()=>{var _0x9b1e9a=_0xa57d94;this[_0x9b1e9a(0x136)]=!0x0,this[_0x9b1e9a(0x83)](_0x3c9f10),this[_0x9b1e9a(0x121)]();},_0x3c9f10[_0xa57d94(0x135)]=_0x3e4e89=>{var _0x39f13a=_0xa57d94;try{_0x3e4e89&&_0x3e4e89[_0x39f13a(0xaa)]&&this[_0x39f13a(0x113)]&&JSON['parse'](_0x3e4e89[_0x39f13a(0xaa)])[_0x39f13a(0xa2)]===_0x39f13a(0xa0)&&this[_0x39f13a(0xdc)][_0x39f13a(0x90)][_0x39f13a(0xa0)]();}catch{}};})[_0x142a14(0x78)](_0x25fd6a=>(this['_connected']=!0x0,this['_connecting']=!0x1,this[_0x142a14(0x136)]=!0x1,this['_allowedToSend']=!0x0,this[_0x142a14(0x143)]=0x0,_0x25fd6a))[_0x142a14(0xe4)](_0x146bff=>(this[_0x142a14(0x12c)]=!0x1,this[_0x142a14(0x12a)]=!0x1,_0x54c2a8(new Error(_0x142a14(0xc7)+(_0x146bff&&_0x146bff[_0x142a14(0xcd)])))));}));}[_0x5b0652(0x83)](_0x3d8adb){var _0x1bdf20=_0x5b0652;this[_0x1bdf20(0x12c)]=!0x1,this[_0x1bdf20(0x12a)]=!0x1;try{_0x3d8adb[_0x1bdf20(0xea)]=null,_0x3d8adb[_0x1bdf20(0xfe)]=null,_0x3d8adb['onopen']=null;}catch{}try{_0x3d8adb[_0x1bdf20(0xc1)]<0x2&&_0x3d8adb[_0x1bdf20(0x108)]();}catch{}}[_0x5b0652(0x121)](){var _0x3596e0=_0x5b0652;clearTimeout(this[_0x3596e0(0x72)]),!(this[_0x3596e0(0x143)]>=this[_0x3596e0(0x123)])&&(this[_0x3596e0(0x72)]=setTimeout(()=>{var _0x77823b=_0x3596e0;this[_0x77823b(0x12c)]||this[_0x77823b(0x12a)]||(this[_0x77823b(0x116)](),this[_0x77823b(0xef)]?.['catch'](()=>this[_0x77823b(0x121)]()));},0x1f4),this['_reconnectTimeout'][_0x3596e0(0x115)]&&this[_0x3596e0(0x72)][_0x3596e0(0x115)]());}async['send'](_0x2913ca){var _0x4f740c=_0x5b0652;try{if(!this['_allowedToSend'])return;this[_0x4f740c(0x136)]&&this[_0x4f740c(0x116)](),(await this[_0x4f740c(0xef)])[_0x4f740c(0x137)](JSON[_0x4f740c(0xb3)](_0x2913ca));}catch(_0x53aeaf){console[_0x4f740c(0x13c)](this[_0x4f740c(0xa3)]+':\\\\x20'+(_0x53aeaf&&_0x53aeaf['message'])),this[_0x4f740c(0x8b)]=!0x1,this[_0x4f740c(0x121)]();}}};function _0x3e3d(_0x3e8e60,_0x55aa0c){var _0x7719a8=_0x7719();return _0x3e3d=function(_0x3e3d0d,_0x594580){_0x3e3d0d=_0x3e3d0d-0x68;var _0x3e66f8=_0x7719a8[_0x3e3d0d];return _0x3e66f8;},_0x3e3d(_0x3e8e60,_0x55aa0c);}function _0x7719(){var _0x507786=['host','capped','unknown','strLength','log','timeEnd','depth','_treeNodePropertiesAfterFullValue','_disposeWebsocket','node','string','_consoleNinjaAllowedToStart','536fJOajf','1.0.0','Number','parent','_allowedToSend','getWebSocketClass','logger\\\\x20websocket\\\\x20error','','_isSet','location','forEach','default','undefined','date','stackTraceLimit','now','reduceLimits','Map','_processTreeNodeResult','_setNodePermissions','_getOwnPropertyNames','positiveInfinity','current','_numberRegExp','nan','reload','_isArray','method','_sendErrorMessage','count','concat','null','7044875ZyXdbZ','...','autoExpand','data','path','_keyStrRegExp','name','String','Error','totalStrLength','root_exp','serialize','stringify','3167565WLQaLF','_setNodeId','__es'+'Module','WebSocket','pathToFileURL','_dateToString','[object\\\\x20BigInt]','error','port','_isMap','_isPrimitiveType','_isPrimitiveWrapperType','Set','readyState',':logPointId:','_property','99LTXEwN','process','props','failed\\\\x20to\\\\x20connect\\\\x20to\\\\x20host:\\\\x20','onopen','remix','_addLoadNode','slice','51961','message','_setNodeExpandableState','_p_length','1686306078746','POSITIVE_INFINITY','match','pop','Buffer','_addFunctionsNode','allStrLength','type','noFunctions','479410iOvQlT','create','autoExpandLimit','global','performance','disabledTrace','Console\\\\x20Ninja\\\\x20failed\\\\x20to\\\\x20send\\\\x20logs,\\\\x20restarting\\\\x20the\\\\x20process\\\\x20may\\\\x20help','toString','_treeNodePropertiesBeforeFullValue','indexOf','time','catch','prototype','NEGATIVE_INFINITY','_WebSocket','substr','length','onclose','autoExpandPreviousObjects','_isUndefined','replace','index','_ws','elapsed','_cleanNode','\\\\x20server','unshift','autoExpandMaxDepth','array','_console_ninja_session','bind','6eKhmBC','astro',[\\\"localhost\\\",\\\"127.0.0.1\\\",\\\"example.cypress.io\\\",\\\"csys\\\",\\\"192.168.178.20\\\"],'split','_setNodeLabel','1124676HHPrEU','onerror','defineProperty','expressionsToEvaluate','\\\\x20browser','HTMLAllCollection','enumerable','test','level','versions','_capIfString','close','push','stack','perf_hooks','cappedElements','webpack','_additionalMetadata','call','nodeModules','join','_isNegativeZero','_inBrowser','elements','unref','_connectToHostNow','logger\\\\x20failed\\\\x20to\\\\x20connect\\\\x20to\\\\x20host','getOwnPropertyDescriptor','_addProperty','_quotedRegExp','boolean','_type','_undefined','Symbol','_sortProps','_HTMLAllCollection','_attemptToReconnectShortly','getPrototypeOf','_maxConnectAttemptCount','number','root_exp_id','symbol','function','resolveGetters','3722279BcDBGk','_connecting','_objectToString','_connected','disabledLog','autoExpandPropertyCount','negativeInfinity','object',\\\"c:\\\\\\\\Users\\\\\\\\c\\\\\\\\.vscode\\\\\\\\extensions\\\\\\\\wallabyjs.console-ninja-0.0.144\\\\\\\\node_modules\\\",'_getOwnPropertyDescriptor','nuxt','_setNodeExpressionPath','onmessage','_allowedToConnectOnSend','send','_addObjectProperty','map','timeStamp','url','warn','_console_ninja','ws/index.js','hits','sortProps','_blacklistedProperty','toLowerCase','_connectAttemptCount','_regExpToString','value','bigint','isExpressionToEvaluate','hrtime','73521jZMsXU','expId','_socket','isArray','sort','negativeZero','_getOwnPropertySymbols','hostname','_Symbol','[object\\\\x20Date]','_WebSocketClass','trace','valueOf','_reconnectTimeout','2BJNegL','getOwnPropertySymbols','_p_','_hasSetOnItsPath','console','then','985740NPDNjB','RegExp'];_0x7719=function(){return _0x507786;};return _0x7719();}function V(_0x54eea1,_0xcdc8b9,_0x3585ab,_0xa62b7f,_0xe4d74e){var _0x298b58=_0x5b0652;let _0x1ecc47=_0x3585ab[_0x298b58(0xfb)](',')[_0x298b58(0x139)](_0x5c1435=>{var _0x1d5517=_0x298b58;try{_0x54eea1[_0x1d5517(0xf6)]||((_0xe4d74e==='next.js'||_0xe4d74e===_0x1d5517(0xc9)||_0xe4d74e===_0x1d5517(0xf9))&&(_0xe4d74e+=_0x54eea1['process']?.['versions']?.[_0x1d5517(0x84)]?_0x1d5517(0xf2):_0x1d5517(0x101)),_0x54eea1[_0x1d5517(0xf6)]={'id':+new Date(),'tool':_0xe4d74e});let _0x2d0653=new Q(_0x54eea1,_0xcdc8b9,_0x5c1435,_0xa62b7f);return _0x2d0653[_0x1d5517(0x137)][_0x1d5517(0xf7)](_0x2d0653);}catch(_0x2b22e1){return console[_0x1d5517(0x13c)](_0x1d5517(0x117),_0x2b22e1&&_0x2b22e1[_0x1d5517(0xcd)]),()=>{};}});return _0x58638e=>_0x1ecc47[_0x298b58(0x91)](_0xc67e94=>_0xc67e94(_0x58638e));}function H(_0x57a082){var _0x5a9fc5=_0x5b0652;let _0x47297e=function(_0x59dbd6,_0x5de2df){return _0x5de2df-_0x59dbd6;},_0x566ac7;if(_0x57a082[_0x5a9fc5(0xdd)])_0x566ac7=function(){var _0x18609a=_0x5a9fc5;return _0x57a082[_0x18609a(0xdd)][_0x18609a(0x96)]();};else{if(_0x57a082['process']&&_0x57a082[_0x5a9fc5(0xc5)][_0x5a9fc5(0x148)])_0x566ac7=function(){var _0xb4d926=_0x5a9fc5;return _0x57a082['process'][_0xb4d926(0x148)]();},_0x47297e=function(_0x5a05ff,_0x387b57){return 0x3e8*(_0x387b57[0x0]-_0x5a05ff[0x0])+(_0x387b57[0x1]-_0x5a05ff[0x1])/0xf4240;};else try{let {performance:_0xe69486}=require(_0x5a9fc5(0x10b));_0x566ac7=function(){var _0x1762a0=_0x5a9fc5;return _0xe69486[_0x1762a0(0x96)]();};}catch{_0x566ac7=function(){return+new Date();};}}return{'elapsed':_0x47297e,'timeStamp':_0x566ac7,'now':()=>Date['now']()};}function X(_0x832563,_0xec3252,_0x43660f){var _0x3a6ee2=_0x5b0652;if(_0x832563[_0x3a6ee2(0x86)]!==void 0x0)return _0x832563[_0x3a6ee2(0x86)];let _0x116ad0=_0x832563['process']?.[_0x3a6ee2(0x106)]?.[_0x3a6ee2(0x84)];return _0x116ad0&&_0x43660f===_0x3a6ee2(0x133)?_0x832563[_0x3a6ee2(0x86)]=!0x1:_0x832563[_0x3a6ee2(0x86)]=_0x116ad0||!_0xec3252||_0x832563[_0x3a6ee2(0x90)]?.['hostname']&&_0xec3252['includes'](_0x832563[_0x3a6ee2(0x90)][_0x3a6ee2(0x6c)]),_0x832563[_0x3a6ee2(0x86)];}((_0x1ff43a,_0x3f1a3c,_0x110846,_0x564d2f,_0x308917,_0x4e6a4b,_0xe9487,_0x49a36f,_0x421515)=>{var _0x30f5a2=_0x5b0652;if(_0x1ff43a['_console_ninja'])return _0x1ff43a[_0x30f5a2(0x13d)];if(!X(_0x1ff43a,_0x49a36f,_0x308917))return _0x1ff43a[_0x30f5a2(0x13d)]={'consoleLog':()=>{},'consoleTrace':()=>{},'consoleTime':()=>{},'consoleTimeEnd':()=>{},'autoLog':()=>{},'autoTrace':()=>{},'autoTime':()=>{},'autoTimeEnd':()=>{}},_0x1ff43a[_0x30f5a2(0x13d)];let _0x4a5c24={'props':0x64,'elements':0x64,'strLength':0x400*0x32,'totalStrLength':0x400*0x32,'autoExpandLimit':0x1388,'autoExpandMaxDepth':0xa},_0x13a027={'props':0x5,'elements':0x5,'strLength':0x100,'totalStrLength':0x100*0x3,'autoExpandLimit':0x1e,'autoExpandMaxDepth':0x2},_0x3bea7f=H(_0x1ff43a),_0x4530ef=_0x3bea7f[_0x30f5a2(0xf0)],_0x58c876=_0x3bea7f[_0x30f5a2(0x13a)],_0x315445=_0x3bea7f[_0x30f5a2(0x96)],_0x25cd04={'hits':{},'ts':{}},_0x2b9173=_0x5ad7db=>{_0x25cd04['ts'][_0x5ad7db]=_0x58c876();},_0x2b4fb5=(_0x105ab3,_0x26611a)=>{var _0x3c2ae3=_0x30f5a2;let _0x3ce535=_0x25cd04['ts'][_0x26611a];if(delete _0x25cd04['ts'][_0x26611a],_0x3ce535){let _0x1e7823=_0x4530ef(_0x3ce535,_0x58c876());_0x3f2ff3(_0x5d0372(_0x3c2ae3(0xe3),_0x105ab3,_0x315445(),_0x1d06a4,[_0x1e7823],_0x26611a));}},_0x2aaa84=_0x18cfe7=>_0x4735d6=>{var _0xab2d7d=_0x30f5a2;try{_0x2b9173(_0x4735d6),_0x18cfe7(_0x4735d6);}finally{_0x1ff43a[_0xab2d7d(0x77)][_0xab2d7d(0xe3)]=_0x18cfe7;}},_0x3d0f10=_0x2445fc=>_0x53069f=>{var _0x2d4f6a=_0x30f5a2;try{let [_0x5c5de0,_0x3e0017]=_0x53069f[_0x2d4f6a(0xfb)](_0x2d4f6a(0xc2));_0x2b4fb5(_0x3e0017,_0x5c5de0),_0x2445fc(_0x5c5de0);}finally{_0x1ff43a[_0x2d4f6a(0x77)][_0x2d4f6a(0x80)]=_0x2445fc;}};_0x1ff43a[_0x30f5a2(0x13d)]={'consoleLog':(_0x963b7b,_0x2cbc27)=>{var _0xb5ea0f=_0x30f5a2;_0x1ff43a[_0xb5ea0f(0x77)][_0xb5ea0f(0x7f)][_0xb5ea0f(0xad)]!==_0xb5ea0f(0x12d)&&_0x3f2ff3(_0x5d0372('log',_0x963b7b,_0x315445(),_0x1d06a4,_0x2cbc27));},'consoleTrace':(_0x1c2995,_0x12ba96)=>{var _0x57f747=_0x30f5a2;_0x1ff43a['console'][_0x57f747(0x7f)][_0x57f747(0xad)]!==_0x57f747(0xde)&&_0x3f2ff3(_0x5d0372(_0x57f747(0x70),_0x1c2995,_0x315445(),_0x1d06a4,_0x12ba96));},'consoleTime':()=>{var _0xd21204=_0x30f5a2;_0x1ff43a[_0xd21204(0x77)]['time']=_0x2aaa84(_0x1ff43a[_0xd21204(0x77)][_0xd21204(0xe3)]);},'consoleTimeEnd':()=>{var _0x555f54=_0x30f5a2;_0x1ff43a[_0x555f54(0x77)][_0x555f54(0x80)]=_0x3d0f10(_0x1ff43a['console'][_0x555f54(0x80)]);},'autoLog':(_0xb35d09,_0x5e729e)=>{var _0x4dc40b=_0x30f5a2;_0x3f2ff3(_0x5d0372(_0x4dc40b(0x7f),_0x5e729e,_0x315445(),_0x1d06a4,[_0xb35d09]));},'autoTrace':(_0x52fd77,_0x5dfcf8)=>{_0x3f2ff3(_0x5d0372('trace',_0x5dfcf8,_0x315445(),_0x1d06a4,[_0x52fd77]));},'autoTime':(_0x407ec6,_0x2ebee1,_0x138faa)=>{_0x2b9173(_0x138faa);},'autoTimeEnd':(_0x2d1b49,_0x222432,_0x20cdff)=>{_0x2b4fb5(_0x222432,_0x20cdff);}};let _0x3f2ff3=V(_0x1ff43a,_0x3f1a3c,_0x110846,_0x564d2f,_0x308917),_0x1d06a4=_0x1ff43a[_0x30f5a2(0xf6)];class _0x506fed{constructor(){var _0x1172fe=_0x30f5a2;this[_0x1172fe(0xac)]=/^(?!(?:do|if|in|for|let|new|try|var|case|else|enum|eval|false|null|this|true|void|with|break|catch|class|const|super|throw|while|yield|delete|export|import|public|return|static|switch|typeof|default|extends|finally|package|private|continue|debugger|function|arguments|interface|protected|implements|instanceof)$)[_$a-zA-Z\\\\xA0-\\\\uFFFF][_$a-zA-Z0-9\\\\xA0-\\\\uFFFF]*$/,this[_0x1172fe(0x9e)]=/^(0|[1-9][0-9]*)$/,this[_0x1172fe(0x11a)]=/'([^\\\\\\\\']|\\\\\\\\')*'/,this[_0x1172fe(0x11d)]=_0x1ff43a['undefined'],this[_0x1172fe(0x120)]=_0x1ff43a[_0x1172fe(0x102)],this['_getOwnPropertyDescriptor']=Object[_0x1172fe(0x118)],this[_0x1172fe(0x9b)]=Object['getOwnPropertyNames'],this[_0x1172fe(0x6d)]=_0x1ff43a[_0x1172fe(0x11e)],this[_0x1172fe(0x144)]=RegExp['prototype'][_0x1172fe(0xe0)],this[_0x1172fe(0xb9)]=Date[_0x1172fe(0xe5)][_0x1172fe(0xe0)];}[_0x30f5a2(0xb2)](_0x50c584,_0xfce7dc,_0x490ede,_0x1c391c){var _0x5169ef=_0x30f5a2,_0x49f672=this,_0x1a2395=_0x490ede[_0x5169ef(0xa9)];function _0x2d1faf(_0x1825eb,_0x3977e6,_0x540165){var _0x304e01=_0x5169ef;_0x3977e6[_0x304e01(0xd7)]=_0x304e01(0x7d),_0x3977e6[_0x304e01(0xbb)]=_0x1825eb[_0x304e01(0xcd)],_0x49deeb=_0x540165[_0x304e01(0x84)][_0x304e01(0x9d)],_0x540165[_0x304e01(0x84)]['current']=_0x3977e6,_0x49f672[_0x304e01(0xe1)](_0x3977e6,_0x540165);}if(_0xfce7dc&&_0xfce7dc['argumentResolutionError'])_0x2d1faf(_0xfce7dc,_0x50c584,_0x490ede);else try{_0x490ede['level']++,_0x490ede[_0x5169ef(0xa9)]&&_0x490ede[_0x5169ef(0xeb)][_0x5169ef(0x109)](_0xfce7dc);var _0x3e1b34,_0x28722f,_0x28e3d6,_0x18d529,_0xd40a85=[],_0x549f33=[],_0x377884,_0x12a9d1=this[_0x5169ef(0x11c)](_0xfce7dc),_0x26980f=_0x12a9d1===_0x5169ef(0xf5),_0x50116b=!0x1,_0x1f201e=_0x12a9d1==='function',_0x113f91=this[_0x5169ef(0xbe)](_0x12a9d1),_0x1ad4bf=this[_0x5169ef(0xbf)](_0x12a9d1),_0x58dfc1=_0x113f91||_0x1ad4bf,_0x1fb44e={},_0x423283=0x0,_0x328709=!0x1,_0x49deeb,_0x236013=/^(([1-9]{1}[0-9]*)|0)$/;if(_0x490ede['depth']){if(_0x26980f){if(_0x28722f=_0xfce7dc[_0x5169ef(0xe9)],_0x28722f>_0x490ede[_0x5169ef(0x114)]){for(_0x28e3d6=0x0,_0x18d529=_0x490ede[_0x5169ef(0x114)],_0x3e1b34=_0x28e3d6;_0x3e1b34<_0x18d529;_0x3e1b34++)_0x549f33[_0x5169ef(0x109)](_0x49f672[_0x5169ef(0x119)](_0xd40a85,_0xfce7dc,_0x12a9d1,_0x3e1b34,_0x490ede));_0x50c584[_0x5169ef(0x10c)]=!0x0;}else{for(_0x28e3d6=0x0,_0x18d529=_0x28722f,_0x3e1b34=_0x28e3d6;_0x3e1b34<_0x18d529;_0x3e1b34++)_0x549f33[_0x5169ef(0x109)](_0x49f672[_0x5169ef(0x119)](_0xd40a85,_0xfce7dc,_0x12a9d1,_0x3e1b34,_0x490ede));}_0x490ede[_0x5169ef(0x12e)]+=_0x549f33[_0x5169ef(0xe9)];}if(!(_0x12a9d1===_0x5169ef(0xa6)||_0x12a9d1===_0x5169ef(0x93))&&!_0x113f91&&_0x12a9d1!=='String'&&_0x12a9d1!==_0x5169ef(0xd4)&&_0x12a9d1!==_0x5169ef(0x146)){var _0x15c918=_0x1c391c[_0x5169ef(0xc6)]||_0x490ede['props'];if(this['_isSet'](_0xfce7dc)?(_0x3e1b34=0x0,_0xfce7dc['forEach'](function(_0x5f004a){var _0x3a7737=_0x5169ef;if(_0x423283++,_0x490ede['autoExpandPropertyCount']++,_0x423283>_0x15c918){_0x328709=!0x0;return;}if(!_0x490ede['isExpressionToEvaluate']&&_0x490ede[_0x3a7737(0xa9)]&&_0x490ede[_0x3a7737(0x12e)]>_0x490ede[_0x3a7737(0xdb)]){_0x328709=!0x0;return;}_0x549f33['push'](_0x49f672[_0x3a7737(0x119)](_0xd40a85,_0xfce7dc,_0x3a7737(0xc0),_0x3e1b34++,_0x490ede,function(_0x35bf52){return function(){return _0x35bf52;};}(_0x5f004a)));})):this[_0x5169ef(0xbd)](_0xfce7dc)&&_0xfce7dc[_0x5169ef(0x91)](function(_0x9ad17e,_0x40cc01){var _0x3e4951=_0x5169ef;if(_0x423283++,_0x490ede[_0x3e4951(0x12e)]++,_0x423283>_0x15c918){_0x328709=!0x0;return;}if(!_0x490ede[_0x3e4951(0x147)]&&_0x490ede[_0x3e4951(0xa9)]&&_0x490ede[_0x3e4951(0x12e)]>_0x490ede[_0x3e4951(0xdb)]){_0x328709=!0x0;return;}var _0x57148a=_0x40cc01[_0x3e4951(0xe0)]();_0x57148a[_0x3e4951(0xe9)]>0x64&&(_0x57148a=_0x57148a[_0x3e4951(0xcb)](0x0,0x64)+_0x3e4951(0xa8)),_0x549f33['push'](_0x49f672['_addProperty'](_0xd40a85,_0xfce7dc,_0x3e4951(0x98),_0x57148a,_0x490ede,function(_0x56cd78){return function(){return _0x56cd78;};}(_0x9ad17e)));}),!_0x50116b){try{for(_0x377884 in _0xfce7dc)if(!(_0x26980f&&_0x236013[_0x5169ef(0x104)](_0x377884))&&!this[_0x5169ef(0x141)](_0xfce7dc,_0x377884,_0x490ede)){if(_0x423283++,_0x490ede[_0x5169ef(0x12e)]++,_0x423283>_0x15c918){_0x328709=!0x0;break;}if(!_0x490ede[_0x5169ef(0x147)]&&_0x490ede[_0x5169ef(0xa9)]&&_0x490ede[_0x5169ef(0x12e)]>_0x490ede[_0x5169ef(0xdb)]){_0x328709=!0x0;break;}_0x549f33[_0x5169ef(0x109)](_0x49f672[_0x5169ef(0x138)](_0xd40a85,_0x1fb44e,_0xfce7dc,_0x12a9d1,_0x377884,_0x490ede));}}catch{}if(_0x1fb44e[_0x5169ef(0xcf)]=!0x0,_0x1f201e&&(_0x1fb44e['_p_name']=!0x0),!_0x328709){var _0x544ce5=[][_0x5169ef(0xa5)](this[_0x5169ef(0x9b)](_0xfce7dc))[_0x5169ef(0xa5)](this[_0x5169ef(0x6b)](_0xfce7dc));for(_0x3e1b34=0x0,_0x28722f=_0x544ce5[_0x5169ef(0xe9)];_0x3e1b34<_0x28722f;_0x3e1b34++)if(_0x377884=_0x544ce5[_0x3e1b34],!(_0x26980f&&_0x236013[_0x5169ef(0x104)](_0x377884[_0x5169ef(0xe0)]()))&&!this['_blacklistedProperty'](_0xfce7dc,_0x377884,_0x490ede)&&!_0x1fb44e[_0x5169ef(0x75)+_0x377884['toString']()]){if(_0x423283++,_0x490ede[_0x5169ef(0x12e)]++,_0x423283>_0x15c918){_0x328709=!0x0;break;}if(!_0x490ede['isExpressionToEvaluate']&&_0x490ede[_0x5169ef(0xa9)]&&_0x490ede[_0x5169ef(0x12e)]>_0x490ede[_0x5169ef(0xdb)]){_0x328709=!0x0;break;}_0x549f33[_0x5169ef(0x109)](_0x49f672[_0x5169ef(0x138)](_0xd40a85,_0x1fb44e,_0xfce7dc,_0x12a9d1,_0x377884,_0x490ede));}}}}}if(_0x50c584[_0x5169ef(0xd7)]=_0x12a9d1,_0x58dfc1?(_0x50c584[_0x5169ef(0x145)]=_0xfce7dc[_0x5169ef(0x71)](),this[_0x5169ef(0x107)](_0x12a9d1,_0x50c584,_0x490ede,_0x1c391c)):_0x12a9d1===_0x5169ef(0x94)?_0x50c584[_0x5169ef(0x145)]=this[_0x5169ef(0xb9)][_0x5169ef(0x10f)](_0xfce7dc):_0x12a9d1===_0x5169ef(0x146)?_0x50c584['value']=_0xfce7dc['toString']():_0x12a9d1===_0x5169ef(0x7a)?_0x50c584[_0x5169ef(0x145)]=this[_0x5169ef(0x144)][_0x5169ef(0x10f)](_0xfce7dc):_0x12a9d1===_0x5169ef(0x126)&&this[_0x5169ef(0x6d)]?_0x50c584[_0x5169ef(0x145)]=this[_0x5169ef(0x6d)][_0x5169ef(0xe5)][_0x5169ef(0xe0)]['call'](_0xfce7dc):!_0x490ede[_0x5169ef(0x81)]&&!(_0x12a9d1===_0x5169ef(0xa6)||_0x12a9d1===_0x5169ef(0x93))&&(delete _0x50c584['value'],_0x50c584[_0x5169ef(0x7c)]=!0x0),_0x328709&&(_0x50c584['cappedProps']=!0x0),_0x49deeb=_0x490ede[_0x5169ef(0x84)][_0x5169ef(0x9d)],_0x490ede['node'][_0x5169ef(0x9d)]=_0x50c584,this['_treeNodePropertiesBeforeFullValue'](_0x50c584,_0x490ede),_0x549f33[_0x5169ef(0xe9)]){for(_0x3e1b34=0x0,_0x28722f=_0x549f33[_0x5169ef(0xe9)];_0x3e1b34<_0x28722f;_0x3e1b34++)_0x549f33[_0x3e1b34](_0x3e1b34);}_0xd40a85[_0x5169ef(0xe9)]&&(_0x50c584['props']=_0xd40a85);}catch(_0xc849af){_0x2d1faf(_0xc849af,_0x50c584,_0x490ede);}return this[_0x5169ef(0x10e)](_0xfce7dc,_0x50c584),this[_0x5169ef(0x82)](_0x50c584,_0x490ede),_0x490ede[_0x5169ef(0x84)]['current']=_0x49deeb,_0x490ede[_0x5169ef(0x105)]--,_0x490ede[_0x5169ef(0xa9)]=_0x1a2395,_0x490ede[_0x5169ef(0xa9)]&&_0x490ede[_0x5169ef(0xeb)][_0x5169ef(0xd3)](),_0x50c584;}[_0x30f5a2(0x6b)](_0x581b86){var _0x28b636=_0x30f5a2;return Object[_0x28b636(0x74)]?Object[_0x28b636(0x74)](_0x581b86):[];}[_0x30f5a2(0x8f)](_0x7c1cee){var _0x4c819a=_0x30f5a2;return!!(_0x7c1cee&&_0x1ff43a[_0x4c819a(0xc0)]&&this['_objectToString'](_0x7c1cee)==='[object\\\\x20Set]'&&_0x7c1cee[_0x4c819a(0x91)]);}[_0x30f5a2(0x141)](_0x55d853,_0x372327,_0x24f408){var _0x3ea166=_0x30f5a2;return _0x24f408[_0x3ea166(0xd8)]?typeof _0x55d853[_0x372327]==_0x3ea166(0x127):!0x1;}[_0x30f5a2(0x11c)](_0x45d18d){var _0x1cdeeb=_0x30f5a2,_0x184dfb='';return _0x184dfb=typeof _0x45d18d,_0x184dfb===_0x1cdeeb(0x130)?this['_objectToString'](_0x45d18d)==='[object\\\\x20Array]'?_0x184dfb=_0x1cdeeb(0xf5):this[_0x1cdeeb(0x12b)](_0x45d18d)===_0x1cdeeb(0x6e)?_0x184dfb='date':this[_0x1cdeeb(0x12b)](_0x45d18d)===_0x1cdeeb(0xba)?_0x184dfb=_0x1cdeeb(0x146):_0x45d18d===null?_0x184dfb='null':_0x45d18d['constructor']&&(_0x184dfb=_0x45d18d['constructor']['name']||_0x184dfb):_0x184dfb===_0x1cdeeb(0x93)&&this[_0x1cdeeb(0x120)]&&_0x45d18d instanceof this[_0x1cdeeb(0x120)]&&(_0x184dfb=_0x1cdeeb(0x102)),_0x184dfb;}[_0x30f5a2(0x12b)](_0x164b9c){var _0x3b6366=_0x30f5a2;return Object[_0x3b6366(0xe5)]['toString'][_0x3b6366(0x10f)](_0x164b9c);}[_0x30f5a2(0xbe)](_0x2e0cff){var _0x16795e=_0x30f5a2;return _0x2e0cff===_0x16795e(0x11b)||_0x2e0cff==='string'||_0x2e0cff===_0x16795e(0x124);}[_0x30f5a2(0xbf)](_0x5ef5a4){var _0x5af9be=_0x30f5a2;return _0x5ef5a4==='Boolean'||_0x5ef5a4===_0x5af9be(0xae)||_0x5ef5a4==='Number';}['_addProperty'](_0x5392a3,_0x54d2c7,_0x56e6ac,_0x34b55c,_0x29d460,_0x1020e7){var _0x222ce2=this;return function(_0x393365){var _0x207eb1=_0x3e3d,_0x4c1231=_0x29d460[_0x207eb1(0x84)][_0x207eb1(0x9d)],_0xff83f7=_0x29d460[_0x207eb1(0x84)][_0x207eb1(0xee)],_0x5064cf=_0x29d460['node'][_0x207eb1(0x8a)];_0x29d460[_0x207eb1(0x84)]['parent']=_0x4c1231,_0x29d460[_0x207eb1(0x84)][_0x207eb1(0xee)]=typeof _0x34b55c==_0x207eb1(0x124)?_0x34b55c:_0x393365,_0x5392a3['push'](_0x222ce2['_property'](_0x54d2c7,_0x56e6ac,_0x34b55c,_0x29d460,_0x1020e7)),_0x29d460[_0x207eb1(0x84)][_0x207eb1(0x8a)]=_0x5064cf,_0x29d460[_0x207eb1(0x84)][_0x207eb1(0xee)]=_0xff83f7;};}[_0x30f5a2(0x138)](_0x5ada2d,_0x36f4ed,_0xae0397,_0x3c2169,_0x52f55f,_0x44199a,_0x526471){var _0x4c1b88=_0x30f5a2,_0x26f00e=this;return _0x36f4ed[_0x4c1b88(0x75)+_0x52f55f[_0x4c1b88(0xe0)]()]=!0x0,function(_0x125a54){var _0xc33a95=_0x4c1b88,_0x220db3=_0x44199a['node'][_0xc33a95(0x9d)],_0x353619=_0x44199a[_0xc33a95(0x84)]['index'],_0x466bc9=_0x44199a[_0xc33a95(0x84)][_0xc33a95(0x8a)];_0x44199a[_0xc33a95(0x84)]['parent']=_0x220db3,_0x44199a[_0xc33a95(0x84)][_0xc33a95(0xee)]=_0x125a54,_0x5ada2d[_0xc33a95(0x109)](_0x26f00e[_0xc33a95(0xc3)](_0xae0397,_0x3c2169,_0x52f55f,_0x44199a,_0x526471)),_0x44199a[_0xc33a95(0x84)][_0xc33a95(0x8a)]=_0x466bc9,_0x44199a[_0xc33a95(0x84)][_0xc33a95(0xee)]=_0x353619;};}[_0x30f5a2(0xc3)](_0x4e1b20,_0x5fe379,_0x44acb8,_0x3475d7,_0x43d5f0){var _0x2a6dae=_0x30f5a2,_0x1b0159=this;_0x43d5f0||(_0x43d5f0=function(_0x21d7e7,_0x46d009){return _0x21d7e7[_0x46d009];});var _0x4960f9=_0x44acb8[_0x2a6dae(0xe0)](),_0x40b30c=_0x3475d7[_0x2a6dae(0x100)]||{},_0x384265=_0x3475d7['depth'],_0x24b5dc=_0x3475d7[_0x2a6dae(0x147)];try{var _0x28cf4d=this['_isMap'](_0x4e1b20),_0x47646a=_0x4960f9;_0x28cf4d&&_0x47646a[0x0]==='\\\\x27'&&(_0x47646a=_0x47646a[_0x2a6dae(0xe8)](0x1,_0x47646a[_0x2a6dae(0xe9)]-0x2));var _0x8a5816=_0x3475d7[_0x2a6dae(0x100)]=_0x40b30c[_0x2a6dae(0x75)+_0x47646a];_0x8a5816&&(_0x3475d7[_0x2a6dae(0x81)]=_0x3475d7['depth']+0x1),_0x3475d7[_0x2a6dae(0x147)]=!!_0x8a5816;var _0x3d8cf8=typeof _0x44acb8==_0x2a6dae(0x126),_0x3e3ccb={'name':_0x3d8cf8||_0x28cf4d?_0x4960f9:this['_propertyName'](_0x4960f9)};if(_0x3d8cf8&&(_0x3e3ccb[_0x2a6dae(0x126)]=!0x0),!(_0x5fe379===_0x2a6dae(0xf5)||_0x5fe379===_0x2a6dae(0xaf))){var _0x5c96e4=this[_0x2a6dae(0x132)](_0x4e1b20,_0x44acb8);if(_0x5c96e4&&(_0x5c96e4['set']&&(_0x3e3ccb['setter']=!0x0),_0x5c96e4['get']&&!_0x8a5816&&!_0x3475d7[_0x2a6dae(0x128)]))return _0x3e3ccb['getter']=!0x0,this[_0x2a6dae(0x99)](_0x3e3ccb,_0x3475d7),_0x3e3ccb;}var _0x274c5b;try{_0x274c5b=_0x43d5f0(_0x4e1b20,_0x44acb8);}catch(_0x315d5f){return _0x3e3ccb={'name':_0x4960f9,'type':'unknown','error':_0x315d5f[_0x2a6dae(0xcd)]},this[_0x2a6dae(0x99)](_0x3e3ccb,_0x3475d7),_0x3e3ccb;}var _0x550e6e=this[_0x2a6dae(0x11c)](_0x274c5b),_0x3941d9=this[_0x2a6dae(0xbe)](_0x550e6e);if(_0x3e3ccb['type']=_0x550e6e,_0x3941d9)this[_0x2a6dae(0x99)](_0x3e3ccb,_0x3475d7,_0x274c5b,function(){var _0x420d89=_0x2a6dae;_0x3e3ccb[_0x420d89(0x145)]=_0x274c5b[_0x420d89(0x71)](),!_0x8a5816&&_0x1b0159['_capIfString'](_0x550e6e,_0x3e3ccb,_0x3475d7,{});});else{var _0x112568=_0x3475d7[_0x2a6dae(0xa9)]&&_0x3475d7[_0x2a6dae(0x105)]<_0x3475d7[_0x2a6dae(0xf4)]&&_0x3475d7[_0x2a6dae(0xeb)][_0x2a6dae(0xe2)](_0x274c5b)<0x0&&_0x550e6e!==_0x2a6dae(0x127)&&_0x3475d7['autoExpandPropertyCount']<_0x3475d7['autoExpandLimit'];_0x112568||_0x3475d7[_0x2a6dae(0x105)]<_0x384265||_0x8a5816?(this['serialize'](_0x3e3ccb,_0x274c5b,_0x3475d7,_0x8a5816||{}),this[_0x2a6dae(0x10e)](_0x274c5b,_0x3e3ccb)):this[_0x2a6dae(0x99)](_0x3e3ccb,_0x3475d7,_0x274c5b,function(){var _0x518332=_0x2a6dae;_0x550e6e===_0x518332(0xa6)||_0x550e6e==='undefined'||(delete _0x3e3ccb['value'],_0x3e3ccb[_0x518332(0x7c)]=!0x0);});}return _0x3e3ccb;}finally{_0x3475d7[_0x2a6dae(0x100)]=_0x40b30c,_0x3475d7[_0x2a6dae(0x81)]=_0x384265,_0x3475d7[_0x2a6dae(0x147)]=_0x24b5dc;}}[_0x30f5a2(0x107)](_0x3067ab,_0x23cf9c,_0x57463a,_0x294306){var _0x454f72=_0x30f5a2,_0x534158=_0x294306[_0x454f72(0x7e)]||_0x57463a[_0x454f72(0x7e)];if((_0x3067ab==='string'||_0x3067ab==='String')&&_0x23cf9c[_0x454f72(0x145)]){let _0x327ca2=_0x23cf9c['value'][_0x454f72(0xe9)];_0x57463a[_0x454f72(0xd6)]+=_0x327ca2,_0x57463a[_0x454f72(0xd6)]>_0x57463a['totalStrLength']?(_0x23cf9c[_0x454f72(0x7c)]='',delete _0x23cf9c[_0x454f72(0x145)]):_0x327ca2>_0x534158&&(_0x23cf9c[_0x454f72(0x7c)]=_0x23cf9c[_0x454f72(0x145)][_0x454f72(0xe8)](0x0,_0x534158),delete _0x23cf9c[_0x454f72(0x145)]);}}['_isMap'](_0x419af1){return!!(_0x419af1&&_0x1ff43a['Map']&&this['_objectToString'](_0x419af1)==='[object\\\\x20Map]'&&_0x419af1['forEach']);}['_propertyName'](_0x4d6700){var _0x44244f=_0x30f5a2;if(_0x4d6700[_0x44244f(0xd2)](/^\\\\d+$/))return _0x4d6700;var _0x2a5b1e;try{_0x2a5b1e=JSON['stringify'](''+_0x4d6700);}catch{_0x2a5b1e='\\\\x22'+this[_0x44244f(0x12b)](_0x4d6700)+'\\\\x22';}return _0x2a5b1e[_0x44244f(0xd2)](/^\\\"([a-zA-Z_][a-zA-Z_0-9]*)\\\"$/)?_0x2a5b1e=_0x2a5b1e[_0x44244f(0xe8)](0x1,_0x2a5b1e[_0x44244f(0xe9)]-0x2):_0x2a5b1e=_0x2a5b1e[_0x44244f(0xed)](/'/g,'\\\\x5c\\\\x27')[_0x44244f(0xed)](/\\\\\\\\\\\"/g,'\\\\x22')[_0x44244f(0xed)](/(^\\\"|\\\"$)/g,'\\\\x27'),_0x2a5b1e;}[_0x30f5a2(0x99)](_0x55604d,_0x567025,_0x5aeb52,_0x464480){var _0x1affcf=_0x30f5a2;this['_treeNodePropertiesBeforeFullValue'](_0x55604d,_0x567025),_0x464480&&_0x464480(),this[_0x1affcf(0x10e)](_0x5aeb52,_0x55604d),this[_0x1affcf(0x82)](_0x55604d,_0x567025);}[_0x30f5a2(0xe1)](_0x394211,_0xbef255){var _0x33f7f9=_0x30f5a2;this[_0x33f7f9(0xb5)](_0x394211,_0xbef255),this['_setNodeQueryPath'](_0x394211,_0xbef255),this[_0x33f7f9(0x134)](_0x394211,_0xbef255),this[_0x33f7f9(0x9a)](_0x394211,_0xbef255);}[_0x30f5a2(0xb5)](_0x303ef6,_0x3160df){}['_setNodeQueryPath'](_0x2fed62,_0x3d2ebb){}[_0x30f5a2(0xfc)](_0x39d7b4,_0x8c6037){}[_0x30f5a2(0xec)](_0x5af8b9){var _0x4549c2=_0x30f5a2;return _0x5af8b9===this[_0x4549c2(0x11d)];}[_0x30f5a2(0x82)](_0x459e75,_0x3e0214){var _0x11f3b4=_0x30f5a2;this[_0x11f3b4(0xfc)](_0x459e75,_0x3e0214),this[_0x11f3b4(0xce)](_0x459e75),_0x3e0214[_0x11f3b4(0x140)]&&this[_0x11f3b4(0x11f)](_0x459e75),this[_0x11f3b4(0xd5)](_0x459e75,_0x3e0214),this[_0x11f3b4(0xca)](_0x459e75,_0x3e0214),this['_cleanNode'](_0x459e75);}[_0x30f5a2(0x10e)](_0x35aa64,_0x2b85f3){var _0x35897c=_0x30f5a2;try{_0x35aa64&&typeof _0x35aa64[_0x35897c(0xe9)]=='number'&&(_0x2b85f3[_0x35897c(0xe9)]=_0x35aa64['length']);}catch{}if(_0x2b85f3[_0x35897c(0xd7)]===_0x35897c(0x124)||_0x2b85f3[_0x35897c(0xd7)]===_0x35897c(0x89)){if(isNaN(_0x2b85f3['value']))_0x2b85f3[_0x35897c(0x9f)]=!0x0,delete _0x2b85f3[_0x35897c(0x145)];else switch(_0x2b85f3[_0x35897c(0x145)]){case Number[_0x35897c(0xd1)]:_0x2b85f3[_0x35897c(0x9c)]=!0x0,delete _0x2b85f3[_0x35897c(0x145)];break;case Number[_0x35897c(0xe6)]:_0x2b85f3[_0x35897c(0x12f)]=!0x0,delete _0x2b85f3[_0x35897c(0x145)];break;case 0x0:this[_0x35897c(0x112)](_0x2b85f3[_0x35897c(0x145)])&&(_0x2b85f3[_0x35897c(0x6a)]=!0x0);break;}}else _0x2b85f3[_0x35897c(0xd7)]==='function'&&typeof _0x35aa64['name']==_0x35897c(0x85)&&_0x35aa64['name']&&_0x2b85f3['name']&&_0x35aa64[_0x35897c(0xad)]!==_0x2b85f3['name']&&(_0x2b85f3['funcName']=_0x35aa64['name']);}[_0x30f5a2(0x112)](_0x972fa8){var _0x3cd377=_0x30f5a2;return 0x1/_0x972fa8===Number[_0x3cd377(0xe6)];}[_0x30f5a2(0x11f)](_0x31bcbc){var _0x4dc88a=_0x30f5a2;!_0x31bcbc[_0x4dc88a(0xc6)]||!_0x31bcbc[_0x4dc88a(0xc6)][_0x4dc88a(0xe9)]||_0x31bcbc[_0x4dc88a(0xd7)]==='array'||_0x31bcbc['type']===_0x4dc88a(0x98)||_0x31bcbc['type']===_0x4dc88a(0xc0)||_0x31bcbc[_0x4dc88a(0xc6)][_0x4dc88a(0x69)](function(_0xbb2af0,_0x421e61){var _0x18e910=_0x4dc88a,_0x1f5dd7=_0xbb2af0[_0x18e910(0xad)][_0x18e910(0x142)](),_0x1927a9=_0x421e61[_0x18e910(0xad)]['toLowerCase']();return _0x1f5dd7<_0x1927a9?-0x1:_0x1f5dd7>_0x1927a9?0x1:0x0;});}[_0x30f5a2(0xd5)](_0x5545e0,_0x4a53b1){var _0x5a8900=_0x30f5a2;if(!(_0x4a53b1[_0x5a8900(0xd8)]||!_0x5545e0['props']||!_0x5545e0[_0x5a8900(0xc6)][_0x5a8900(0xe9)])){for(var _0x354d1c=[],_0x38153f=[],_0x11975a=0x0,_0x3209f2=_0x5545e0[_0x5a8900(0xc6)][_0x5a8900(0xe9)];_0x11975a<_0x3209f2;_0x11975a++){var _0x183b88=_0x5545e0[_0x5a8900(0xc6)][_0x11975a];_0x183b88[_0x5a8900(0xd7)]===_0x5a8900(0x127)?_0x354d1c[_0x5a8900(0x109)](_0x183b88):_0x38153f['push'](_0x183b88);}if(!(!_0x38153f[_0x5a8900(0xe9)]||_0x354d1c[_0x5a8900(0xe9)]<=0x1)){_0x5545e0[_0x5a8900(0xc6)]=_0x38153f;var _0x2b6227={'functionsNode':!0x0,'props':_0x354d1c};this[_0x5a8900(0xb5)](_0x2b6227,_0x4a53b1),this['_setNodeLabel'](_0x2b6227,_0x4a53b1),this['_setNodeExpandableState'](_0x2b6227),this[_0x5a8900(0x9a)](_0x2b6227,_0x4a53b1),_0x2b6227['id']+='\\\\x20f',_0x5545e0['props'][_0x5a8900(0xf3)](_0x2b6227);}}}[_0x30f5a2(0xca)](_0x108487,_0x3103c5){}[_0x30f5a2(0xce)](_0x2ead19){}[_0x30f5a2(0xa1)](_0x1a6fb4){var _0x25831=_0x30f5a2;return Array[_0x25831(0x68)](_0x1a6fb4)||typeof _0x1a6fb4==_0x25831(0x130)&&this['_objectToString'](_0x1a6fb4)==='[object\\\\x20Array]';}['_setNodePermissions'](_0x339bb8,_0xde15c){}[_0x30f5a2(0xf1)](_0x4a5306){var _0x598a3c=_0x30f5a2;delete _0x4a5306['_hasSymbolPropertyOnItsPath'],delete _0x4a5306[_0x598a3c(0x76)],delete _0x4a5306['_hasMapOnItsPath'];}['_setNodeExpressionPath'](_0x1e5238,_0x28fe11){}['_propertyAccessor'](_0x5d86da){var _0x56f8c3=_0x30f5a2;return _0x5d86da?_0x5d86da[_0x56f8c3(0xd2)](this['_numberRegExp'])?'['+_0x5d86da+']':_0x5d86da[_0x56f8c3(0xd2)](this[_0x56f8c3(0xac)])?'.'+_0x5d86da:_0x5d86da['match'](this[_0x56f8c3(0x11a)])?'['+_0x5d86da+']':'[\\\\x27'+_0x5d86da+'\\\\x27]':'';}}let _0x3624fa=new _0x506fed();function _0x5d0372(_0xce048b,_0x191a41,_0x5b38a3,_0x2c055e,_0x4d113a,_0x56072b){var _0x5a738b=_0x30f5a2;let _0x493190,_0x3ce0ef;try{_0x3ce0ef=_0x58c876(),_0x493190=_0x25cd04[_0x191a41],!_0x493190||_0x3ce0ef-_0x493190['ts']>0x1f4&&_0x493190['count']&&_0x493190[_0x5a738b(0xe3)]/_0x493190[_0x5a738b(0xa4)]<0x64?(_0x25cd04[_0x191a41]=_0x493190={'count':0x0,'time':0x0,'ts':_0x3ce0ef},_0x25cd04[_0x5a738b(0x13f)]={}):_0x3ce0ef-_0x25cd04[_0x5a738b(0x13f)]['ts']>0x32&&_0x25cd04[_0x5a738b(0x13f)][_0x5a738b(0xa4)]&&_0x25cd04[_0x5a738b(0x13f)][_0x5a738b(0xe3)]/_0x25cd04[_0x5a738b(0x13f)][_0x5a738b(0xa4)]<0x64&&(_0x25cd04[_0x5a738b(0x13f)]={});let _0x15a332=[],_0x289f32=_0x493190['reduceLimits']||_0x25cd04[_0x5a738b(0x13f)][_0x5a738b(0x97)]?_0x13a027:_0x4a5c24,_0xcb4d41=_0x5d3ed2=>{var _0x3f2c47=_0x5a738b;let _0x14d0b3={};return _0x14d0b3[_0x3f2c47(0xc6)]=_0x5d3ed2['props'],_0x14d0b3[_0x3f2c47(0x114)]=_0x5d3ed2[_0x3f2c47(0x114)],_0x14d0b3['strLength']=_0x5d3ed2[_0x3f2c47(0x7e)],_0x14d0b3['totalStrLength']=_0x5d3ed2[_0x3f2c47(0xb0)],_0x14d0b3[_0x3f2c47(0xdb)]=_0x5d3ed2['autoExpandLimit'],_0x14d0b3[_0x3f2c47(0xf4)]=_0x5d3ed2['autoExpandMaxDepth'],_0x14d0b3[_0x3f2c47(0x140)]=!0x1,_0x14d0b3[_0x3f2c47(0xd8)]=!_0x421515,_0x14d0b3[_0x3f2c47(0x81)]=0x1,_0x14d0b3[_0x3f2c47(0x105)]=0x0,_0x14d0b3[_0x3f2c47(0x14a)]=_0x3f2c47(0x125),_0x14d0b3['rootExpression']=_0x3f2c47(0xb1),_0x14d0b3[_0x3f2c47(0xa9)]=!0x0,_0x14d0b3[_0x3f2c47(0xeb)]=[],_0x14d0b3[_0x3f2c47(0x12e)]=0x0,_0x14d0b3[_0x3f2c47(0x128)]=!0x0,_0x14d0b3[_0x3f2c47(0xd6)]=0x0,_0x14d0b3[_0x3f2c47(0x84)]={'current':void 0x0,'parent':void 0x0,'index':0x0},_0x14d0b3;};for(var _0x120ea0=0x0;_0x120ea0<_0x4d113a[_0x5a738b(0xe9)];_0x120ea0++)_0x15a332[_0x5a738b(0x109)](_0x3624fa[_0x5a738b(0xb2)]({'timeNode':_0xce048b==='time'||void 0x0},_0x4d113a[_0x120ea0],_0xcb4d41(_0x289f32),{}));if(_0xce048b==='trace'){let _0xbbb5a6=Error[_0x5a738b(0x95)];try{Error[_0x5a738b(0x95)]=0x1/0x0,_0x15a332[_0x5a738b(0x109)](_0x3624fa['serialize']({'stackNode':!0x0},new Error()[_0x5a738b(0x10a)],_0xcb4d41(_0x289f32),{'strLength':0x1/0x0}));}finally{Error['stackTraceLimit']=_0xbbb5a6;}}return{'method':_0x5a738b(0x7f),'version':_0x4e6a4b,'args':[{'ts':_0x5b38a3,'session':_0x2c055e,'args':_0x15a332,'id':_0x191a41,'context':_0x56072b}]};}catch(_0x2eacc9){return{'method':_0x5a738b(0x7f),'version':_0x4e6a4b,'args':[{'ts':_0x5b38a3,'session':_0x2c055e,'args':[{'type':'unknown','error':_0x2eacc9&&_0x2eacc9[_0x5a738b(0xcd)]}],'id':_0x191a41,'context':_0x56072b}]};}finally{try{if(_0x493190&&_0x3ce0ef){let _0x2d4032=_0x58c876();_0x493190[_0x5a738b(0xa4)]++,_0x493190[_0x5a738b(0xe3)]+=_0x4530ef(_0x3ce0ef,_0x2d4032),_0x493190['ts']=_0x2d4032,_0x25cd04['hits'][_0x5a738b(0xa4)]++,_0x25cd04[_0x5a738b(0x13f)][_0x5a738b(0xe3)]+=_0x4530ef(_0x3ce0ef,_0x2d4032),_0x25cd04['hits']['ts']=_0x2d4032,(_0x493190[_0x5a738b(0xa4)]>0x32||_0x493190['time']>0x64)&&(_0x493190[_0x5a738b(0x97)]=!0x0),(_0x25cd04[_0x5a738b(0x13f)][_0x5a738b(0xa4)]>0x3e8||_0x25cd04[_0x5a738b(0x13f)][_0x5a738b(0xe3)]>0x12c)&&(_0x25cd04[_0x5a738b(0x13f)][_0x5a738b(0x97)]=!0x0);}}catch{}}}return _0x1ff43a[_0x30f5a2(0x13d)];})(globalThis,'127.0.0.1',_0x5b0652(0xcc),_0x5b0652(0x131),_0x5b0652(0x10d),_0x5b0652(0x88),_0x5b0652(0xd0),_0x5b0652(0xfa),_0x5b0652(0x8e));\");\n}\ncatch (e) { } }\n;\nfunction oo_oo(i, ...v) { try {\n    oo_cm().consoleLog(i, v);\n}\ncatch (e) { } return v; }\n;\noo_oo;\nfunction oo_tr(i, ...v) { try {\n    oo_cm().consoleTrace(i, v);\n}\ncatch (e) { } return v; }\n;\noo_tr;\nfunction oo_ts() { try {\n    oo_cm().consoleTime();\n}\ncatch (e) { } }\n;\noo_ts;\nfunction oo_te() { try {\n    oo_cm().consoleTimeEnd();\n}\ncatch (e) { } }\n;\noo_te; /*eslint eslint-comments/disable-enable-pair:,eslint-comments/no-unlimited-disable:,eslint-comments/no-aggregating-enable:,eslint-comments/no-duplicate-disable:,eslint-comments/no-unused-disable:,eslint-comments/no-unused-enable:,*/\n","import { Renderer } from \"./renderer\";\nimport { Scene } from \"./scene\";\nimport { Controller } from \"./controller\";\nimport { switch_latte, switch_mocha } from \"./theme_switch\";\nimport { SliceRenderer } from \"./slice_renderer\";\nconst canvas = document.getElementById(\"canv\");\nconst fps = document.getElementById(\"fps\");\nconst img = document.getElementById(\"kloppenheim_02\");\nconst slice_canvas = document.getElementById(\"slice-canvas\");\n//let camera = new FPCamera([-8.0, 0.0, 0.0], 0.0, 50.0);\nconst scene = new Scene();\nlet controller = new Controller(scene, canvas, 12, 0.0, 0.0);\nlet renderer = new Renderer(canvas, scene, controller.camera);\nscene.initialize_default_grid();\nrenderer.initialize(false);\nlet slice_renderer = new SliceRenderer(slice_canvas, scene);\nslice_renderer.slice = 6;\nslice_renderer.background = [30 / 255, 30 / 255, 46 / 255];\nslice_renderer.update();\nlet last_time = performance.now();\nlet camera_active = false;\n// const btn_renderer = <HTMLInputElement>document.getElementById(\"renderer\");\n// btn_renderer.addEventListener(\"change\", (e) => {\n//   renderer.shutdown();\n//   renderer.initialize((<HTMLInputElement>e.target).checked);\n// });\n//\naddEventListener(\"scroll\", () => {\n    // console.log(`${window.scrollY} / ${window.innerHeight}`);\n    let t = Math.min(2, window.scrollY / window.innerHeight);\n    // console.log(window.scrollY / window.innerHeight);\n    document.documentElement.style.setProperty(\"--canv-offset\", t.toString());\n    // document.documentElement.dataset.scroll = window.scrollY.toString();\n});\nrequestAnimationFrame(function tick() {\n    renderer.render();\n    const elapsed = performance.now() - last_time;\n    controller.tick(elapsed / 1000);\n    last_time = performance.now();\n    fps.innerText = Math.round((1 / elapsed) * 1000).toString() + \" fps\";\n    requestAnimationFrame(tick);\n});\naddEventListener(\"mousedown\", (e) => {\n    if (e.button == 2)\n        camera_active = true;\n});\nlet theme = \"mocha\";\nconst btn_switch_theme = document.getElementById(\"menu_switch_theme\");\nbtn_switch_theme === null || btn_switch_theme === void 0 ? void 0 : btn_switch_theme.addEventListener(\"click\", (e) => {\n    if (theme === \"mocha\") {\n        theme = \"latte\";\n        switch_latte();\n        scene.background_color = [204 / 255, 208 / 255, 218 / 255];\n        slice_renderer.set_background([204 / 255, 208 / 255, 218 / 255]);\n    }\n    else {\n        theme = \"mocha\";\n        switch_mocha();\n        scene.background_color = [30 / 255, 30 / 255, 46 / 255];\n        slice_renderer.set_background([30 / 255, 30 / 255, 46 / 255]);\n    }\n});\nscene.background_color = [30 / 255, 30 / 255, 46 / 255];\nconst btn_rescale_canvas = document.getElementById(\"menu_rescale_canvas\");\nfunction rescale() {\n    const root = document.querySelector(\":root\");\n    const scaled = Math.min(window.innerWidth, window.innerHeight) * 0.8;\n    root.style.setProperty(\"--canv-x\", scaled.toString() + \"px\");\n    root.style.setProperty(\"--canv-y\", scaled.toString() + \"px\");\n    canvas.height = scaled;\n    canvas.width = scaled;\n    renderer.shutdown();\n    renderer.initialize(renderer.pathtracing);\n}\nbtn_rescale_canvas === null || btn_rescale_canvas === void 0 ? void 0 : btn_rescale_canvas.addEventListener(\"click\", (e) => {\n    rescale();\n});\nrescale();\nconst btn_save_scene = document.getElementById(\"menu_save_scene\");\nfunction save() {\n    const file = new Blob([scene.serialize_scene()], { type: \"text/json\" });\n    const a = document.createElement(\"a\");\n    a.href = URL.createObjectURL(file);\n    a.download = \"scene.json\";\n    a.click();\n    URL.revokeObjectURL(a.href);\n}\nbtn_save_scene === null || btn_save_scene === void 0 ? void 0 : btn_save_scene.addEventListener(\"click\", e => {\n    save();\n});\nconst btn_load_scene = document.getElementById(\"menu_load_scene\");\nfunction load() {\n    const input = document.createElement(\"input\");\n    input.type = \"file\";\n    input.addEventListener(\"change\", e => {\n        const file = (input === null || input === void 0 ? void 0 : input.files)[0];\n        const reader = new FileReader();\n        reader.readAsText(file, \"UTF-8\");\n        reader.addEventListener(\"load\", e => {\n            var _a;\n            const content = (_a = e.target) === null || _a === void 0 ? void 0 : _a.result;\n            scene.deserialize_scene(content);\n        });\n    });\n    input.click();\n}\nbtn_load_scene === null || btn_load_scene === void 0 ? void 0 : btn_load_scene.addEventListener(\"click\", e => {\n    load();\n});\n//switch_latte();\n// addEventListener(\"mouseup\", (e) => {\n// \tif (e.button == 2) camera_active = false;\n// \tif (e.button == 0) {\n// \t\tconst rect = canvas.getBoundingClientRect();\n// \t\tconst x = e.clientX - rect.left;\n// \t\tconst y = e.clientY - rect.top;\n// \t\tconst hit = scene.ray_any(camera.screen_to_ray(x, y, canvas.width, canvas.height));\n// \t\tif (hit) {\n// \t\t\tlet voxel = new Voxel();\n// \t\t\tvoxel.opacity = 0;\n// \t\t\tscene.set_voxel(voxel, hit.voxel_position);\n// \t\t}\n// \t}\n// });\naddEventListener(\"contextmenu\", (e) => {\n    e.preventDefault();\n    // const rect = canvas.getBoundingClientRect();\n    // const x = e.clientX - rect.left;\n    // const y = e.clientY - rect.top;\n    // renderer.shoot_ray(x, y);\n    return false;\n});\n","import { vec2, vec3 } from \"wgpu-matrix\";\nimport { OrbitCamera } from \"./orbit_camera\";\nimport { Voxel } from \"./scene\";\nexport class Controller {\n    constructor(scene, canvas, distance, theta, phi) {\n        this.mouse_down = false;\n        this.mouse_dragged = false;\n        this.last_move = 0;\n        this.velocity = [0, 0];\n        this.selected_color = [0, 0, 0];\n        this.selected_roughness = 1;\n        this.selected_opacity = 1;\n        this.selected_lightness = 0;\n        this.camera = new OrbitCamera(distance, theta, phi);\n        this.setup();\n        this.last_move = performance.now();\n        this.last_movement = [0, 0];\n        this.scene = scene;\n        this.canvas = canvas;\n        this.selected_tool = \"place\";\n        this.blub_high = document.getElementById(\"blub_high\");\n        this.blub_low = document.getElementById(\"blub_low\");\n    }\n    tick(delta_time) {\n        this.camera.tick(delta_time);\n    }\n    setup() {\n        var _a, _b, _c, _d, _e, _f, _g;\n        addEventListener(\"mousedown\", (e) => {\n            if (e.button == 0) {\n                this.mouse_down = true;\n                this.mouse_dragged = false;\n                this.camera.dragged = true;\n                this.last_move = performance.now();\n            }\n        });\n        addEventListener(\"mouseup\", (e) => {\n            if (e.button == 0) {\n                this.mouse_down = false;\n                this.camera.dragged = false;\n                this.camera.velocity = [...this.velocity];\n                if (!this.mouse_dragged) {\n                    const rect = this.canvas.getBoundingClientRect();\n                    const x = e.clientX - rect.left;\n                    const y = e.clientY - rect.top;\n                    let voxel = this.scene.ray_any(this.camera.screen_to_ray(x, y, rect.width, rect.height));\n                    if (voxel) {\n                        switch (this.selected_tool) {\n                            case \"place\":\n                                let n_voxel = new Voxel();\n                                n_voxel.color = this.selected_color;\n                                n_voxel.roughness = this.selected_roughness;\n                                n_voxel.lightness = this.selected_lightness;\n                                n_voxel.opacity = this.selected_opacity;\n                                this.scene.set_voxel(n_voxel, voxel.voxel_position.map((val, i) => val + voxel.normal[i]));\n                                this.blub_high.play();\n                                break;\n                            case \"replace\":\n                                let r_voxel = new Voxel();\n                                r_voxel.color = this.selected_color;\n                                r_voxel.roughness = this.selected_roughness;\n                                r_voxel.lightness = this.selected_lightness;\n                                r_voxel.opacity = this.selected_opacity;\n                                this.scene.set_voxel(r_voxel, voxel.voxel_position);\n                                this.blub_high.play();\n                                break;\n                            case \"remove\":\n                                let d_voxel = new Voxel();\n                                d_voxel.opacity = 0;\n                                this.scene.set_voxel(d_voxel, voxel.voxel_position);\n                                this.blub_low.play();\n                                break;\n                        }\n                    }\n                }\n            }\n        });\n        addEventListener(\"mousemove\", (e) => {\n            this.last_movement = vec2.scale([e.movementX, e.movementY], 0.2);\n            if (this.mouse_down)\n                this.mouse_drag(e);\n            this.calculate_velocity();\n            this.last_move = performance.now();\n        });\n        (_a = document.getElementById(\"color_value\")) === null || _a === void 0 ? void 0 : _a.addEventListener(\"input\", (e) => {\n            var _a;\n            const col = e.target.value;\n            this.selected_color = vec3.scale((_a = col.match(/\\w\\w/g)) === null || _a === void 0 ? void 0 : _a.map(x => parseInt(x, 16)), 1 / 255);\n        });\n        (_b = document.getElementById(\"roughness_value\")) === null || _b === void 0 ? void 0 : _b.addEventListener(\"input\", (e) => {\n            this.selected_roughness = 1 - parseInt(e.target.value) / 100;\n        });\n        (_c = document.getElementById(\"lightness_value\")) === null || _c === void 0 ? void 0 : _c.addEventListener(\"input\", (e) => {\n            this.selected_lightness = parseInt(e.target.value) / 100;\n        });\n        (_d = document.getElementById(\"opacity_value\")) === null || _d === void 0 ? void 0 : _d.addEventListener(\"input\", (e) => {\n            this.selected_opacity = parseInt(e.target.value) / 100;\n        });\n        (_e = document.getElementById(\"tool-place-button\")) === null || _e === void 0 ? void 0 : _e.addEventListener(\"change\", (e) => {\n            this.selected_tool = \"place\";\n        });\n        (_f = document.getElementById(\"tool-replace-button\")) === null || _f === void 0 ? void 0 : _f.addEventListener(\"change\", (e) => {\n            this.selected_tool = \"replace\";\n        });\n        (_g = document.getElementById(\"tool-remove-button\")) === null || _g === void 0 ? void 0 : _g.addEventListener(\"change\", (e) => {\n            this.selected_tool = \"remove\";\n        });\n    }\n    calculate_velocity() {\n        const t = performance.now() - this.last_move;\n        vec2.scale(this.last_movement, 1 / t, this.velocity);\n    }\n    mouse_drag(e) {\n        this.camera.eulers[1] = this.camera.eulers[1] - this.last_movement[1];\n        this.camera.eulers[2] = this.camera.eulers[2] - this.last_movement[0];\n        // this.camera.velocity = [e.movementY, e.movementX];\n        this.mouse_dragged = true;\n    }\n}\n","export default \"const light_scatter_samples: i32 = 2;\\r\\n\\r\\nfn gamma_correct(color: vec3<f32>) -> vec3<f32> {\\r\\n    let correction = 1.0 / f32(samples);\\r\\n    return sqrt(correction * color);\\r\\n}\\r\\n\\r\\nfn trace(ray: Ray, depth: i32) -> vec3<f32> {\\r\\n\\tif (depth <= 0) {\\r\\n\\t\\treturn vec3<f32>(0);\\r\\n\\t}\\r\\n\\t\\tvar accum: vec3<f32> = vec3<f32>(0.0);\\r\\n\\t\\tvar mask: vec3<f32> = vec3<f32>(1.0);\\r\\n\\t\\tvar curr_ray: Ray = ray;\\r\\n\\t\\tvar curr_hit: RayHit;\\r\\n\\t\\tvar refl: f32 = 1.0;\\r\\n\\t\\tvar hits: i32 = 0;\\r\\n\\r\\n\\t\\tvar bounce_results: array<RayHit, light_bounces>;\\r\\n\\r\\n\\t\\tfor (; hits < light_bounces;){\\r\\n\\t\\t\\tif (voxel_ray_any(curr_ray, 0.0001, &curr_hit)) {\\r\\n\\t\\t\\t\\tlet bounce_direction = random_unit_vector() + curr_hit.normal;\\r\\n\\t\\t\\t\\tif (all(bounce_direction == vec3<f32>(0))){\\r\\n\\t\\t\\t\\t\\tcurr_ray = Ray(curr_hit.position, curr_hit.normal, 1 / curr_hit.normal);\\r\\n\\t\\t\\t\\t} else {\\r\\n\\t\\t\\t\\t\\tlet normalized = normalize(bounce_direction);\\r\\n\\t\\t\\t\\t\\tcurr_ray = Ray(curr_hit.position, normalized, 1 / normalized);\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\tbounce_results[hits] = curr_hit;\\r\\n\\t\\t\\t\\thits++;\\r\\n\\t\\t\\t} else {\\r\\n\\t\\t\\t\\t// accum = pow(textureSampleLevel(hdr_tex, hdr_sampler, sample_spherical_map(curr_ray.direction), 0.0).rgb, vec3<f32>(2)) * 5;\\r\\n\\t\\t\\t\\taccum = vec3<f32>(pow(max(0, dot(curr_ray.direction, scene.direct_light) - 0.98) * 40, 1));\\r\\n\\t\\t\\t\\tbreak;\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif (hits == 0){\\r\\n\\t\\t\\t// return textureSampleLevel(hdr_tex, hdr_sampler, sample_spherical_map(ray.direction), 0.0).rgb;\\r\\n\\t\\t\\treturn vec3<f32>(pow(max(0, dot(ray.direction, scene.direct_light) - 0.95) * 20, 1));\\r\\n\\t\\t}\\r\\n\\t\\tif (hits == light_bounces){\\r\\n\\t\\t\\taccum = vec3<f32>(0, 0, 0);\\r\\n\\t\\t} else {\\r\\n\\t\\t\\t// accum = textureSampleLevel(hdr_tex, hdr_sampler, sample_spherical_map(bounce_results[hits - 1].ray_direction), 0.0).rgb;\\r\\n\\t\\t\\t/* accum = vec3<f32>(max(0, dot(bounce_results[hits - 1].ray_direction, scene.direct_light))); */\\r\\n\\t\\t\\t// accum = vec3<f32>(0);\\r\\n\\t\\t}\\r\\n\\t\\tfor (var i: i32 = hits - 1; i >= 0; i--){\\r\\n\\t\\t\\tlet bounce = bounce_results[i];\\r\\n\\t\\t\\t/* accum = min(vec3<f32>(1), accum) * min(vec3<f32>(1), bounce.voxel.color); */\\r\\n\\t\\t\\taccum = accum * bounce.voxel.color\\r\\n\\t\\t\\t\\t+ bounce_results[i].voxel.lightness * bounce_results[i].voxel.color;\\r\\n\\t\\t\\t// if (all(bounce.normal == vec3<f32>(0)) && all(bounce.ray_direction == vec3<f32>(0))){\\r\\n\\t\\t\\t// \\t// accum = textureSampleLevel(hdr_tex, hdr_sampler, sample_spherical_map(bounce_results[i].ray_direction), 0.0).rgb;\\r\\n\\t\\t\\t// \\taccum = vec3<f32>(0.5);\\r\\n\\t\\t\\t// \\tcontinue;\\r\\n\\t\\t\\t// }\\r\\n\\t\\t\\t// accum = accum * bounce.voxel.color;\\r\\n\\t\\t\\t// accum = accum * bounce.voxel.color;\\r\\n\\t\\t}\\r\\n\\treturn accum; // / f32(light_scatter_samples);\\r\\n}\\r\\n\\r\\nfn direct_illumination(orig_hit: RayHit, refl: ptr<function, f32>) -> vec3<f32> {\\r\\n\\tvar hit: RayHit;\\r\\n\\tif (!voxel_ray_any(Ray(orig_hit.position, scene.direct_light, 1 / scene.direct_light), 0.00001, &hit)){\\r\\n\\t\\treturn scene.direct_light_brightness * orig_hit.voxel.color;\\r\\n\\t} else {\\r\\n\\t\\treturn 0.2 * orig_hit.voxel.color;\\r\\n\\t}\\r\\n}\\r\\n\\r\\nfn voxel_ray_any(ray: Ray, start_tolerance: f32, hit: ptr<function, RayHit>) -> bool {\\r\\n\\tvar tmin: f32 = 0.0;\\r\\n\\tvar tmax: f32 = 300000000;\\r\\n\\tfor (var d: i32 = 0; d < 3; d++) {\\r\\n\\t\\tlet t1 = (boundary_min[d] - ray.origin[d]) * ray.inv_direction[d];\\r\\n\\t\\tlet t2 = (boundary_max[d] - ray.origin[d]) * ray.inv_direction[d];\\r\\n\\r\\n\\t\\ttmin = min(max(t1, tmin), max(t2, tmin));\\r\\n\\t\\ttmax = max(min(t1, tmax), min(t2, tmax));\\r\\n\\t}\\r\\n\\t// Hier ist noch ein Fehler drin, tritt nur von ausserhalb des grid auf, das kommt ja vielleicht eh noch weg\\r\\n\\tif tmin > tmax { return false; }\\r\\n    \\tlet ray_entry = ray.origin + ray.direction * tmin;\\r\\n\\tlet ray_exit = ray.origin + ray.direction * tmax;\\r\\n\\r\\n\\tvar voxel: vec3<i32> = max(vec3<i32>(0), min(vec3<i32>(voxel_count - 1), vec3<i32>((ray_entry - boundary_min) / f32(voxel_size))));\\r\\n\\t//var end_voxel: vec3<i32> = max(vec3<i32>(0), min(vec3<i32>(voxel_count - 1), vec3<i32>((ray_exit - boundary_min - ray.direction * 0.000001) / f32(voxel_size))));\\r\\n\\r\\n\\tlet direction_zeros: vec3<bool> = ray.direction == vec3<f32>(0);\\r\\n\\tlet step: vec3<i32> = vec3<i32>(sign(ray.direction));\\r\\n\\tlet tdelta: vec3<f32> = select(voxel_size / abs(ray.direction), vec3<f32>(tmax), direction_zeros);\\r\\n\\tlet voxel_boundary: vec3<f32> = vec3<f32>(voxel + max(vec3<i32>(0), step)) * voxel_size;\\r\\n\\tvar tmax_comp: vec3<f32> = select(tmin + (boundary_min + voxel_boundary - ray_entry) / ray.direction, vec3<f32>(tmax), direction_zeros);\\r\\n\\tvar thit: f32 = tmin;\\r\\n\\tvar hit_normal: vec3<f32> = vec3<f32>(0, 0, 0);\\r\\n\\r\\n\\twhile(all(voxel >= vec3<i32>(0)) && all(voxel < vec3<i32>(voxel_count))) {\\r\\n\\t\\tlet hit_voxel = get_voxel(voxel);\\r\\n\\t\\tif (hit_voxel.opacity > 0.01 && all(tmax_comp > vec3<f32>(start_tolerance))){\\r\\n\\t\\t\\t(*hit).position = ray.origin + ray.direction * thit;\\r\\n\\t\\t\\t(*hit).voxel = hit_voxel;\\r\\n\\t\\t\\t(*hit).voxel_position = voxel;\\r\\n\\t\\t\\t(*hit).depth = 1 - (thit - depth_clip_min) / (depth_clip_max - depth_clip_min);\\r\\n\\t\\t\\t(*hit).normal = hit_normal;\\r\\n\\t\\t\\t(*hit).ray_direction = ray.direction;\\r\\n\\t\\t\\treturn true;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif (tmax_comp.x < tmax_comp.y && tmax_comp.x < tmax_comp.z) {\\r\\n\\t\\t\\tvoxel.x += step.x;\\r\\n\\t\\t\\tthit = tmax_comp.x;\\r\\n\\t\\t\\ttmax_comp.x += tdelta.x;\\r\\n\\t\\t\\thit_normal = vec3<f32>(f32(-step.x), 0, 0);\\r\\n\\t\\t} else if (tmax_comp.y < tmax_comp.z){\\r\\n\\t\\t\\tvoxel.y += step.y;\\r\\n\\t\\t\\tthit = tmax_comp.y;\\r\\n\\t\\t\\ttmax_comp.y += tdelta.y;\\r\\n\\t\\t\\thit_normal = vec3<f32>(0, f32(-step.y), 0);\\r\\n\\t\\t} else {\\r\\n\\t\\t\\tvoxel.z += step.z;\\r\\n\\t\\t\\tthit = tmax_comp.z;\\r\\n\\t\\t\\ttmax_comp.z += tdelta.z;\\r\\n\\t\\t\\thit_normal = vec3<f32>(0, 0, f32(-step.z));\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\treturn false;\\r\\n}\\r\\n\"","export default \"const ao_samples: i32 = 20;\\r\\nconst ao_range: f32 = 0.2;\\r\\n\\r\\nstruct penetration {\\r\\n\\tcolor: vec3<f32>,\\r\\n\\tao: f32,\\r\\n\\topacity: f32,\\r\\n}\\r\\n\\r\\nfn gamma_correct(color: vec3<f32>) -> vec3<f32> {\\r\\n    return color / f32(samples);\\r\\n}\\r\\n\\r\\nfn trace(ray: Ray, depth: i32) -> vec3<f32> {\\r\\n\\tvar hit: RayHit;\\r\\n\\tvar bounces: array<RayHit, reflection_bounces>;\\r\\n\\tvar curr_ray = ray;\\r\\n\\tvar hits: i32 = 0;\\r\\n\\tvar has_next_ray = true;\\r\\n\\tvar penetrations: array<penetration, max_penetrations>;\\r\\n\\tvar penetration_count = 0;\\r\\n\\r\\n\\tfor (var p = 0; p < max_penetrations; p++){\\r\\n\\t\\tvar color = vec3<f32>(0.0);\\r\\n\\t\\tvar ao = 0f;\\r\\n\\t\\tvar first_hit: RayHit;\\r\\n\\t\\tfor (var i = 0; i < reflection_bounces; i++){\\r\\n\\t\\t\\tif(voxel_ray_any(curr_ray, 0.001, &hit)){\\r\\n\\t\\t\\t\\t// return TraceResult(vec3<f32>(hit.uv.x), 0.0);\\r\\n\\t\\t\\t\\tbounces[i] = hit;\\r\\n\\t\\t\\t\\tcurr_ray = ray_reflect(curr_ray, hit.position, hit.normal);\\r\\n\\t\\t\\t\\thits++;\\r\\n\\t\\t\\t\\tif (i == 0){\\r\\n\\t\\t\\t\\t\\tfirst_hit = hit;\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\tif (hit.voxel.roughness > 0.99){\\r\\n\\t\\t\\t\\t\\tbreak;\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t} else {\\r\\n\\t\\t\\t\\t// return TraceResult(vec3<f32>(0.1), 0.0);\\r\\n\\t\\t\\t\\tcolor = scene.background_color;\\r\\n\\t\\t\\t\\tbreak;\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t\\tif (hits == 0){\\r\\n\\t\\t\\tbreak;\\r\\n\\t\\t\\t// return background;\\r\\n\\t\\t\\t// return ray.direction;\\r\\n\\t\\t}\\r\\n\\t\\t// return vec3<f32>(0.2, 0.4, 0.5);\\r\\n\\t\\t// return vec3<f32>(bounces[0].uv.x, bounces[0].uv.y, 0.0);\\r\\n\\r\\n\\t\\tfor (var i: i32 = hits; i >= 0; i--){\\r\\n\\t\\t\\t\\t// return TraceResult(vec3<f32>(0.5), 0.0);\\r\\n\\t\\t\\t// return TraceResult(vec3<f32>(bounces[i].uv.x), 0.0);\\r\\n\\t\\t\\tlet t = bounces[i].voxel.roughness;\\r\\n\\t\\t\\tcolor = color * (1 - t) + t * bounces[i].voxel.color * illumination(bounces[i].position);\\r\\n\\t\\t\\tif (i == 0){\\r\\n\\t\\t\\t\\t//ao = get_point_ao(bounces[0].position);\\r\\n\\t\\t\\t\\tao = 0;\\r\\n\\t\\t\\t\\tlet nrm = vec3<i32>(bounces[i].normal);\\r\\n\\t\\t\\t\\tlet uv = bounces[i].uv;\\r\\n\\t\\t\\t\\tlet am = voxel_ao(bounces[i].voxel_position + nrm, nrm.zxy, nrm.yzx);\\r\\n\\t\\t\\t\\tao = mix(mix(am.z, am.w, uv.x), mix(am.y, am.x, uv.x), uv.y);\\r\\n\\t\\t\\t\\t// return vec3<f32>(uv.x / 10 + interp_ao, uv.y / 10 + interp_ao, interp_ao) / 2;\\r\\n\\t\\t\\t\\t// return vec3<f32>(interp_ao);\\r\\n\\t\\t\\t\\t// let interp_ao = \\r\\n\\t\\t\\t\\t// ao = get_point_ao_lambert(bounces[0].position, bounces[0].normal);\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\t\\r\\n\\t\\t\\tfor (var l: i32 = 0; l < i32(scene.light_count); l++){\\r\\n\\t\\t\\t\\tlet light = lights.data[l];\\r\\n\\t\\t\\t\\tif i32(light.emitter_type) == 0 {\\r\\n\\t\\t\\t\\t\\tlet light_voxel = get_voxel(vec3<i32>(light.location));\\r\\n\\t\\t\\t\\t\\tlet light_voxel_location = light.location * voxel_size + boundary_min;\\r\\n\\t\\t\\t\\t\\tlet light_voxel_location_top = light_voxel_location + voxel_size;\\r\\n\\t\\t\\t\\t\\tlet light_voxel_location_mid = (light_voxel_location + light_voxel_location_top) / 2;\\r\\n\\t\\t\\t\\t\\tlet lray_dir = light_voxel_location_mid - bounces[i].position;\\r\\n\\t\\t\\t\\t\\tlet lray = Ray(bounces[i].position, lray_dir, 1 / lray_dir);\\r\\n\\t\\t\\t\\t\\tvar lhit: RayHit;\\r\\n\\t\\t\\t\\t\\tif (voxel_ray_any(lray, 0.001, &lhit) && all(lhit.voxel_position == vec3<i32>(light.location))){\\r\\n\\t\\t\\t\\t\\t\\tlet dist = distance(light_voxel_location_mid, bounces[i].position);\\r\\n\\t\\t\\t\\t\\t\\tlet intensity = 1 / pow(dist, 2) * lhit.voxel.lightness;\\r\\n\\t\\t\\t\\t\\t\\tcolor += light_voxel.color * vec3<f32>(intensity) * bounces[i].voxel.color;\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\t\\r\\n\\t\\t\\t// let vox = bounces[i].voxel_position;\\r\\n\\t\\t\\t// let gi_vox = vox + vec3<i32>(bounces[i].normal);\\r\\n\\t\\t\\t// color += get_meta_voxel(gi_vox).gi / 5;\\r\\n\\t\\t}\\r\\n\\t\\tpenetrations[p] = penetration(color, ao, first_hit.voxel.opacity);\\r\\n\\t\\tpenetration_count++;\\r\\n\\t\\tcurr_ray = Ray(first_hit.exit_position, ray.direction, ray.inv_direction);\\r\\n\\t\\tif (first_hit.voxel.opacity > 0.99){\\r\\n\\t\\t\\tbreak;\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\tif (penetration_count == 0){\\r\\n\\t\\treturn scene.background_color;\\r\\n\\t\\t// return TraceResult(scene.background_color, 0);\\r\\n\\t}\\r\\n\\r\\n\\tvar color = penetrations[penetration_count].color;\\r\\n\\tvar ao = penetrations[penetration_count].ao;\\r\\n\\tfor (var i: i32 = penetration_count - 1; i >= 0; i--){\\r\\n\\t\\tcolor = penetrations[i].color * penetrations[i].opacity + color * (1 - penetrations[i].opacity);\\r\\n\\t\\tao = penetrations[i].ao * penetrations[i].opacity + ao * (1 - penetrations[i].opacity);\\r\\n\\t}\\r\\n\\r\\n\\treturn color * ao;\\r\\n\\t// return TraceResult(color, ao);\\r\\n\\t// return vec3<f32>(ao);\\r\\n}\\r\\n\\r\\nfn illumination(p: vec3<f32>) -> f32 {\\r\\n\\tvar hit: RayHit;\\r\\n\\tif (!voxel_ray_any(Ray(p, scene.direct_light, 1 / scene.direct_light), 0.001, &hit)){\\r\\n\\t\\treturn scene.direct_light_brightness;\\r\\n\\t}\\r\\n\\treturn 0.2;\\r\\n}\\r\\n\\r\\nfn voxel_ray_any(ray: Ray, start_tolerance: f32, hit: ptr<function, RayHit>) -> bool {\\r\\n\\tvar tmin: f32 = 0.0;\\r\\n\\tvar tmax: f32 = 300000000;\\r\\n\\tfor (var d: i32 = 0; d < 3; d++) {\\r\\n\\t\\tlet t1 = (boundary_min[d] - ray.origin[d]) * ray.inv_direction[d];\\r\\n\\t\\tlet t2 = (boundary_max[d] - ray.origin[d]) * ray.inv_direction[d];\\r\\n\\r\\n\\t\\ttmin = min(max(t1, tmin), max(t2, tmin));\\r\\n\\t\\ttmax = max(min(t1, tmax), min(t2, tmax));\\r\\n\\t}\\r\\n\\t// Hier ist noch ein Fehler drin, tritt nur von ausserhalb des grid auf, das kommt ja vielleicht eh noch weg\\r\\n\\tif tmin > tmax { return false; }\\r\\n    \\tlet ray_entry = ray.origin + ray.direction * tmin;\\r\\n\\tlet ray_exit = ray.origin + ray.direction * tmax;\\r\\n\\r\\n\\tvar voxel: vec3<i32> = max(vec3<i32>(0), min(vec3<i32>(voxel_count - 1), vec3<i32>((ray_entry - boundary_min) / f32(voxel_size))));\\r\\n\\t//var end_voxel: vec3<i32> = max(vec3<i32>(0), min(vec3<i32>(voxel_count - 1), vec3<i32>((ray_exit - boundary_min - ray.direction * 0.000001) / f32(voxel_size))));\\r\\n\\r\\n\\tlet direction_zeros: vec3<bool> = ray.direction == vec3<f32>(0);\\r\\n\\tlet vstep: vec3<i32> = vec3<i32>(sign(ray.direction));\\r\\n\\tlet tdelta: vec3<f32> = select(voxel_size / abs(ray.direction), vec3<f32>(tmax), direction_zeros);\\r\\n\\tlet voxel_boundary: vec3<f32> = vec3<f32>(voxel + max(vec3<i32>(0), vstep)) * voxel_size;\\r\\n\\tvar tmax_comp: vec3<f32> = select(tmin + (boundary_min + voxel_boundary - ray_entry) / ray.direction, vec3<f32>(tmax), direction_zeros);\\r\\n\\tvar thit: f32 = tmin;\\r\\n\\tvar hit_normal: vec3<f32> = vec3<f32>(0, 0, 0);\\r\\n\\tvar mask: vec3<f32>;\\r\\n\\r\\n\\twhile(all(voxel >= vec3<i32>(0)) && all(voxel < vec3<i32>(voxel_count))) {\\r\\n\\t\\tlet hit_voxel = get_voxel(voxel);\\r\\n\\t\\tif (hit_voxel.opacity > 0.01 && all(tmax_comp > vec3<f32>(start_tolerance))){\\r\\n\\t\\t\\t(*hit).position = ray.origin + ray.direction * thit;\\r\\n\\t\\t\\t(*hit).voxel = hit_voxel;\\r\\n\\t\\t\\t(*hit).voxel_position = voxel;\\r\\n\\t\\t\\t(*hit).depth = 1 - (thit - depth_clip_min) / (depth_clip_max - depth_clip_min);\\r\\n\\t\\t\\t(*hit).normal = hit_normal;\\r\\n\\t\\t\\t(*hit).ray_direction = ray.direction;\\r\\n\\t\\t\\t// let v_diff = (*hit).position - (vec3<f32>(voxel) * voxel_size - boundary_min);\\r\\n\\t\\t\\tlet uv = (((*hit).position - boundary_min) - (vec3<f32>(voxel) * voxel_size)) / voxel_size;\\r\\n\\t\\t\\tlet uvx = select(vec3<f32>(1) * mask - mask * uv.yzx, mask * uv.yzx, sign(ray.direction) < vec3<f32>(0));\\r\\n\\t\\t\\tlet uvy = select(vec3<f32>(1) * mask - mask * uv.zxy, mask * uv.zxy, sign(ray.direction) < vec3<f32>(0));\\r\\n\\t\\t\\t// let uvy = mask * uv.zxy;\\r\\n\\t\\t\\t(*hit).uv = vec2<f32>(\\r\\n\\t\\t\\t\\tmax(uvx.x, max(uvx.y, uvx.z)),\\r\\n\\t\\t\\t\\tmax(uvy.x, max(uvy.y, uvy.z)),\\r\\n\\t\\t\\t\\t// dot(mask * v_diff.zxy, vec3<f32>(voxel_size)) / voxel_size,\\r\\n\\t\\t\\t);\\r\\n\\t\\t\\tlet next_mask = step(tmax_comp.xyz, tmax_comp.yzx) * step(tmax_comp.xyz, tmax_comp.zxy);\\r\\n\\t\\t\\tlet tmax_masked = vec3<f32>(next_mask) * tmax_comp;\\r\\n\\t\\t\\t(*hit).exit_position = ray.origin + ray.direction * max(tmax_masked.x, max(tmax_masked.y, tmax_masked.z));\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t// if (tmax_comp.x < tmax_comp.y && tmax_comp.x < tmax_comp.z) {\\r\\n\\t\\t\\t// \\t(*hit).exit_position = ray.origin + ray.direction * tmax_comp.x;\\r\\n\\t\\t\\t// } else if (tmax_comp.y < tmax_comp.z){\\r\\n\\t\\t\\t// \\t(*hit).exit_position = ray.origin + ray.direction * tmax_comp.y;\\r\\n\\t\\t\\t// } else {\\r\\n\\t\\t\\t// \\t(*hit).exit_position = ray.origin + ray.direction * tmax_comp.z;\\r\\n\\t\\t\\t// }\\r\\n\\t\\t\\treturn true;\\r\\n\\t\\t}\\r\\n\\t\\tmask = step(tmax_comp.xyz, tmax_comp.yzx) * step(tmax_comp.xyz, tmax_comp.zxy);\\r\\n\\t\\tvoxel += vstep * vec3<i32>(mask);\\r\\n\\t\\tlet tmax_masked = vec3<f32>(mask) * tmax_comp;\\r\\n\\t\\tthit = max(tmax_masked.x, max(tmax_masked.y, tmax_masked.z));\\r\\n\\t\\thit_normal = -(vec3<f32>(vstep) * mask);\\r\\n\\t\\ttmax_comp += mask * tdelta;\\r\\n\\t}\\r\\n\\r\\n\\treturn false;\\r\\n}\\r\\n\\r\\nfn voxel_ao(pos: vec3<i32>, d1: vec3<i32>, d2: vec3<i32>) -> vec4<f32> {\\r\\n\\tlet side = vec4<f32>(get_voxel(pos + d1).opacity, get_voxel(pos + d2).opacity, get_voxel(pos - d1).opacity, get_voxel(pos - d2).opacity);\\r\\n\\tlet corner = vec4<f32>(get_voxel(pos + d1 + d2).opacity, get_voxel(pos - d1 + d2).opacity, get_voxel(pos - d1 - d2).opacity, get_voxel(pos + d1 - d2).opacity);\\r\\n\\tlet ao = vec4<f32>(\\r\\n\\t\\tvertex_ao(side.xy, corner.x),\\r\\n\\t\\tvertex_ao(side.yz, corner.y),\\r\\n\\t\\tvertex_ao(side.zw, corner.z),\\r\\n\\t\\tvertex_ao(side.wx, corner.w),\\r\\n\\t);\\r\\n\\treturn 1.0 - ao * 0.8;\\r\\n}\\r\\n\\r\\nfn vertex_ao(side: vec2<f32>, corner: f32) -> f32 {\\r\\n\\t// return (side.x + side.y) / 2.0;\\r\\n\\treturn max(side.x + side.y, max(corner, side.x * side.y)) / 2;\\r\\n\\treturn (side.x + side.y + max(corner, side.x * side.y)) / 3.0;\\r\\n}\\r\\n\\r\\nfn get_point_ao_lambert(point: vec3<f32>, normal: vec3<f32>) -> f32 {\\r\\n\\tvar ao: f32 = 0.0;\\r\\n\\tfor (var i = 0; i < ao_samples; i++) {\\r\\n\\t\\tlet sample_point = (random_unit_vector() + normal) * rng() * voxel_size * 0.6 + point ;\\r\\n\\t\\tao += get_voxel_by_position(sample_point).opacity;\\r\\n\\t}\\r\\n\\treturn max(0, ao / f32(ao_samples));\\r\\n}\\r\\n\\r\\nfn get_point_ao(point: vec3<f32>) -> f32 {\\r\\n\\tvar ao: f32 = 0.0;\\r\\n\\tfor (var i = 0; i < ao_samples; i++) {\\r\\n\\t\\tlet sample_point = random_unit_vector() * rng() * ao_range + point;\\r\\n\\t\\tao += get_voxel_by_position(sample_point).opacity;\\r\\n\\t}\\r\\n\\treturn max(0, ao / f32(ao_samples) - 0.5);\\r\\n}\\r\\n\"","export function switch_latte() {\n    const root = document.querySelector(\":root\");\n    document.documentElement.dataset.theme = \"latte\";\n    root.style.setProperty(\"--ctp-crust\", \"#dce0e8\");\n    root.style.setProperty(\"--ctp-mantle\", \"#e6e9ef\");\n    root.style.setProperty(\"--ctp-base\", \"#eff1f5\");\n    root.style.setProperty(\"--ctp-surface0\", \"#ccd0da\");\n    root.style.setProperty(\"--ctp-surface1\", \"#bcc0cc\");\n    root.style.setProperty(\"--ctp-surface2\", \"#acb0be\");\n    root.style.setProperty(\"--ctp-overlay0\", \"#9ca0b0\");\n    root.style.setProperty(\"--ctp-overlay1\", \"#8c8fa1\");\n    root.style.setProperty(\"--ctp-overlay2\", \"#7c7f93\");\n    root.style.setProperty(\"--ctp-subtext0\", \"#6c6f85\");\n    root.style.setProperty(\"--ctp-subtext1\", \"#5c5f77\");\n    root.style.setProperty(\"--ctp-text\", \"#4c4f69\");\n    root.style.setProperty(\"--ctp-lavender\", \"#7287fd\");\n    root.style.setProperty(\"--ctp-blue\", \"#1e66f5\");\n    root.style.setProperty(\"--ctp-sapphire\", \"#209fb5\");\n    root.style.setProperty(\"--ctp-sky\", \"#04a5e5\");\n    root.style.setProperty(\"--ctp-teal\", \"#179299\");\n    root.style.setProperty(\"--ctp-green\", \"#40a02b\");\n    root.style.setProperty(\"--ctp-yellow\", \"#df8e1d\");\n    root.style.setProperty(\"--ctp-peach\", \"#fe640b\");\n    root.style.setProperty(\"--ctp-maroon\", \"#e64553\");\n    root.style.setProperty(\"--ctp-red\", \"#d20f39\");\n    root.style.setProperty(\"--ctp-mauve\", \"#8839ef\");\n    root.style.setProperty(\"--ctp-pink\", \"#ea76cb\");\n    root.style.setProperty(\"--ctp-flamingo\", \"#dd7878\");\n    root.style.setProperty(\"--ctp-rosewater\", \"#dc8a78\");\n}\nexport function switch_mocha() {\n    const root = document.querySelector(\":root\");\n    document.documentElement.dataset.theme = \"mocha\";\n    root.style.setProperty(\"--ctp-crust\", \"#11111b\");\n    root.style.setProperty(\"--ctp-mantle\", \"#181825\");\n    root.style.setProperty(\"--ctp-base\", \"#1e1e2e\");\n    root.style.setProperty(\"--ctp-surface0\", \"#313244\");\n    root.style.setProperty(\"--ctp-surface1\", \"#45475a\");\n    root.style.setProperty(\"--ctp-surface2\", \"#585b70\");\n    root.style.setProperty(\"--ctp-overlay0\", \"#6c7086\");\n    root.style.setProperty(\"--ctp-overlay1\", \"#7f849c\");\n    root.style.setProperty(\"--ctp-overlay2\", \"#9399b2\");\n    root.style.setProperty(\"--ctp-subtext0\", \"#a6adc8\");\n    root.style.setProperty(\"--ctp-subtext1\", \"#bac2de\");\n    root.style.setProperty(\"--ctp-text\", \"#cdd6f4\");\n    root.style.setProperty(\"--ctp-lavender\", \"#b4befe\");\n    root.style.setProperty(\"--ctp-blue\", \"#89b4fa\");\n    root.style.setProperty(\"--ctp-sapphire\", \"#74c7ec\");\n    root.style.setProperty(\"--ctp-sky\", \"#89dceb\");\n    root.style.setProperty(\"--ctp-teal\", \"#94e2d5\");\n    root.style.setProperty(\"--ctp-green\", \"#a6e3a1\");\n    root.style.setProperty(\"--ctp-yellow\", \"#f9e2af\");\n    root.style.setProperty(\"--ctp-peach\", \"#fab387\");\n    root.style.setProperty(\"--ctp-maroon\", \"#eba0ac\");\n    root.style.setProperty(\"--ctp-red\", \"#f38ba8\");\n    root.style.setProperty(\"--ctp-mauve\", \"#cba6f7\");\n    root.style.setProperty(\"--ctp-pink\", \"#f5c2e7\");\n    root.style.setProperty(\"--ctp-flamingo\", \"#f2cdcd\");\n    root.style.setProperty(\"--ctp-rosewater\", \"#f5e0dc\");\n}\n"],"names":["__awaiter","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","value","step","next","e","rejected","result","done","then","apply","EPSILON","VecType$2","Float32Array","create$5","x","y","dst","undefined","fromValues$3","subtract$3","a","b","sub$3","mulScalar$3","v","k","scale$5","inverse$5","invert$4","dot$3","length$3","v0","v1","Math","sqrt","len$3","lengthSq$3","lenSq$3","distance$2","dx","dy","dist$2","distanceSq$2","distSq$2","copy$5","clone$5","multiply$5","mul$5","divide$2","div$2","vec2Impl","Object","freeze","__proto__","add","addScaled","scale","angle","ax","ay","bx","by","mag","cosine","acos","ceil","clamp","min","max","clone","copy","create","cross","z","dist","distSq","distance","distanceSq","div","divScalar","divide","dot","equals","equalsApproximately","abs","floor","fromValues","inverse","invert","len","lenSq","length","lengthSq","lerp","t","lerpV","mul","mulScalar","multiply","negate","normalize","random","PI","cos","sin","round","setDefaultType","ctor","oldType","sub","subtract","transformMat3","m","transformMat4","zero","Map","Float64Array","Array","fill","get","VecType$1","create$3","fromValues$2","subtract$2","sub$2","mulScalar$2","scale$3","inverse$3","invert$2","dot$2","length$2","v2","len$2","lengthSq$2","lenSq$2","distance$1","dz","dist$1","distanceSq$1","distSq$1","copy$3","clone$3","multiply$3","mul$3","divide$1","div$1","vec3Impl","az","bz","t1","t2","getAxis","axis","off","getScaling","xx","xy","xz","yx","yy","yz","zx","zy","zz","getTranslation","zScale","w","transformMat4Upper3x3","Ray","constructor","origin","direction","this","inv_direction","RayHit","position","voxel_position","voxel","normal","Voxel","color","opacity","roughness","lightness","MetaVoxel","gi","Deg2Rad","theta","OrbitCamera","phi","dragged","velocity","forward","right","up","eulers","update","tick","delta_time","screen_to_ray","sx","sy","horizontal_coefficient","vertical_coefficient","ray_direction","oo_oo","i","eval","oo_cm","consoleLog","canvas","document","getElementById","fps","slice_canvas","scene","grid_size","voxel_count","grid","meta_grid","boundary_min","boundary_max","voxel_size","initialize_grid","direct_light","direct_light_brightness","background_color","serialize_scene","JSON","stringify","deserialize_scene","s","parse","vox","mvox","initialize_default_grid","set_voxel_comp","calc_gi","ray","get_voxel_center","ray_any","get_voxel_id","tmin","tmax","Infinity","d","ray_entry","ray_exit","voxel_upper_edge","tmax_comp","tdelta","end_voxel","thit","hit_normal","get_voxel","hit_position","get_voxel_id_comp","get_voxel_comp","set_voxel","controller","mouse_down","mouse_dragged","last_move","selected_color","selected_roughness","selected_opacity","selected_lightness","camera","setup","performance","now","last_movement","selected_tool","blub_high","blub_low","_a","_b","_c","_d","_e","_f","_g","addEventListener","button","rect","getBoundingClientRect","clientX","left","clientY","top","width","height","n_voxel","map","val","play","r_voxel","d_voxel","movementX","movementY","mouse_drag","calculate_velocity","col","target","match","parseInt","renderer","initialized","render","lights","push","device","queue","writeBuffer","sceneParameters","Date","getMilliseconds","light_data","lightData","scene_data","scene_meta_data","sceneData","sceneMetaData","commandEncoder","createCommandEncoder","ray_trace_pass","beginComputePass","setPipeline","ray_tracing_pipeline","setBindGroup","ray_tracing_bind_group","dispatchWorkgroups","end","textureView","context","getCurrentTexture","createView","renderPass","beginRenderPass","colorAttachments","view","clearValue","r","g","loadOp","storeOp","screen_pipeline","screen_bind_group","draw","submit","finish","pathtracing","initialize","setupDevice","createAssets","setupPipeline","set_hdr","hdr","shutdown","destroy","color_buffer","secondary_buffer","adapter","navigator","gpu","requestAdapter","requestDevice","getContext","format","configure","alphaMode","_h","_j","createTexture","size","usage","GPUTextureUsage","COPY_DST","STORAGE_BINDING","TEXTURE_BINDING","color_buffer_view","secondary_buffer_view","sampler","createSampler","addressModeU","addressModeV","magFilter","minFilter","mipmapFilter","maxAnisotropy","createBuffer","GPUBufferUsage","UNIFORM","scene_size","STORAGE","createBindGroupLayout","entries","binding","visibility","GPUShaderStage","COMPUTE","storageTexture","access","viewDimension","buffer","type","createBindGroup","layout","label","resource","ray_tracing_pipline_layout","createPipelineLayout","bindGroupLayouts","createComputePipeline","compute","entryPoint","module","createShaderModule","code","constants","screen_bind_group_layout","FRAGMENT","texture","screen_pipeline_layout","createRenderPipeline","vertex","screen_shader","fragment","targets","primitive","topology","cullMode","frontFace","slice_renderer","background","slice","slice_input","set_slice","console","log","set_background","set_axis","sxpv","sypv","clearRect","vox_pos","fillStyle","color_to_string","fillRect","scaled_color","toString","last_time","camera_active","window","scrollY","innerHeight","documentElement","style","setProperty","requestAnimationFrame","elapsed","innerText","theme","btn_switch_theme","root","querySelector","dataset","switch_latte","switch_mocha","btn_rescale_canvas","rescale","scaled","innerWidth","btn_save_scene","file","Blob","createElement","href","URL","createObjectURL","download","click","revokeObjectURL","save","btn_load_scene","input","files","reader","FileReader","readAsText","content","load","preventDefault"],"sourceRoot":""}