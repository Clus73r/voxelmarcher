{"version":3,"file":"main.js","mappings":"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","sources":["webpack://voxelraymarcher/./src/shaders/common.wgsl","webpack://voxelraymarcher/./src/shaders/screen_shader.wgsl","webpack://voxelraymarcher/./src/renderer.ts","webpack://voxelraymarcher/./node_modules/wgpu-matrix/dist/2.x/wgpu-matrix.module.js","webpack://voxelraymarcher/./src/math_util.ts","webpack://voxelraymarcher/./src/scene.ts","webpack://voxelraymarcher/./src/orbit_camera.ts","webpack://voxelraymarcher/./src/slice_renderer.ts","webpack://voxelraymarcher/./src/main.ts","webpack://voxelraymarcher/./src/controller.ts","webpack://voxelraymarcher/./src/shaders/path_trace_kernel.wgsl","webpack://voxelraymarcher/./src/shaders/ray_trace_kernel.wgsl","webpack://voxelraymarcher/./src/theme_switch.ts"],"sourcesContent":["export default \"@group(0) @binding(0) var color_buffer: texture_storage_2d<rgba8unorm, write>;\\r\\n@group(0) @binding(1) var<uniform> scene: SceneParameter;\\r\\n@group(0) @binding(2) var<storage, read> scene_data: SceneData;\\r\\n// @group(0) @binding(3) var hdr_tex: texture_2d<f32>;\\r\\n// @group(0) @binding(4) var hdr_sampler: sampler;\\r\\n@group(0) @binding(3) var<storage, read> lights: LightData;\\r\\n@group(0) @binding(4) var secondary_buffer: texture_storage_2d<rgba8unorm, write>;\\r\\n@group(0) @binding(5) var<storage, read> scene_meta_data: SceneMetaData;\\r\\n\\r\\noverride grid_size: f32 = 2f;\\r\\noverride voxel_count: i32 = 4;\\r\\nvar<private> voxel_size: f32 = grid_size / f32(voxel_count);\\r\\nvar<private> boundary_min: vec3<f32> = vec3<f32>(f32(-grid_size) / 2, f32(-grid_size) / 2, f32(-grid_size) / 2);\\r\\nvar<private> boundary_max: vec3<f32> = vec3<f32>(f32(grid_size) / 2, f32(grid_size) / 2, f32(grid_size) / 2);\\r\\nvar<private> depth_clip_min: f32 = 1f;\\r\\nvar<private> depth_clip_max: f32 = 10f;\\r\\n\\r\\nvar<private> rng_seed: u32;\\r\\nvar<private> rng_seed_steady: u32;\\r\\n\\r\\nconst samples: i32 = 1;\\r\\nconst light_bounces: i32 = 3;\\r\\nconst max_penetrations: i32 = 3;\\r\\nconst reflection_bounces: i32 = 3;\\r\\nconst scatter: i32 = 5;\\r\\n// const ambient_light: f32 = 0.03;\\r\\nconst pi = 3.14159265359;\\r\\n\\r\\n// const background: vec3<f32> = vec3<f32>(24f / 255f, 24f / 255f, 37f / 255f);\\r\\n\\r\\nstruct SceneParameter {\\r\\n    camera_pos: vec3<f32>,\\r\\n    rng_start: f32,\\r\\n    camera_forward: vec3<f32>,\\r\\n    light_count: f32,\\r\\n    camera_right: vec3<f32>,\\r\\n\\tao_strength: f32,\\r\\n    camera_up: vec3<f32>,\\r\\n\\tambient_light: f32,\\r\\n    direct_light: vec3<f32>,\\r\\n    direct_light_brightness: f32,\\r\\n\\tbackground_color: vec3<f32>,\\r\\n}\\r\\n\\r\\nstruct Voxel {\\r\\n\\tcolor: vec3<f32>,\\r\\n\\topacity: f32,\\r\\n\\troughness: f32,\\r\\n\\tlightness: f32,\\r\\n}\\r\\n\\r\\nstruct MetaVoxel {\\r\\n\\tgi: vec3<f32>,\\r\\n\\tsomethingelse: vec3<f32>\\r\\n}\\r\\n\\r\\nstruct SceneData {\\r\\n\\tdata: array<Voxel>,\\r\\n}\\r\\n\\r\\nstruct SceneMetaData {\\r\\n\\tdata: array<MetaVoxel>,\\r\\n}\\r\\n\\r\\nstruct LightData {\\r\\n\\tdata: array<Light>,\\r\\n}\\r\\n\\r\\nstruct Light {\\r\\n\\tlocation: vec3<f32>,\\r\\n\\temitter_type: f32,\\r\\n}\\r\\n\\r\\nstruct Ray {\\r\\n    origin: vec3<f32>,\\r\\n    direction: vec3<f32>,\\r\\n    inv_direction: vec3<f32>,\\r\\n}\\r\\n\\r\\nstruct RayHit {\\r\\n\\tposition: vec3<f32>,\\r\\n\\tdepth: f32,\\r\\n\\tvoxel_position: vec3<i32>,\\r\\n\\tvoxel: Voxel,\\r\\n\\tnormal: vec3<f32>,\\r\\n\\tray_direction: vec3<f32>,\\r\\n\\texit_position: vec3<f32>,\\r\\n\\tao: f32,\\r\\n\\tuv: vec2<f32>,\\r\\n}\\r\\n\\r\\nstruct TraceResult {\\r\\n\\tcolor: vec3<f32>,\\r\\n\\tao: f32,\\r\\n}\\r\\n\\r\\n@compute @workgroup_size(16,16,1)\\r\\nfn main(@builtin(global_invocation_id) GlobalInvocationID : vec3<u32>) {\\r\\n    let screen_size: vec2<u32> = textureDimensions(color_buffer);\\r\\n    let screen_pos : vec2<i32> = vec2<i32>(i32(GlobalInvocationID.x), i32(GlobalInvocationID.y));\\r\\n    // rng_seed = GlobalInvocationID.x + 50 + (GlobalInvocationID.y + 50) * (GlobalInvocationID.x + 100) * 1000 * u32(scene.rng_start);\\r\\n    rng_seed = GlobalInvocationID.x + 50 + (GlobalInvocationID.y + 50) * (GlobalInvocationID.x + 100) * 1000;\\r\\n    rng_seed_steady = GlobalInvocationID.x + 150 + (GlobalInvocationID.y + 75) * (GlobalInvocationID.x + 350) * 1000;\\r\\n\\r\\n    var pixel_color: vec3<f32>;\\r\\n    var pixel_ao: f32;\\r\\n    for (var i = 0; i < samples; i++){\\r\\n\\r\\n\\t    let rng_offset: vec2<f32> = select(vec2<f32>(0), vec2<f32>(rng() - 0.5, rng() - 0.5), samples > 1);\\r\\n\\t    let horizontal_coefficient: f32 = (f32(screen_pos.x) + rng_offset.x - f32(screen_size.x) / 2) / f32(screen_size.x);\\r\\n\\t    let vertical_coefficient: f32 = (f32(screen_pos.y) + rng_offset.y - f32(screen_size.y) / 2) / -f32(screen_size.y);\\r\\n\\r\\n\\t    let ray_direction = normalize(scene.camera_forward\\r\\n\\t\\t\\t    + horizontal_coefficient * scene.camera_right\\r\\n\\t\\t\\t    + vertical_coefficient * scene.camera_up);\\r\\n\\t    let ray: Ray = Ray(scene.camera_pos, ray_direction, 1 / ray_direction);\\r\\n\\t    let trace_result = trace(ray, light_bounces);\\r\\n\\t    // pixel_color += trace(ray, light_bounces);\\r\\n\\t    // pixel_color += trace_result.color;\\r\\n\\t    pixel_color += trace_result;\\r\\n\\t    // pixel_ao += trace_result.ao;\\r\\n    }\\r\\n\\r\\n    // let correction = 1.0 / f32(samples);\\r\\n    // pixel_color = sqrt(correction * pixel_color);\\r\\n\\r\\n\\tpixel_color /= f32(samples);\\r\\n\\t// pixel_ao /= f32(samples);\\r\\n\\r\\n    /* pixel_color = textureSampleLevel(hdr_tex, hdr_sampler, vec2<f32>(f32(GlobalInvocationID.x) / f32(screen_size.x), f32(GlobalInvocationID.y) / f32(screen_size.y) * 2), 0.0).rgb; */\\r\\n\\r\\n    textureStore(color_buffer, screen_pos, vec4<f32>(pixel_color, 1.0));\\r\\n    // textureStore(secondary_buffer, screen_pos, vec4<f32>(pixel_ao, 0, 0, 1.0));\\r\\n}\\r\\n\\r\\nfn rng_hash(seed: u32) -> u32 {\\r\\n\\tvar x = ( seed << 10u );\\r\\n\\tx ^= ( x >>  6u );\\r\\n\\tx += ( x <<  3u );\\r\\n\\tx ^= ( x >> 11u );\\r\\n\\tx += ( x << 15u );\\r\\n\\treturn x;\\r\\n}\\r\\n\\r\\nfn rng() -> f32 {\\r\\n\\trng_seed++;\\r\\n\\treturn bitcast<f32>((rng_hash(rng_seed) >> 9) | 0x3f800000 ) - 1.0;\\r\\n}\\r\\n\\r\\nfn rng_steady() -> f32 {\\r\\n\\trng_seed_steady++;\\r\\n\\treturn bitcast<f32>((rng_hash(rng_seed_steady) >> 9) | 0x3f800000 ) - 1.0;\\r\\n}\\r\\n\\r\\nfn ray_reflect(ray: Ray, position: vec3<f32>, normal: vec3<f32>) -> Ray {\\r\\n\\tlet reflect = ray.direction - 2 * dot(ray.direction, normal) * normal;\\r\\n\\treturn Ray(position, reflect, 1 / reflect);\\r\\n}\\r\\n\\r\\nfn get_voxel_id(v: vec3<i32>) -> i32 {\\r\\n\\treturn v.z * voxel_count * voxel_count + v.y * voxel_count + v.x;\\r\\n}\\r\\n\\r\\nfn get_voxel(v: vec3<i32>) -> Voxel {\\r\\n\\treturn scene_data.data[v.z * voxel_count * voxel_count + v.y * voxel_count + v.x];\\r\\n}\\r\\n\\r\\nfn get_meta_voxel(v: vec3<i32>) -> MetaVoxel {\\r\\n\\treturn scene_meta_data.data[v.z * voxel_count * voxel_count + v.y * voxel_count + v.x];\\r\\n}\\r\\n\\r\\nfn get_voxel_by_position(v: vec3<f32>) -> Voxel {\\r\\n\\treturn get_voxel(vec3<i32>((v - boundary_min) / f32(voxel_size)));\\r\\n}\\r\\n\\r\\nfn sample_spherical_map(v: vec3<f32>) -> vec2<f32> {\\r\\n\\tlet theta = atan2(v.x, v.y);\\r\\n\\tlet phi = acos(v.z);\\r\\n\\tlet raw_u = theta / (2 * pi);\\r\\n\\tlet uv = vec2<f32>(\\r\\n\\t\\t1 - (raw_u + 0.5),\\r\\n\\t\\tphi / pi\\r\\n\\t);\\r\\n\\treturn uv;\\r\\n}\\r\\n\\r\\nfn random_unit_vector() -> vec3<f32> {\\r\\n\\tlet phi = rng() * pi * 2;\\r\\n\\tlet costheta = rng() * 2 - 1;\\r\\n\\t\\tlet theta = acos(costheta);\\r\\n\\tlet x = sin(theta) * cos(phi);\\r\\n\\tlet y = sin(theta) * sin(phi);\\r\\n\\tlet z = cos(theta);\\r\\n\\treturn vec3<f32>(x, y, z);\\r\\n}\\r\\n\"","export default \"@group(0) @binding(0) var screen_sampler : sampler;\\r\\n@group(0) @binding(1) var color_buffer : texture_2d<f32>;\\r\\n@group(0) @binding(2) var secondary_buffer : texture_2d<f32>;\\r\\n\\r\\nstruct VertexOutput {\\r\\n        @builtin(position) Position : vec4<f32>,\\r\\n            @location(0) TexCoord : vec2<f32>,\\r\\n}\\r\\n\\r\\n@vertex\\r\\nfn vert_main(@builtin(vertex_index) VertexIndex : u32) -> VertexOutput {\\r\\n    var positions = array<vec2<f32>, 6>(\\r\\n        vec2<f32>( 1.0,  1.0),\\r\\n        vec2<f32>( 1.0, -1.0),\\r\\n        vec2<f32>(-1.0, -1.0),\\r\\n        vec2<f32>( 1.0,  1.0),\\r\\n        vec2<f32>(-1.0, -1.0),\\r\\n        vec2<f32>(-1.0,  1.0)\\r\\n    );\\r\\n\\r\\n    var texCoords = array<vec2<f32>, 6>(\\r\\n        vec2<f32>(1.0, 0.0),\\r\\n        vec2<f32>(1.0, 1.0),\\r\\n        vec2<f32>(0.0, 1.0),\\r\\n        vec2<f32>(1.0, 0.0),\\r\\n        vec2<f32>(0.0, 1.0),\\r\\n        vec2<f32>(0.0, 0.0)\\r\\n    );\\r\\n\\r\\n    var output : VertexOutput;\\r\\n    output.Position = vec4<f32>(positions[VertexIndex], 0.0, 1.0);\\r\\n    output.TexCoord = texCoords[VertexIndex];\\r\\n    return output;\\r\\n}\\r\\n\\r\\nconst ao_blur_steps = 7;\\r\\nconst ao_blur_radius = 0.00f / f32(ao_blur_steps);\\r\\nconst ao_strength = 1;\\r\\n\\r\\n@fragment\\r\\nfn frag_main(@location(0) TexCoord : vec2<f32>) -> @location(0) vec4<f32> {\\r\\n\\tvar acc = 0f;\\r\\n\\tlet blur_offset = (ao_blur_radius * f32(ao_blur_steps)) / 2;\\r\\n\\tfor (var x = 0; x < ao_blur_steps; x++){\\r\\n\\t\\tfor (var y = 0; y < ao_blur_steps; y++){\\r\\n\\t\\t\\tacc += textureSample(secondary_buffer, screen_sampler, vec2<f32>(TexCoord.x - blur_offset + ao_blur_radius * f32(x), TexCoord.y - blur_offset + ao_blur_radius * f32(y))).x;\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\tacc /= f32(ao_blur_steps) * f32(ao_blur_steps);\\r\\n\\r\\n    // return vec4<f32>(acc, acc, acc, 1.0);\\r\\n    return textureSample(color_buffer, screen_sampler, TexCoord) * (1 - acc * ao_strength);\\r\\n}\\r\\n\"","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport common from \"./shaders/common.wgsl\";\nimport ray_trace_kernel from \"./shaders/ray_trace_kernel.wgsl\";\nimport path_trace_kernel from \"./shaders/path_trace_kernel.wgsl\";\nimport screen_shader from \"./shaders/screen_shader.wgsl\";\nexport class Renderer {\n    constructor(canvas, scene, camera) {\n        // hdrtexture: HDRTexture;\n        this.initialized = false;\n        this.render = () => {\n            var _a, _b, _c, _d, _e, _f, _g;\n            if (!this.initialized)\n                return;\n            let lights = [];\n            for (let x = 0; x < this.scene.voxel_count; x++) {\n                for (let y = 0; y < this.scene.voxel_count; y++) {\n                    for (let z = 0; z < this.scene.voxel_count; z++) {\n                        if (this.scene.get_voxel([x, y, z]).lightness > 0) {\n                            lights.push([x, y, z]);\n                        }\n                    }\n                }\n            }\n            (_a = this.device) === null || _a === void 0 ? void 0 : _a.queue.writeBuffer(this.sceneParameters, 0, new Float32Array([\n                this.camera.position[0],\n                this.camera.position[1],\n                this.camera.position[2],\n                new Date().getMilliseconds(),\n                this.camera.forward[0],\n                this.camera.forward[1],\n                this.camera.forward[2],\n                lights.length,\n                this.camera.right[0],\n                this.camera.right[1],\n                this.camera.right[2],\n                this.scene.ao_strength,\n                this.camera.up[0],\n                this.camera.up[1],\n                this.camera.up[2],\n                this.scene.ambient_light,\n                this.scene.direct_light[0],\n                this.scene.direct_light[1],\n                this.scene.direct_light[2],\n                this.scene.direct_light_brightness,\n                this.scene.background_color[0],\n                this.scene.background_color[1],\n                this.scene.background_color[2],\n                0.0,\n            ]), 0, 24);\n            const light_data = new Float32Array(4 * lights.length);\n            for (let i = 0; i < lights.length; ++i) {\n                light_data[4 * i] = lights[i][0];\n                light_data[4 * i + 1] = lights[i][1];\n                light_data[4 * i + 2] = lights[i][2];\n                light_data[4 * i + 3] = 0;\n            }\n            (_b = this.device) === null || _b === void 0 ? void 0 : _b.queue.writeBuffer(this.lightData, 0, light_data, 0, lights.length * 4);\n            const scene_data = new Float32Array(8 * this.scene.grid.length);\n            for (let i = 0; i < this.scene.grid.length; ++i) {\n                scene_data[8 * i] = this.scene.grid[i].color[0];\n                scene_data[8 * i + 1] = this.scene.grid[i].color[1];\n                scene_data[8 * i + 2] = this.scene.grid[i].color[2];\n                scene_data[8 * i + 3] = this.scene.grid[i].opacity;\n                scene_data[8 * i + 4] = this.scene.grid[i].roughness;\n                scene_data[8 * i + 5] = this.scene.grid[i].lightness;\n                scene_data[8 * i + 6] = 0;\n                scene_data[8 * i + 7] = 0;\n            }\n            const scene_meta_data = new Float32Array(8 * this.scene.grid.length);\n            for (let i = 0; i < this.scene.grid.length; ++i) {\n                scene_meta_data[8 * i] = this.scene.meta_grid[i].gi[0];\n                scene_meta_data[8 * i + 1] = this.scene.meta_grid[i].gi[1];\n                scene_meta_data[8 * i + 2] = this.scene.meta_grid[i].gi[2];\n                scene_meta_data[8 * i + 3] = 0;\n                scene_meta_data[8 * i + 4] = 0;\n                scene_meta_data[8 * i + 5] = 0;\n                scene_meta_data[8 * i + 6] = 0;\n                scene_meta_data[8 * i + 7] = 0;\n            }\n            (_c = this.device) === null || _c === void 0 ? void 0 : _c.queue.writeBuffer(this.sceneData, 0, scene_data, 0, this.scene.grid.length * 8);\n            (_d = this.device) === null || _d === void 0 ? void 0 : _d.queue.writeBuffer(this.sceneMetaData, 0, scene_meta_data, 0, this.scene.grid.length * 8);\n            const commandEncoder = (_e = this.device) === null || _e === void 0 ? void 0 : _e.createCommandEncoder();\n            const ray_trace_pass = commandEncoder === null || commandEncoder === void 0 ? void 0 : commandEncoder.beginComputePass();\n            ray_trace_pass === null || ray_trace_pass === void 0 ? void 0 : ray_trace_pass.setPipeline(this.ray_tracing_pipeline);\n            ray_trace_pass === null || ray_trace_pass === void 0 ? void 0 : ray_trace_pass.setBindGroup(0, this.ray_tracing_bind_group);\n            ray_trace_pass === null || ray_trace_pass === void 0 ? void 0 : ray_trace_pass.dispatchWorkgroups(this.canvas.width / 16, this.canvas.height / 16, 1);\n            ray_trace_pass === null || ray_trace_pass === void 0 ? void 0 : ray_trace_pass.end();\n            const textureView = (_f = this.context) === null || _f === void 0 ? void 0 : _f.getCurrentTexture().createView();\n            const renderPass = commandEncoder === null || commandEncoder === void 0 ? void 0 : commandEncoder.beginRenderPass({\n                colorAttachments: [\n                    {\n                        view: textureView,\n                        clearValue: { r: 0.5, g: 0.0, b: 0.25, a: 1.0 },\n                        loadOp: \"clear\",\n                        storeOp: \"store\",\n                    },\n                ],\n            });\n            renderPass === null || renderPass === void 0 ? void 0 : renderPass.setPipeline(this.screen_pipeline);\n            renderPass === null || renderPass === void 0 ? void 0 : renderPass.setBindGroup(0, this.screen_bind_group);\n            renderPass === null || renderPass === void 0 ? void 0 : renderPass.draw(6, 1, 0, 0);\n            renderPass === null || renderPass === void 0 ? void 0 : renderPass.end();\n            (_g = this.device) === null || _g === void 0 ? void 0 : _g.queue.submit([commandEncoder === null || commandEncoder === void 0 ? void 0 : commandEncoder.finish()]);\n        };\n        this.canvas = canvas;\n        this.scene = scene;\n        this.pathtracing = false;\n        this.camera = camera;\n        // this.hdrtexture = new HDRTexture();\n    }\n    initialize(pathtracing) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.pathtracing = pathtracing;\n            yield this.setupDevice();\n            yield this.createAssets();\n            yield this.setupPipeline();\n            this.initialized = true;\n        });\n    }\n    set_hdr(hdr) { }\n    shutdown() {\n        var _a, _b, _c;\n        this.initialized = false;\n        (_a = this.device) === null || _a === void 0 ? void 0 : _a.destroy();\n        (_b = this.color_buffer) === null || _b === void 0 ? void 0 : _b.destroy();\n        (_c = this.secondary_buffer) === null || _c === void 0 ? void 0 : _c.destroy();\n    }\n    setupDevice() {\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function* () {\n            this.adapter = (yield ((_a = navigator.gpu) === null || _a === void 0 ? void 0 : _a.requestAdapter()));\n            this.device = yield ((_b = this.adapter) === null || _b === void 0 ? void 0 : _b.requestDevice());\n            this.context = this.canvas.getContext(\"webgpu\");\n            this.format = \"bgra8unorm\";\n            const err = document.getElementById(\"canv-error\");\n            if (!this.context) {\n                err.textContent =\n                    \"Sorry, this canvas requires a WebGPU capable browser :(\";\n            }\n            else {\n                err.textContent = \"\";\n            }\n            this.context.configure({\n                device: this.device,\n                format: this.format,\n                alphaMode: \"opaque\",\n            });\n        });\n    }\n    createAssets() {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j;\n        return __awaiter(this, void 0, void 0, function* () {\n            this.color_buffer = (_a = this.device) === null || _a === void 0 ? void 0 : _a.createTexture({\n                size: { width: this.canvas.width, height: this.canvas.height },\n                format: \"rgba8unorm\",\n                usage: GPUTextureUsage.COPY_DST |\n                    GPUTextureUsage.STORAGE_BINDING |\n                    GPUTextureUsage.TEXTURE_BINDING,\n            });\n            this.secondary_buffer = (_b = this.device) === null || _b === void 0 ? void 0 : _b.createTexture({\n                size: { width: this.canvas.width, height: this.canvas.height },\n                format: \"rgba8unorm\",\n                usage: GPUTextureUsage.COPY_DST |\n                    GPUTextureUsage.STORAGE_BINDING |\n                    GPUTextureUsage.TEXTURE_BINDING,\n            });\n            this.color_buffer_view = (_c = this.color_buffer) === null || _c === void 0 ? void 0 : _c.createView();\n            this.secondary_buffer_view = (_d = this.secondary_buffer) === null || _d === void 0 ? void 0 : _d.createView();\n            this.sampler = (_e = this.device) === null || _e === void 0 ? void 0 : _e.createSampler({\n                addressModeU: \"repeat\",\n                addressModeV: \"repeat\",\n                magFilter: \"linear\",\n                minFilter: \"nearest\",\n                mipmapFilter: \"nearest\",\n                maxAnisotropy: 1,\n            });\n            this.sceneParameters = (_f = this.device) === null || _f === void 0 ? void 0 : _f.createBuffer({\n                size: 96,\n                usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\n            });\n            const scene_size = this.scene.voxel_count * this.scene.voxel_count * this.scene.voxel_count;\n            this.sceneData = (_g = this.device) === null || _g === void 0 ? void 0 : _g.createBuffer({\n                size: scene_size * 8 * 4,\n                usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\n            });\n            this.sceneMetaData = (_h = this.device) === null || _h === void 0 ? void 0 : _h.createBuffer({\n                size: scene_size * 8 * 4,\n                usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\n            });\n            this.lightData = (_j = this.device) === null || _j === void 0 ? void 0 : _j.createBuffer({\n                size: 128 * 4,\n                usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\n            });\n        });\n    }\n    setupPipeline() {\n        var _a, _b, _c, _d, _e, _f, _g, _h;\n        return __awaiter(this, void 0, void 0, function* () {\n            const ray_tracing_bind_group = ((_a = this.device) === null || _a === void 0 ? void 0 : _a.createBindGroupLayout({\n                entries: [\n                    {\n                        binding: 0,\n                        visibility: GPUShaderStage.COMPUTE,\n                        storageTexture: {\n                            access: \"write-only\",\n                            format: \"rgba8unorm\",\n                            viewDimension: \"2d\",\n                        },\n                    },\n                    {\n                        binding: 1,\n                        visibility: GPUShaderStage.COMPUTE,\n                        buffer: {\n                            type: \"uniform\",\n                        },\n                    },\n                    {\n                        binding: 2,\n                        visibility: GPUShaderStage.COMPUTE,\n                        buffer: {\n                            type: \"read-only-storage\",\n                        },\n                    },\n                    // {\n                    //   binding: 3,\n                    //   visibility: GPUShaderStage.COMPUTE,\n                    //   texture: {},\n                    // },\n                    // {\n                    //   binding: 4,\n                    //   visibility: GPUShaderStage.COMPUTE,\n                    //   sampler: {},\n                    // },\n                    {\n                        binding: 3,\n                        visibility: GPUShaderStage.COMPUTE,\n                        buffer: {\n                            type: \"read-only-storage\",\n                        },\n                    },\n                    {\n                        binding: 4,\n                        visibility: GPUShaderStage.COMPUTE,\n                        storageTexture: {\n                            access: \"write-only\",\n                            format: \"rgba8unorm\",\n                            viewDimension: \"2d\",\n                        },\n                    },\n                    {\n                        binding: 5,\n                        visibility: GPUShaderStage.COMPUTE,\n                        buffer: {\n                            type: \"read-only-storage\",\n                        },\n                    },\n                ],\n            }));\n            this.ray_tracing_bind_group = (_b = this.device) === null || _b === void 0 ? void 0 : _b.createBindGroup({\n                layout: ray_tracing_bind_group,\n                label: \"Ray tracing bind group\",\n                entries: [\n                    { binding: 0, resource: this.color_buffer_view },\n                    {\n                        binding: 1,\n                        resource: { buffer: this.sceneParameters },\n                    },\n                    { binding: 2, resource: { buffer: this.sceneData } },\n                    // {\n                    //   binding: 3,\n                    //   resource: <GPUTextureView>this.hdrtexture.view,\n                    // },\n                    // {\n                    //   binding: 4,\n                    //   resource: <GPUSampler>this.hdrtexture.sampler,\n                    // },\n                    {\n                        binding: 3,\n                        resource: { buffer: this.lightData },\n                    },\n                    {\n                        binding: 4,\n                        resource: this.secondary_buffer_view,\n                    },\n                    {\n                        binding: 5,\n                        resource: { buffer: this.sceneMetaData },\n                    },\n                ],\n            });\n            const ray_tracing_pipline_layout = ((_c = this.device) === null || _c === void 0 ? void 0 : _c.createPipelineLayout({\n                bindGroupLayouts: [ray_tracing_bind_group],\n            }));\n            this.ray_tracing_pipeline = ((_d = this.device) === null || _d === void 0 ? void 0 : _d.createComputePipeline({\n                label: \"Ray tracing pipeline\",\n                layout: ray_tracing_pipline_layout,\n                compute: {\n                    entryPoint: \"main\",\n                    module: this.device.createShaderModule({\n                        code: common +\n                            (!this.pathtracing ? ray_trace_kernel : path_trace_kernel),\n                    }),\n                    constants: {\n                        grid_size: this.scene.grid_size,\n                        voxel_count: this.scene.voxel_count,\n                    },\n                },\n            }));\n            const screen_bind_group_layout = ((_e = this.device) === null || _e === void 0 ? void 0 : _e.createBindGroupLayout({\n                entries: [\n                    { binding: 0, visibility: GPUShaderStage.FRAGMENT, sampler: {} },\n                    { binding: 1, visibility: GPUShaderStage.FRAGMENT, texture: {} },\n                    { binding: 2, visibility: GPUShaderStage.FRAGMENT, texture: {} },\n                ],\n            }));\n            this.screen_bind_group = (_f = this.device) === null || _f === void 0 ? void 0 : _f.createBindGroup({\n                layout: screen_bind_group_layout,\n                entries: [\n                    { binding: 0, resource: this.sampler },\n                    { binding: 1, resource: this.color_buffer_view },\n                    {\n                        binding: 2,\n                        resource: this.secondary_buffer_view,\n                    },\n                ],\n            });\n            const screen_pipeline_layout = ((_g = this.device) === null || _g === void 0 ? void 0 : _g.createPipelineLayout({\n                bindGroupLayouts: [screen_bind_group_layout],\n            }));\n            this.screen_pipeline = (_h = this.device) === null || _h === void 0 ? void 0 : _h.createRenderPipeline({\n                layout: screen_pipeline_layout,\n                vertex: {\n                    module: this.device.createShaderModule({ code: screen_shader }),\n                    entryPoint: \"vert_main\",\n                },\n                fragment: {\n                    module: this.device.createShaderModule({ code: screen_shader }),\n                    entryPoint: \"frag_main\",\n                    targets: [{ format: \"bgra8unorm\" }],\n                },\n                primitive: {\n                    topology: \"triangle-list\",\n                    cullMode: \"back\",\n                    frontFace: \"cw\",\n                },\n            });\n        });\n    }\n}\n","/* wgpu-matrix@2.2.2, license MIT */\nvar arrayLike = /*#__PURE__*/Object.freeze({\n    __proto__: null\n});\n\n/*\n * Copyright 2022 Gregg Tavares\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\nlet EPSILON = 0.000001;\n/**\n * Set the value for EPSILON for various checks\n * @param v - Value to use for EPSILON.\n * @returns previous value of EPSILON;\n */\nfunction setEpsilon(v) {\n    const old = EPSILON;\n    EPSILON = v;\n    return old;\n}\n/**\n * Convert degrees to radians\n * @param degrees - Angle in degrees\n * @returns angle converted to radians\n */\nfunction degToRad(degrees) {\n    return degrees * Math.PI / 180;\n}\n/**\n * Convert radians to degrees\n * @param radians - Angle in radians\n * @returns angle converted to degrees\n */\nfunction radToDeg(radians) {\n    return radians * 180 / Math.PI;\n}\n/**\n * Lerps between a and b via t\n * @param a - starting value\n * @param b - ending value\n * @param t - value where 0 = a and 1 = b\n * @returns a + (b - a) * t\n */\nfunction lerp$4(a, b, t) {\n    return a + (b - a) * t;\n}\n/**\n * Compute the opposite of lerp. Given a and b and a value between\n * a and b returns a value between 0 and 1. 0 if a, 1 if b.\n * Note: no clamping is done.\n * @param a - start value\n * @param b - end value\n * @param v - value between a and b\n * @returns (v - a) / (b - a)\n */\nfunction inverseLerp(a, b, v) {\n    const d = b - a;\n    return (Math.abs(b - a) < EPSILON)\n        ? a\n        : (v - a) / d;\n}\n/**\n * Compute the euclidean modulo\n *\n * ```\n * // table for n / 3\n * -5, -4, -3, -2, -1,  0,  1,  2,  3,  4,  5   <- n\n * ------------------------------------\n * -2  -1  -0  -2  -1   0,  1,  2,  0,  1,  2   <- n % 3\n *  1   2   0   1   2   0,  1,  2,  0,  1,  2   <- euclideanModule(n, 3)\n * ```\n *\n * @param n - dividend\n * @param m - divisor\n * @returns the euclidean modulo of n / m\n */\nfunction euclideanModulo(n, m) {\n    return ((n % m) + m) % m;\n}\n\nvar utils = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    get EPSILON () { return EPSILON; },\n    degToRad: degToRad,\n    euclideanModulo: euclideanModulo,\n    inverseLerp: inverseLerp,\n    lerp: lerp$4,\n    radToDeg: radToDeg,\n    setEpsilon: setEpsilon\n});\n\n/**\n *\n * Vec2 math functions.\n *\n * Almost all functions take an optional `dst` argument. If it is not passed in the\n * functions will create a new Vec2. In other words you can do this\n *\n *     const v = vec2.cross(v1, v2);  // Creates a new Vec2 with the cross product of v1 x v2.\n *\n * or\n *\n *     const v = vec2.create();\n *     vec2.cross(v1, v2, v);  // Puts the cross product of v1 x v2 in v\n *\n * The first style is often easier but depending on where it's used it generates garbage where\n * as there is almost never allocation with the second style.\n *\n * It is always safe to pass any vector as the destination. So for example\n *\n *     vec2.cross(v1, v2, v1);  // Puts the cross product of v1 x v2 in v1\n *\n */\nlet VecType$2 = Float32Array;\n/**\n * Sets the type this library creates for a Vec2\n * @param ctor - the constructor for the type. Either `Float32Array`, `Float64Array`, or `Array`\n * @returns previous constructor for Vec2\n */\nfunction setDefaultType$6(ctor) {\n    const oldType = VecType$2;\n    VecType$2 = ctor;\n    return oldType;\n}\n/**\n * Creates a Vec2; may be called with x, y, z to set initial values.\n *\n * Note: Since passing in a raw JavaScript array\n * is valid in all circumstances, if you want to\n * force a JavaScript array into a Vec2's specified type\n * it would be faster to use\n *\n * ```\n * const v = vec2.clone(someJSArray);\n * ```\n *\n * Note: a consequence of the implementation is if your Vec2Type = `Array`\n * instead of `Float32Array` or `Float64Array` then any values you\n * don't pass in will be undefined. Usually this is not an issue since\n * (a) using `Array` is rare and (b) using `vec2.create` is usually used\n * to create a Vec2 to be filled out as in\n *\n * ```\n * const sum = vec2.create();\n * vec2.add(v1, v2, sum);\n * ```\n *\n * @param x - Initial x value.\n * @param y - Initial y value.\n * @returns the created vector\n */\nfunction create$5(x = 0, y = 0) {\n    const dst = new VecType$2(2);\n    if (x !== undefined) {\n        dst[0] = x;\n        if (y !== undefined) {\n            dst[1] = y;\n        }\n    }\n    return dst;\n}\n\n/*\n * Copyright 2022 Gregg Tavares\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n/**\n * Creates a Vec2; may be called with x, y, z to set initial values. (same as create)\n * @param x - Initial x value.\n * @param y - Initial y value.\n * @returns the created vector\n */\nconst fromValues$3 = create$5;\n/**\n * Applies Math.ceil to each element of vector\n * @param v - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that is the ceil of each element of v.\n */\nfunction ceil$2(v, dst) {\n    dst = dst || new VecType$2(2);\n    dst[0] = Math.ceil(v[0]);\n    dst[1] = Math.ceil(v[1]);\n    return dst;\n}\n/**\n * Applies Math.floor to each element of vector\n * @param v - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that is the floor of each element of v.\n */\nfunction floor$2(v, dst) {\n    dst = dst || new VecType$2(2);\n    dst[0] = Math.floor(v[0]);\n    dst[1] = Math.floor(v[1]);\n    return dst;\n}\n/**\n * Applies Math.round to each element of vector\n * @param v - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that is the round of each element of v.\n */\nfunction round$2(v, dst) {\n    dst = dst || new VecType$2(2);\n    dst[0] = Math.round(v[0]);\n    dst[1] = Math.round(v[1]);\n    return dst;\n}\n/**\n * Clamp each element of vector between min and max\n * @param v - Operand vector.\n * @param max - Min value, default 0\n * @param min - Max value, default 1\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that the clamped value of each element of v.\n */\nfunction clamp$2(v, min = 0, max = 1, dst) {\n    dst = dst || new VecType$2(2);\n    dst[0] = Math.min(max, Math.max(min, v[0]));\n    dst[1] = Math.min(max, Math.max(min, v[1]));\n    return dst;\n}\n/**\n * Adds two vectors; assumes a and b have the same dimension.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that is the sum of a and b.\n */\nfunction add$3(a, b, dst) {\n    dst = dst || new VecType$2(2);\n    dst[0] = a[0] + b[0];\n    dst[1] = a[1] + b[1];\n    return dst;\n}\n/**\n * Adds two vectors, scaling the 2nd; assumes a and b have the same dimension.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param scale - Amount to scale b\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that is the sum of a + b * scale.\n */\nfunction addScaled$2(a, b, scale, dst) {\n    dst = dst || new VecType$2(2);\n    dst[0] = a[0] + b[0] * scale;\n    dst[1] = a[1] + b[1] * scale;\n    return dst;\n}\n/**\n * Returns the angle in radians between two vectors.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @returns The angle in radians between the 2 vectors.\n */\nfunction angle$2(a, b) {\n    const ax = a[0];\n    const ay = a[1];\n    const bx = a[0];\n    const by = a[1];\n    const mag1 = Math.sqrt(ax * ax + ay * ay);\n    const mag2 = Math.sqrt(bx * bx + by * by);\n    const mag = mag1 * mag2;\n    const cosine = mag && dot$3(a, b) / mag;\n    return Math.acos(cosine);\n}\n/**\n * Subtracts two vectors.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that is the difference of a and b.\n */\nfunction subtract$3(a, b, dst) {\n    dst = dst || new VecType$2(2);\n    dst[0] = a[0] - b[0];\n    dst[1] = a[1] - b[1];\n    return dst;\n}\n/**\n * Subtracts two vectors.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that is the difference of a and b.\n */\nconst sub$3 = subtract$3;\n/**\n * Check if 2 vectors are approximately equal\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @returns true if vectors are approximately equal\n */\nfunction equalsApproximately$5(a, b) {\n    return Math.abs(a[0] - b[0]) < EPSILON &&\n        Math.abs(a[1] - b[1]) < EPSILON;\n}\n/**\n * Check if 2 vectors are exactly equal\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @returns true if vectors are exactly equal\n */\nfunction equals$5(a, b) {\n    return a[0] === b[0] && a[1] === b[1];\n}\n/**\n * Performs linear interpolation on two vectors.\n * Given vectors a and b and interpolation coefficient t, returns\n * a + t * (b - a).\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param t - Interpolation coefficient.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The linear interpolated result.\n */\nfunction lerp$3(a, b, t, dst) {\n    dst = dst || new VecType$2(2);\n    dst[0] = a[0] + t * (b[0] - a[0]);\n    dst[1] = a[1] + t * (b[1] - a[1]);\n    return dst;\n}\n/**\n * Performs linear interpolation on two vectors.\n * Given vectors a and b and interpolation coefficient vector t, returns\n * a + t * (b - a).\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param t - Interpolation coefficients vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns the linear interpolated result.\n */\nfunction lerpV$2(a, b, t, dst) {\n    dst = dst || new VecType$2(2);\n    dst[0] = a[0] + t[0] * (b[0] - a[0]);\n    dst[1] = a[1] + t[1] * (b[1] - a[1]);\n    return dst;\n}\n/**\n * Return max values of two vectors.\n * Given vectors a and b returns\n * [max(a[0], b[0]), max(a[1], b[1]), max(a[2], b[2])].\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The max components vector.\n */\nfunction max$2(a, b, dst) {\n    dst = dst || new VecType$2(2);\n    dst[0] = Math.max(a[0], b[0]);\n    dst[1] = Math.max(a[1], b[1]);\n    return dst;\n}\n/**\n * Return min values of two vectors.\n * Given vectors a and b returns\n * [min(a[0], b[0]), min(a[1], b[1]), min(a[2], b[2])].\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The min components vector.\n */\nfunction min$2(a, b, dst) {\n    dst = dst || new VecType$2(2);\n    dst[0] = Math.min(a[0], b[0]);\n    dst[1] = Math.min(a[1], b[1]);\n    return dst;\n}\n/**\n * Multiplies a vector by a scalar.\n * @param v - The vector.\n * @param k - The scalar.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The scaled vector.\n */\nfunction mulScalar$3(v, k, dst) {\n    dst = dst || new VecType$2(2);\n    dst[0] = v[0] * k;\n    dst[1] = v[1] * k;\n    return dst;\n}\n/**\n * Multiplies a vector by a scalar. (same as mulScalar)\n * @param v - The vector.\n * @param k - The scalar.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The scaled vector.\n */\nconst scale$5 = mulScalar$3;\n/**\n * Divides a vector by a scalar.\n * @param v - The vector.\n * @param k - The scalar.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The scaled vector.\n */\nfunction divScalar$3(v, k, dst) {\n    dst = dst || new VecType$2(2);\n    dst[0] = v[0] / k;\n    dst[1] = v[1] / k;\n    return dst;\n}\n/**\n * Inverse a vector.\n * @param v - The vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The inverted vector.\n */\nfunction inverse$5(v, dst) {\n    dst = dst || new VecType$2(2);\n    dst[0] = 1 / v[0];\n    dst[1] = 1 / v[1];\n    return dst;\n}\n/**\n * Invert a vector. (same as inverse)\n * @param v - The vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The inverted vector.\n */\nconst invert$4 = inverse$5;\n/**\n * Computes the cross product of two vectors; assumes both vectors have\n * three entries.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The vector of a cross b.\n */\nfunction cross$1(a, b, dst) {\n    dst = dst || new VecType$2(3);\n    const z = a[0] * b[1] - a[1] * b[0];\n    dst[0] = 0;\n    dst[1] = 0;\n    dst[2] = z;\n    return dst;\n}\n/**\n * Computes the dot product of two vectors; assumes both vectors have\n * three entries.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @returns dot product\n */\nfunction dot$3(a, b) {\n    return a[0] * b[0] + a[1] * b[1];\n}\n/**\n * Computes the length of vector\n * @param v - vector.\n * @returns length of vector.\n */\nfunction length$3(v) {\n    const v0 = v[0];\n    const v1 = v[1];\n    return Math.sqrt(v0 * v0 + v1 * v1);\n}\n/**\n * Computes the length of vector (same as length)\n * @param v - vector.\n * @returns length of vector.\n */\nconst len$3 = length$3;\n/**\n * Computes the square of the length of vector\n * @param v - vector.\n * @returns square of the length of vector.\n */\nfunction lengthSq$3(v) {\n    const v0 = v[0];\n    const v1 = v[1];\n    return v0 * v0 + v1 * v1;\n}\n/**\n * Computes the square of the length of vector (same as lengthSq)\n * @param v - vector.\n * @returns square of the length of vector.\n */\nconst lenSq$3 = lengthSq$3;\n/**\n * Computes the distance between 2 points\n * @param a - vector.\n * @param b - vector.\n * @returns distance between a and b\n */\nfunction distance$2(a, b) {\n    const dx = a[0] - b[0];\n    const dy = a[1] - b[1];\n    return Math.sqrt(dx * dx + dy * dy);\n}\n/**\n * Computes the distance between 2 points (same as distance)\n * @param a - vector.\n * @param b - vector.\n * @returns distance between a and b\n */\nconst dist$2 = distance$2;\n/**\n * Computes the square of the distance between 2 points\n * @param a - vector.\n * @param b - vector.\n * @returns square of the distance between a and b\n */\nfunction distanceSq$2(a, b) {\n    const dx = a[0] - b[0];\n    const dy = a[1] - b[1];\n    return dx * dx + dy * dy;\n}\n/**\n * Computes the square of the distance between 2 points (same as distanceSq)\n * @param a - vector.\n * @param b - vector.\n * @returns square of the distance between a and b\n */\nconst distSq$2 = distanceSq$2;\n/**\n * Divides a vector by its Euclidean length and returns the quotient.\n * @param v - The vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The normalized vector.\n */\nfunction normalize$3(v, dst) {\n    dst = dst || new VecType$2(2);\n    const v0 = v[0];\n    const v1 = v[1];\n    const len = Math.sqrt(v0 * v0 + v1 * v1);\n    if (len > 0.00001) {\n        dst[0] = v0 / len;\n        dst[1] = v1 / len;\n    }\n    else {\n        dst[0] = 0;\n        dst[1] = 0;\n    }\n    return dst;\n}\n/**\n * Negates a vector.\n * @param v - The vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns -v.\n */\nfunction negate$4(v, dst) {\n    dst = dst || new VecType$2(2);\n    dst[0] = -v[0];\n    dst[1] = -v[1];\n    return dst;\n}\n/**\n * Copies a vector. (same as clone)\n * @param v - The vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A copy of v.\n */\nfunction copy$5(v, dst) {\n    dst = dst || new VecType$2(2);\n    dst[0] = v[0];\n    dst[1] = v[1];\n    return dst;\n}\n/**\n * Clones a vector. (same as copy)\n * @param v - The vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A copy of v.\n */\nconst clone$5 = copy$5;\n/**\n * Multiplies a vector by another vector (component-wise); assumes a and\n * b have the same length.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The vector of products of entries of a and b.\n */\nfunction multiply$5(a, b, dst) {\n    dst = dst || new VecType$2(2);\n    dst[0] = a[0] * b[0];\n    dst[1] = a[1] * b[1];\n    return dst;\n}\n/**\n * Multiplies a vector by another vector (component-wise); assumes a and\n * b have the same length. (same as mul)\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The vector of products of entries of a and b.\n */\nconst mul$5 = multiply$5;\n/**\n * Divides a vector by another vector (component-wise); assumes a and\n * b have the same length.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The vector of quotients of entries of a and b.\n */\nfunction divide$2(a, b, dst) {\n    dst = dst || new VecType$2(2);\n    dst[0] = a[0] / b[0];\n    dst[1] = a[1] / b[1];\n    return dst;\n}\n/**\n * Divides a vector by another vector (component-wise); assumes a and\n * b have the same length. (same as divide)\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The vector of quotients of entries of a and b.\n */\nconst div$2 = divide$2;\n/**\n * Creates a random unit vector * scale\n * @param scale - Default 1\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The random vector.\n */\nfunction random$1(scale = 1, dst) {\n    dst = dst || new VecType$2(2);\n    const angle = Math.random() * 2 * Math.PI;\n    dst[0] = Math.cos(angle) * scale;\n    dst[1] = Math.sin(angle) * scale;\n    return dst;\n}\n/**\n * Zero's a vector\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The zeroed vector.\n */\nfunction zero$2(dst) {\n    dst = dst || new VecType$2(2);\n    dst[0] = 0;\n    dst[1] = 0;\n    return dst;\n}\n/**\n * transform Vec2 by 4x4 matrix\n * @param v - the vector\n * @param m - The matrix.\n * @param dst - optional Vec2 to store result. If not passed a new one is created.\n * @returns the transformed vector\n */\nfunction transformMat4$2(v, m, dst) {\n    dst = dst || new VecType$2(2);\n    const x = v[0];\n    const y = v[1];\n    dst[0] = x * m[0] + y * m[4] + m[12];\n    dst[1] = x * m[1] + y * m[5] + m[13];\n    return dst;\n}\n/**\n * Transforms vec4 by 3x3 matrix\n *\n * @param v - the vector\n * @param m - The matrix.\n * @param dst - optional Vec2 to store result. If not passed a new one is created.\n * @returns the transformed vector\n */\nfunction transformMat3$1(v, m, dst) {\n    dst = dst || new VecType$2(2);\n    const x = v[0];\n    const y = v[1];\n    dst[0] = m[0] * x + m[4] * y + m[8];\n    dst[1] = m[1] * x + m[5] * y + m[9];\n    return dst;\n}\n\nvar vec2Impl = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    add: add$3,\n    addScaled: addScaled$2,\n    angle: angle$2,\n    ceil: ceil$2,\n    clamp: clamp$2,\n    clone: clone$5,\n    copy: copy$5,\n    create: create$5,\n    cross: cross$1,\n    dist: dist$2,\n    distSq: distSq$2,\n    distance: distance$2,\n    distanceSq: distanceSq$2,\n    div: div$2,\n    divScalar: divScalar$3,\n    divide: divide$2,\n    dot: dot$3,\n    equals: equals$5,\n    equalsApproximately: equalsApproximately$5,\n    floor: floor$2,\n    fromValues: fromValues$3,\n    inverse: inverse$5,\n    invert: invert$4,\n    len: len$3,\n    lenSq: lenSq$3,\n    length: length$3,\n    lengthSq: lengthSq$3,\n    lerp: lerp$3,\n    lerpV: lerpV$2,\n    max: max$2,\n    min: min$2,\n    mul: mul$5,\n    mulScalar: mulScalar$3,\n    multiply: multiply$5,\n    negate: negate$4,\n    normalize: normalize$3,\n    random: random$1,\n    round: round$2,\n    scale: scale$5,\n    setDefaultType: setDefaultType$6,\n    sub: sub$3,\n    subtract: subtract$3,\n    transformMat3: transformMat3$1,\n    transformMat4: transformMat4$2,\n    zero: zero$2\n});\n\n/*\n * Copyright 2022 Gregg Tavares\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n/**\n * 3x3 Matrix math math functions.\n *\n * Almost all functions take an optional `dst` argument. If it is not passed in the\n * functions will create a new matrix. In other words you can do this\n *\n *     const mat = mat3.translation([1, 2, 3]);  // Creates a new translation matrix\n *\n * or\n *\n *     const mat = mat3.create();\n *     mat3.translation([1, 2, 3], mat);  // Puts translation matrix in mat.\n *\n * The first style is often easier but depending on where it's used it generates garbage where\n * as there is almost never allocation with the second style.\n *\n * It is always save to pass any matrix as the destination. So for example\n *\n *     const mat = mat3.identity();\n *     const trans = mat3.translation([1, 2, 3]);\n *     mat3.multiply(mat, trans, mat);  // Multiplies mat * trans and puts result in mat.\n *\n */\nlet MatType$1 = Float32Array;\n// This mess is because with Mat3 we have 3 unused elements.\n// For Float32Array and Float64Array that's not an issue\n// but for Array it's troublesome\nconst ctorMap = new Map([\n    [Float32Array, () => new Float32Array(12)],\n    [Float64Array, () => new Float64Array(12)],\n    [Array, () => new Array(12).fill(0)],\n]);\nlet newMat3 = ctorMap.get(Float32Array);\n/**\n * Sets the type this library creates for a Mat3\n * @param ctor - the constructor for the type. Either `Float32Array`, `Float64Array`, or `Array`\n * @returns previous constructor for Mat3\n */\nfunction setDefaultType$5(ctor) {\n    const oldType = MatType$1;\n    MatType$1 = ctor;\n    newMat3 = ctorMap.get(ctor);\n    return oldType;\n}\n/**\n * Create a Mat3 from values\n *\n * Note: Since passing in a raw JavaScript array\n * is valid in all circumstances, if you want to\n * force a JavaScript array into a Mat3's specified type\n * it would be faster to use\n *\n * ```\n * const m = mat3.clone(someJSArray);\n * ```\n *\n * Note: a consequence of the implementation is if your Mat3Type = `Array`\n * instead of `Float32Array` or `Float64Array` then any values you\n * don't pass in will be undefined. Usually this is not an issue since\n * (a) using `Array` is rare and (b) using `mat3.create` is usually used\n * to create a Mat3 to be filled out as in\n *\n * ```\n * const m = mat3.create();\n * mat3.perspective(fov, aspect, near, far, m);\n * ```\n *\n * @param v0 - value for element 0\n * @param v1 - value for element 1\n * @param v2 - value for element 2\n * @param v3 - value for element 3\n * @param v4 - value for element 4\n * @param v5 - value for element 5\n * @param v6 - value for element 6\n * @param v7 - value for element 7\n * @param v8 - value for element 8\n * @returns matrix created from values.\n */\nfunction create$4(v0, v1, v2, v3, v4, v5, v6, v7, v8) {\n    const dst = newMat3();\n    // to make the array homogenous\n    dst[3] = 0;\n    dst[7] = 0;\n    dst[11] = 0;\n    if (v0 !== undefined) {\n        dst[0] = v0;\n        if (v1 !== undefined) {\n            dst[1] = v1;\n            if (v2 !== undefined) {\n                dst[2] = v2;\n                if (v3 !== undefined) {\n                    dst[4] = v3;\n                    if (v4 !== undefined) {\n                        dst[5] = v4;\n                        if (v5 !== undefined) {\n                            dst[6] = v5;\n                            if (v6 !== undefined) {\n                                dst[8] = v6;\n                                if (v7 !== undefined) {\n                                    dst[9] = v7;\n                                    if (v8 !== undefined) {\n                                        dst[10] = v8;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return dst;\n}\n/**\n * Creates a Mat3 from the upper left 3x3 part of a Mat4\n * @param m4 - source matrix\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns Mat3 made from m4\n */\nfunction fromMat4(m4, dst) {\n    dst = dst || newMat3();\n    dst[0] = m4[0];\n    dst[1] = m4[1];\n    dst[2] = m4[2];\n    dst[3] = 0;\n    dst[4] = m4[4];\n    dst[5] = m4[5];\n    dst[6] = m4[6];\n    dst[7] = 0;\n    dst[8] = m4[8];\n    dst[9] = m4[9];\n    dst[10] = m4[10];\n    dst[11] = 0;\n    return dst;\n}\n/**\n * Creates a Mat3 rotation matrix from a quaternion\n * @param q - quaternion to create matrix from\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns Mat3 made from q\n */\nfunction fromQuat$1(q, dst) {\n    dst = dst || newMat3();\n    const x = q[0];\n    const y = q[1];\n    const z = q[2];\n    const w = q[3];\n    const x2 = x + x;\n    const y2 = y + y;\n    const z2 = z + z;\n    const xx = x * x2;\n    const yx = y * x2;\n    const yy = y * y2;\n    const zx = z * x2;\n    const zy = z * y2;\n    const zz = z * z2;\n    const wx = w * x2;\n    const wy = w * y2;\n    const wz = w * z2;\n    dst[0] = 1 - yy - zz;\n    dst[1] = yx + wz;\n    dst[2] = zx - wy;\n    dst[3] = 0;\n    dst[4] = yx - wz;\n    dst[5] = 1 - xx - zz;\n    dst[6] = zy + wx;\n    dst[7] = 0;\n    dst[8] = zx + wy;\n    dst[9] = zy - wx;\n    dst[10] = 1 - xx - yy;\n    dst[11] = 0;\n    return dst;\n}\n/**\n * Negates a matrix.\n * @param m - The matrix.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns -m.\n */\nfunction negate$3(m, dst) {\n    dst = dst || newMat3();\n    dst[0] = -m[0];\n    dst[1] = -m[1];\n    dst[2] = -m[2];\n    dst[4] = -m[4];\n    dst[5] = -m[5];\n    dst[6] = -m[6];\n    dst[8] = -m[8];\n    dst[9] = -m[9];\n    dst[10] = -m[10];\n    return dst;\n}\n/**\n * Copies a matrix.\n * @param m - The matrix.\n * @param dst - The matrix. If not passed a new one is created.\n * @returns A copy of m.\n */\nfunction copy$4(m, dst) {\n    dst = dst || newMat3();\n    dst[0] = m[0];\n    dst[1] = m[1];\n    dst[2] = m[2];\n    dst[4] = m[4];\n    dst[5] = m[5];\n    dst[6] = m[6];\n    dst[8] = m[8];\n    dst[9] = m[9];\n    dst[10] = m[10];\n    return dst;\n}\n/**\n * Copies a matrix (same as copy)\n * @param m - The matrix.\n * @param dst - The matrix. If not passed a new one is created.\n * @returns A copy of m.\n */\nconst clone$4 = copy$4;\n/**\n * Check if 2 matrices are approximately equal\n * @param a Operand matrix.\n * @param b Operand matrix.\n * @returns true if matrices are approximately equal\n */\nfunction equalsApproximately$4(a, b) {\n    return Math.abs(a[0] - b[0]) < EPSILON &&\n        Math.abs(a[1] - b[1]) < EPSILON &&\n        Math.abs(a[2] - b[2]) < EPSILON &&\n        Math.abs(a[4] - b[4]) < EPSILON &&\n        Math.abs(a[5] - b[5]) < EPSILON &&\n        Math.abs(a[6] - b[6]) < EPSILON &&\n        Math.abs(a[8] - b[8]) < EPSILON &&\n        Math.abs(a[9] - b[9]) < EPSILON &&\n        Math.abs(a[10] - b[10]) < EPSILON;\n}\n/**\n * Check if 2 matrices are exactly equal\n * @param a Operand matrix.\n * @param b Operand matrix.\n * @returns true if matrices are exactly equal\n */\nfunction equals$4(a, b) {\n    return a[0] === b[0] &&\n        a[1] === b[1] &&\n        a[2] === b[2] &&\n        a[4] === b[4] &&\n        a[5] === b[5] &&\n        a[6] === b[6] &&\n        a[8] === b[8] &&\n        a[9] === b[9] &&\n        a[10] === b[10];\n}\n/**\n * Creates a 3-by-3 identity matrix.\n *\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns A 3-by-3 identity matrix.\n */\nfunction identity$2(dst) {\n    dst = dst || newMat3();\n    dst[0] = 1;\n    dst[1] = 0;\n    dst[2] = 0;\n    dst[4] = 0;\n    dst[5] = 1;\n    dst[6] = 0;\n    dst[8] = 0;\n    dst[9] = 0;\n    dst[10] = 1;\n    return dst;\n}\n/**\n * Takes the transpose of a matrix.\n * @param m - The matrix.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The transpose of m.\n */\nfunction transpose$1(m, dst) {\n    dst = dst || newMat3();\n    if (dst === m) {\n        let t;\n        // 0 1 2\n        // 4 5 6\n        // 8 9 10\n        t = m[1];\n        m[1] = m[4];\n        m[4] = t;\n        t = m[2];\n        m[2] = m[8];\n        m[8] = t;\n        t = m[6];\n        m[6] = m[9];\n        m[9] = t;\n        return dst;\n    }\n    const m00 = m[0 * 4 + 0];\n    const m01 = m[0 * 4 + 1];\n    const m02 = m[0 * 4 + 2];\n    const m10 = m[1 * 4 + 0];\n    const m11 = m[1 * 4 + 1];\n    const m12 = m[1 * 4 + 2];\n    const m20 = m[2 * 4 + 0];\n    const m21 = m[2 * 4 + 1];\n    const m22 = m[2 * 4 + 2];\n    dst[0] = m00;\n    dst[1] = m10;\n    dst[2] = m20;\n    dst[4] = m01;\n    dst[5] = m11;\n    dst[6] = m21;\n    dst[8] = m02;\n    dst[9] = m12;\n    dst[10] = m22;\n    return dst;\n}\n/**\n * Computes the inverse of a 3-by-3 matrix.\n * @param m - The matrix.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The inverse of m.\n */\nfunction inverse$4(m, dst) {\n    dst = dst || newMat3();\n    const m00 = m[0 * 4 + 0];\n    const m01 = m[0 * 4 + 1];\n    const m02 = m[0 * 4 + 2];\n    const m10 = m[1 * 4 + 0];\n    const m11 = m[1 * 4 + 1];\n    const m12 = m[1 * 4 + 2];\n    const m20 = m[2 * 4 + 0];\n    const m21 = m[2 * 4 + 1];\n    const m22 = m[2 * 4 + 2];\n    const m11_x_m22 = m11 * m22;\n    const m21_x_m12 = m21 * m12;\n    const m01_x_m22 = m01 * m22;\n    const m21_x_m02 = m21 * m02;\n    const m01_x_m12 = m01 * m12;\n    const m11_x_m02 = m11 * m02;\n    const invDet = 1 / (m00 * (m11_x_m22 - m21_x_m12) -\n        m10 * (m01_x_m22 - m21_x_m02) +\n        m20 * (m01_x_m12 - m11_x_m02));\n    dst[0] = +(m11_x_m22 - m21_x_m12) * invDet;\n    dst[1] = -(m10 * m22 - m20 * m12) * invDet;\n    dst[2] = +(m10 * m21 - m20 * m11) * invDet;\n    dst[4] = -(m01_x_m22 - m21_x_m02) * invDet;\n    dst[5] = +(m00 * m22 - m20 * m02) * invDet;\n    dst[6] = -(m00 * m21 - m20 * m01) * invDet;\n    dst[8] = +(m01_x_m12 - m11_x_m02) * invDet;\n    dst[9] = -(m00 * m12 - m10 * m02) * invDet;\n    dst[10] = +(m00 * m11 - m10 * m01) * invDet;\n    return dst;\n}\n/**\n * Compute the determinant of a matrix\n * @param m - the matrix\n * @returns the determinant\n */\nfunction determinant$1(m) {\n    const m00 = m[0 * 4 + 0];\n    const m01 = m[0 * 4 + 1];\n    const m02 = m[0 * 4 + 2];\n    const m10 = m[1 * 4 + 0];\n    const m11 = m[1 * 4 + 1];\n    const m12 = m[1 * 4 + 2];\n    const m20 = m[2 * 4 + 0];\n    const m21 = m[2 * 4 + 1];\n    const m22 = m[2 * 4 + 2];\n    return m00 * (m11 * m22 - m21 * m12) -\n        m10 * (m01 * m22 - m21 * m02) +\n        m20 * (m01 * m12 - m11 * m02);\n}\n/**\n * Computes the inverse of a 3-by-3 matrix. (same as inverse)\n * @param m - The matrix.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The inverse of m.\n */\nconst invert$3 = inverse$4;\n/**\n * Multiplies two 3-by-3 matrices with a on the left and b on the right\n * @param a - The matrix on the left.\n * @param b - The matrix on the right.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The matrix product of a and b.\n */\nfunction multiply$4(a, b, dst) {\n    dst = dst || newMat3();\n    const a00 = a[0];\n    const a01 = a[1];\n    const a02 = a[2];\n    const a10 = a[4 + 0];\n    const a11 = a[4 + 1];\n    const a12 = a[4 + 2];\n    const a20 = a[8 + 0];\n    const a21 = a[8 + 1];\n    const a22 = a[8 + 2];\n    const b00 = b[0];\n    const b01 = b[1];\n    const b02 = b[2];\n    const b10 = b[4 + 0];\n    const b11 = b[4 + 1];\n    const b12 = b[4 + 2];\n    const b20 = b[8 + 0];\n    const b21 = b[8 + 1];\n    const b22 = b[8 + 2];\n    dst[0] = a00 * b00 + a10 * b01 + a20 * b02;\n    dst[1] = a01 * b00 + a11 * b01 + a21 * b02;\n    dst[2] = a02 * b00 + a12 * b01 + a22 * b02;\n    dst[4] = a00 * b10 + a10 * b11 + a20 * b12;\n    dst[5] = a01 * b10 + a11 * b11 + a21 * b12;\n    dst[6] = a02 * b10 + a12 * b11 + a22 * b12;\n    dst[8] = a00 * b20 + a10 * b21 + a20 * b22;\n    dst[9] = a01 * b20 + a11 * b21 + a21 * b22;\n    dst[10] = a02 * b20 + a12 * b21 + a22 * b22;\n    return dst;\n}\n/**\n * Multiplies two 3-by-3 matrices with a on the left and b on the right (same as multiply)\n * @param a - The matrix on the left.\n * @param b - The matrix on the right.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The matrix product of a and b.\n */\nconst mul$4 = multiply$4;\n/**\n * Sets the translation component of a 3-by-3 matrix to the given\n * vector.\n * @param a - The matrix.\n * @param v - The vector.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The matrix with translation set.\n */\nfunction setTranslation$1(a, v, dst) {\n    dst = dst || identity$2();\n    if (a !== dst) {\n        dst[0] = a[0];\n        dst[1] = a[1];\n        dst[2] = a[2];\n        dst[4] = a[4];\n        dst[5] = a[5];\n        dst[6] = a[6];\n    }\n    dst[8] = v[0];\n    dst[9] = v[1];\n    dst[10] = 1;\n    return dst;\n}\n/**\n * Returns the translation component of a 3-by-3 matrix as a vector with 3\n * entries.\n * @param m - The matrix.\n * @param dst - vector to hold result. If not passed a new one is created.\n * @returns The translation component of m.\n */\nfunction getTranslation$2(m, dst) {\n    dst = dst || create$5();\n    dst[0] = m[8];\n    dst[1] = m[9];\n    return dst;\n}\n/**\n * Returns an axis of a 3x3 matrix as a vector with 2 entries\n * @param m - The matrix.\n * @param axis - The axis 0 = x, 1 = y,\n * @returns The axis component of m.\n */\nfunction getAxis$2(m, axis, dst) {\n    dst = dst || create$5();\n    const off = axis * 4;\n    dst[0] = m[off + 0];\n    dst[1] = m[off + 1];\n    return dst;\n}\n/**\n * Sets an axis of a 3x3 matrix as a vector with 2 entries\n * @param m - The matrix.\n * @param v - the axis vector\n * @param axis - The axis  0 = x, 1 = y;\n * @param dst - The matrix to set. If not passed a new one is created.\n * @returns The matrix with axis set.\n */\nfunction setAxis$1(m, v, axis, dst) {\n    if (dst !== m) {\n        dst = copy$4(m, dst);\n    }\n    const off = axis * 4;\n    dst[off + 0] = v[0];\n    dst[off + 1] = v[1];\n    return dst;\n}\n/**\n * Returns the scaling component of the matrix\n * @param m - The Matrix\n * @param dst - The vector to set. If not passed a new one is created.\n */\nfunction getScaling$2(m, dst) {\n    dst = dst || create$5();\n    const xx = m[0];\n    const xy = m[1];\n    const yx = m[4];\n    const yy = m[5];\n    dst[0] = Math.sqrt(xx * xx + xy * xy);\n    dst[1] = Math.sqrt(yx * yx + yy * yy);\n    return dst;\n}\n/**\n * Creates a 3-by-3 matrix which translates by the given vector v.\n * @param v - The vector by which to translate.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The translation matrix.\n */\nfunction translation$1(v, dst) {\n    dst = dst || newMat3();\n    dst[0] = 1;\n    dst[1] = 0;\n    dst[2] = 0;\n    dst[4] = 0;\n    dst[5] = 1;\n    dst[6] = 0;\n    dst[8] = v[0];\n    dst[9] = v[1];\n    dst[10] = 1;\n    return dst;\n}\n/**\n * Translates the given 3-by-3 matrix by the given vector v.\n * @param m - The matrix.\n * @param v - The vector by which to translate.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The translated matrix.\n */\nfunction translate$1(m, v, dst) {\n    dst = dst || newMat3();\n    const v0 = v[0];\n    const v1 = v[1];\n    const m00 = m[0];\n    const m01 = m[1];\n    const m02 = m[2];\n    const m10 = m[1 * 4 + 0];\n    const m11 = m[1 * 4 + 1];\n    const m12 = m[1 * 4 + 2];\n    const m20 = m[2 * 4 + 0];\n    const m21 = m[2 * 4 + 1];\n    const m22 = m[2 * 4 + 2];\n    if (m !== dst) {\n        dst[0] = m00;\n        dst[1] = m01;\n        dst[2] = m02;\n        dst[4] = m10;\n        dst[5] = m11;\n        dst[6] = m12;\n    }\n    dst[8] = m00 * v0 + m10 * v1 + m20;\n    dst[9] = m01 * v0 + m11 * v1 + m21;\n    dst[10] = m02 * v0 + m12 * v1 + m22;\n    return dst;\n}\n/**\n * Creates a 3-by-3 matrix which rotates  by the given angle.\n * @param angleInRadians - The angle by which to rotate (in radians).\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The rotation matrix.\n */\nfunction rotation$1(angleInRadians, dst) {\n    dst = dst || newMat3();\n    const c = Math.cos(angleInRadians);\n    const s = Math.sin(angleInRadians);\n    dst[0] = c;\n    dst[1] = s;\n    dst[2] = 0;\n    dst[4] = -s;\n    dst[5] = c;\n    dst[6] = 0;\n    dst[8] = 0;\n    dst[9] = 0;\n    dst[10] = 1;\n    return dst;\n}\n/**\n * Rotates the given 3-by-3 matrix  by the given angle.\n * @param m - The matrix.\n * @param angleInRadians - The angle by which to rotate (in radians).\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The rotated matrix.\n */\nfunction rotate$1(m, angleInRadians, dst) {\n    dst = dst || newMat3();\n    const m00 = m[0 * 4 + 0];\n    const m01 = m[0 * 4 + 1];\n    const m02 = m[0 * 4 + 2];\n    const m10 = m[1 * 4 + 0];\n    const m11 = m[1 * 4 + 1];\n    const m12 = m[1 * 4 + 2];\n    const c = Math.cos(angleInRadians);\n    const s = Math.sin(angleInRadians);\n    dst[0] = c * m00 + s * m10;\n    dst[1] = c * m01 + s * m11;\n    dst[2] = c * m02 + s * m12;\n    dst[4] = c * m10 - s * m00;\n    dst[5] = c * m11 - s * m01;\n    dst[6] = c * m12 - s * m02;\n    if (m !== dst) {\n        dst[8] = m[8];\n        dst[9] = m[9];\n        dst[10] = m[10];\n    }\n    return dst;\n}\n/**\n * Creates a 3-by-3 matrix which scales in each dimension by an amount given by\n * the corresponding entry in the given vector; assumes the vector has three\n * entries.\n * @param v - A vector of\n *     2 entries specifying the factor by which to scale in each dimension.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The scaling matrix.\n */\nfunction scaling$1(v, dst) {\n    dst = dst || newMat3();\n    dst[0] = v[0];\n    dst[1] = 0;\n    dst[2] = 0;\n    dst[4] = 0;\n    dst[5] = v[1];\n    dst[6] = 0;\n    dst[8] = 0;\n    dst[9] = 0;\n    dst[10] = 1;\n    return dst;\n}\n/**\n * Scales the given 3-by-3 matrix in each dimension by an amount\n * given by the corresponding entry in the given vector; assumes the vector has\n * three entries.\n * @param m - The matrix to be modified.\n * @param v - A vector of 2 entries specifying the\n *     factor by which to scale in each dimension.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The scaled matrix.\n */\nfunction scale$4(m, v, dst) {\n    dst = dst || newMat3();\n    const v0 = v[0];\n    const v1 = v[1];\n    dst[0] = v0 * m[0 * 4 + 0];\n    dst[1] = v0 * m[0 * 4 + 1];\n    dst[2] = v0 * m[0 * 4 + 2];\n    dst[4] = v1 * m[1 * 4 + 0];\n    dst[5] = v1 * m[1 * 4 + 1];\n    dst[6] = v1 * m[1 * 4 + 2];\n    if (m !== dst) {\n        dst[8] = m[8];\n        dst[9] = m[9];\n        dst[10] = m[10];\n    }\n    return dst;\n}\n\nvar mat3Impl = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    clone: clone$4,\n    copy: copy$4,\n    create: create$4,\n    determinant: determinant$1,\n    equals: equals$4,\n    equalsApproximately: equalsApproximately$4,\n    fromMat4: fromMat4,\n    fromQuat: fromQuat$1,\n    getAxis: getAxis$2,\n    getScaling: getScaling$2,\n    getTranslation: getTranslation$2,\n    identity: identity$2,\n    inverse: inverse$4,\n    invert: invert$3,\n    mul: mul$4,\n    multiply: multiply$4,\n    negate: negate$3,\n    rotate: rotate$1,\n    rotation: rotation$1,\n    scale: scale$4,\n    scaling: scaling$1,\n    setAxis: setAxis$1,\n    setDefaultType: setDefaultType$5,\n    setTranslation: setTranslation$1,\n    translate: translate$1,\n    translation: translation$1,\n    transpose: transpose$1\n});\n\n/**\n *\n * Vec3 math functions.\n *\n * Almost all functions take an optional `dst` argument. If it is not passed in the\n * functions will create a new `Vec3`. In other words you can do this\n *\n *     const v = vec3.cross(v1, v2);  // Creates a new Vec3 with the cross product of v1 x v2.\n *\n * or\n *\n *     const v = vec3.create();\n *     vec3.cross(v1, v2, v);  // Puts the cross product of v1 x v2 in v\n *\n * The first style is often easier but depending on where it's used it generates garbage where\n * as there is almost never allocation with the second style.\n *\n * It is always safe to pass any vector as the destination. So for example\n *\n *     vec3.cross(v1, v2, v1);  // Puts the cross product of v1 x v2 in v1\n *\n */\nlet VecType$1 = Float32Array;\n/**\n * Sets the type this library creates for a Vec3\n * @param ctor - the constructor for the type. Either `Float32Array`, `Float64Array`, or `Array`\n * @returns previous constructor for Vec3\n */\nfunction setDefaultType$4(ctor) {\n    const oldType = VecType$1;\n    VecType$1 = ctor;\n    return oldType;\n}\n/**\n * Creates a vec3; may be called with x, y, z to set initial values.\n * @param x - Initial x value.\n * @param y - Initial y value.\n * @param z - Initial z value.\n * @returns the created vector\n */\nfunction create$3(x, y, z) {\n    const dst = new VecType$1(3);\n    if (x !== undefined) {\n        dst[0] = x;\n        if (y !== undefined) {\n            dst[1] = y;\n            if (z !== undefined) {\n                dst[2] = z;\n            }\n        }\n    }\n    return dst;\n}\n\n/*\n * Copyright 2022 Gregg Tavares\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n/**\n * Creates a vec3; may be called with x, y, z to set initial values. (same as create)\n * @param x - Initial x value.\n * @param y - Initial y value.\n * @param z - Initial z value.\n * @returns the created vector\n */\nconst fromValues$2 = create$3;\n/**\n * Applies Math.ceil to each element of vector\n * @param v - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that is the ceil of each element of v.\n */\nfunction ceil$1(v, dst) {\n    dst = dst || new VecType$1(3);\n    dst[0] = Math.ceil(v[0]);\n    dst[1] = Math.ceil(v[1]);\n    dst[2] = Math.ceil(v[2]);\n    return dst;\n}\n/**\n * Applies Math.floor to each element of vector\n * @param v - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that is the floor of each element of v.\n */\nfunction floor$1(v, dst) {\n    dst = dst || new VecType$1(3);\n    dst[0] = Math.floor(v[0]);\n    dst[1] = Math.floor(v[1]);\n    dst[2] = Math.floor(v[2]);\n    return dst;\n}\n/**\n * Applies Math.round to each element of vector\n * @param v - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that is the round of each element of v.\n */\nfunction round$1(v, dst) {\n    dst = dst || new VecType$1(3);\n    dst[0] = Math.round(v[0]);\n    dst[1] = Math.round(v[1]);\n    dst[2] = Math.round(v[2]);\n    return dst;\n}\n/**\n * Clamp each element of vector between min and max\n * @param v - Operand vector.\n * @param max - Min value, default 0\n * @param min - Max value, default 1\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that the clamped value of each element of v.\n */\nfunction clamp$1(v, min = 0, max = 1, dst) {\n    dst = dst || new VecType$1(3);\n    dst[0] = Math.min(max, Math.max(min, v[0]));\n    dst[1] = Math.min(max, Math.max(min, v[1]));\n    dst[2] = Math.min(max, Math.max(min, v[2]));\n    return dst;\n}\n/**\n * Adds two vectors; assumes a and b have the same dimension.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that is the sum of a and b.\n */\nfunction add$2(a, b, dst) {\n    dst = dst || new VecType$1(3);\n    dst[0] = a[0] + b[0];\n    dst[1] = a[1] + b[1];\n    dst[2] = a[2] + b[2];\n    return dst;\n}\n/**\n * Adds two vectors, scaling the 2nd; assumes a and b have the same dimension.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param scale - Amount to scale b\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that is the sum of a + b * scale.\n */\nfunction addScaled$1(a, b, scale, dst) {\n    dst = dst || new VecType$1(3);\n    dst[0] = a[0] + b[0] * scale;\n    dst[1] = a[1] + b[1] * scale;\n    dst[2] = a[2] + b[2] * scale;\n    return dst;\n}\n/**\n * Returns the angle in radians between two vectors.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @returns The angle in radians between the 2 vectors.\n */\nfunction angle$1(a, b) {\n    const ax = a[0];\n    const ay = a[1];\n    const az = a[2];\n    const bx = a[0];\n    const by = a[1];\n    const bz = a[2];\n    const mag1 = Math.sqrt(ax * ax + ay * ay + az * az);\n    const mag2 = Math.sqrt(bx * bx + by * by + bz * bz);\n    const mag = mag1 * mag2;\n    const cosine = mag && dot$2(a, b) / mag;\n    return Math.acos(cosine);\n}\n/**\n * Subtracts two vectors.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that is the difference of a and b.\n */\nfunction subtract$2(a, b, dst) {\n    dst = dst || new VecType$1(3);\n    dst[0] = a[0] - b[0];\n    dst[1] = a[1] - b[1];\n    dst[2] = a[2] - b[2];\n    return dst;\n}\n/**\n * Subtracts two vectors.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that is the difference of a and b.\n */\nconst sub$2 = subtract$2;\n/**\n * Check if 2 vectors are approximately equal\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @returns true if vectors are approximately equal\n */\nfunction equalsApproximately$3(a, b) {\n    return Math.abs(a[0] - b[0]) < EPSILON &&\n        Math.abs(a[1] - b[1]) < EPSILON &&\n        Math.abs(a[2] - b[2]) < EPSILON;\n}\n/**\n * Check if 2 vectors are exactly equal\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @returns true if vectors are exactly equal\n */\nfunction equals$3(a, b) {\n    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];\n}\n/**\n * Performs linear interpolation on two vectors.\n * Given vectors a and b and interpolation coefficient t, returns\n * a + t * (b - a).\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param t - Interpolation coefficient.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The linear interpolated result.\n */\nfunction lerp$2(a, b, t, dst) {\n    dst = dst || new VecType$1(3);\n    dst[0] = a[0] + t * (b[0] - a[0]);\n    dst[1] = a[1] + t * (b[1] - a[1]);\n    dst[2] = a[2] + t * (b[2] - a[2]);\n    return dst;\n}\n/**\n * Performs linear interpolation on two vectors.\n * Given vectors a and b and interpolation coefficient vector t, returns\n * a + t * (b - a).\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param t - Interpolation coefficients vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns the linear interpolated result.\n */\nfunction lerpV$1(a, b, t, dst) {\n    dst = dst || new VecType$1(3);\n    dst[0] = a[0] + t[0] * (b[0] - a[0]);\n    dst[1] = a[1] + t[1] * (b[1] - a[1]);\n    dst[2] = a[2] + t[2] * (b[2] - a[2]);\n    return dst;\n}\n/**\n * Return max values of two vectors.\n * Given vectors a and b returns\n * [max(a[0], b[0]), max(a[1], b[1]), max(a[2], b[2])].\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The max components vector.\n */\nfunction max$1(a, b, dst) {\n    dst = dst || new VecType$1(3);\n    dst[0] = Math.max(a[0], b[0]);\n    dst[1] = Math.max(a[1], b[1]);\n    dst[2] = Math.max(a[2], b[2]);\n    return dst;\n}\n/**\n * Return min values of two vectors.\n * Given vectors a and b returns\n * [min(a[0], b[0]), min(a[1], b[1]), min(a[2], b[2])].\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The min components vector.\n */\nfunction min$1(a, b, dst) {\n    dst = dst || new VecType$1(3);\n    dst[0] = Math.min(a[0], b[0]);\n    dst[1] = Math.min(a[1], b[1]);\n    dst[2] = Math.min(a[2], b[2]);\n    return dst;\n}\n/**\n * Multiplies a vector by a scalar.\n * @param v - The vector.\n * @param k - The scalar.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The scaled vector.\n */\nfunction mulScalar$2(v, k, dst) {\n    dst = dst || new VecType$1(3);\n    dst[0] = v[0] * k;\n    dst[1] = v[1] * k;\n    dst[2] = v[2] * k;\n    return dst;\n}\n/**\n * Multiplies a vector by a scalar. (same as mulScalar)\n * @param v - The vector.\n * @param k - The scalar.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The scaled vector.\n */\nconst scale$3 = mulScalar$2;\n/**\n * Divides a vector by a scalar.\n * @param v - The vector.\n * @param k - The scalar.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The scaled vector.\n */\nfunction divScalar$2(v, k, dst) {\n    dst = dst || new VecType$1(3);\n    dst[0] = v[0] / k;\n    dst[1] = v[1] / k;\n    dst[2] = v[2] / k;\n    return dst;\n}\n/**\n * Inverse a vector.\n * @param v - The vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The inverted vector.\n */\nfunction inverse$3(v, dst) {\n    dst = dst || new VecType$1(3);\n    dst[0] = 1 / v[0];\n    dst[1] = 1 / v[1];\n    dst[2] = 1 / v[2];\n    return dst;\n}\n/**\n * Invert a vector. (same as inverse)\n * @param v - The vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The inverted vector.\n */\nconst invert$2 = inverse$3;\n/**\n * Computes the cross product of two vectors; assumes both vectors have\n * three entries.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The vector of a cross b.\n */\nfunction cross(a, b, dst) {\n    dst = dst || new VecType$1(3);\n    const t1 = a[2] * b[0] - a[0] * b[2];\n    const t2 = a[0] * b[1] - a[1] * b[0];\n    dst[0] = a[1] * b[2] - a[2] * b[1];\n    dst[1] = t1;\n    dst[2] = t2;\n    return dst;\n}\n/**\n * Computes the dot product of two vectors; assumes both vectors have\n * three entries.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @returns dot product\n */\nfunction dot$2(a, b) {\n    return (a[0] * b[0]) + (a[1] * b[1]) + (a[2] * b[2]);\n}\n/**\n * Computes the length of vector\n * @param v - vector.\n * @returns length of vector.\n */\nfunction length$2(v) {\n    const v0 = v[0];\n    const v1 = v[1];\n    const v2 = v[2];\n    return Math.sqrt(v0 * v0 + v1 * v1 + v2 * v2);\n}\n/**\n * Computes the length of vector (same as length)\n * @param v - vector.\n * @returns length of vector.\n */\nconst len$2 = length$2;\n/**\n * Computes the square of the length of vector\n * @param v - vector.\n * @returns square of the length of vector.\n */\nfunction lengthSq$2(v) {\n    const v0 = v[0];\n    const v1 = v[1];\n    const v2 = v[2];\n    return v0 * v0 + v1 * v1 + v2 * v2;\n}\n/**\n * Computes the square of the length of vector (same as lengthSq)\n * @param v - vector.\n * @returns square of the length of vector.\n */\nconst lenSq$2 = lengthSq$2;\n/**\n * Computes the distance between 2 points\n * @param a - vector.\n * @param b - vector.\n * @returns distance between a and b\n */\nfunction distance$1(a, b) {\n    const dx = a[0] - b[0];\n    const dy = a[1] - b[1];\n    const dz = a[2] - b[2];\n    return Math.sqrt(dx * dx + dy * dy + dz * dz);\n}\n/**\n * Computes the distance between 2 points (same as distance)\n * @param a - vector.\n * @param b - vector.\n * @returns distance between a and b\n */\nconst dist$1 = distance$1;\n/**\n * Computes the square of the distance between 2 points\n * @param a - vector.\n * @param b - vector.\n * @returns square of the distance between a and b\n */\nfunction distanceSq$1(a, b) {\n    const dx = a[0] - b[0];\n    const dy = a[1] - b[1];\n    const dz = a[2] - b[2];\n    return dx * dx + dy * dy + dz * dz;\n}\n/**\n * Computes the square of the distance between 2 points (same as distanceSq)\n * @param a - vector.\n * @param b - vector.\n * @returns square of the distance between a and b\n */\nconst distSq$1 = distanceSq$1;\n/**\n * Divides a vector by its Euclidean length and returns the quotient.\n * @param v - The vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The normalized vector.\n */\nfunction normalize$2(v, dst) {\n    dst = dst || new VecType$1(3);\n    const v0 = v[0];\n    const v1 = v[1];\n    const v2 = v[2];\n    const len = Math.sqrt(v0 * v0 + v1 * v1 + v2 * v2);\n    if (len > 0.00001) {\n        dst[0] = v0 / len;\n        dst[1] = v1 / len;\n        dst[2] = v2 / len;\n    }\n    else {\n        dst[0] = 0;\n        dst[1] = 0;\n        dst[2] = 0;\n    }\n    return dst;\n}\n/**\n * Negates a vector.\n * @param v - The vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns -v.\n */\nfunction negate$2(v, dst) {\n    dst = dst || new VecType$1(3);\n    dst[0] = -v[0];\n    dst[1] = -v[1];\n    dst[2] = -v[2];\n    return dst;\n}\n/**\n * Copies a vector. (same as clone)\n * @param v - The vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A copy of v.\n */\nfunction copy$3(v, dst) {\n    dst = dst || new VecType$1(3);\n    dst[0] = v[0];\n    dst[1] = v[1];\n    dst[2] = v[2];\n    return dst;\n}\n/**\n * Clones a vector. (same as copy)\n * @param v - The vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A copy of v.\n */\nconst clone$3 = copy$3;\n/**\n * Multiplies a vector by another vector (component-wise); assumes a and\n * b have the same length.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The vector of products of entries of a and b.\n */\nfunction multiply$3(a, b, dst) {\n    dst = dst || new VecType$1(3);\n    dst[0] = a[0] * b[0];\n    dst[1] = a[1] * b[1];\n    dst[2] = a[2] * b[2];\n    return dst;\n}\n/**\n * Multiplies a vector by another vector (component-wise); assumes a and\n * b have the same length. (same as mul)\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The vector of products of entries of a and b.\n */\nconst mul$3 = multiply$3;\n/**\n * Divides a vector by another vector (component-wise); assumes a and\n * b have the same length.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The vector of quotients of entries of a and b.\n */\nfunction divide$1(a, b, dst) {\n    dst = dst || new VecType$1(3);\n    dst[0] = a[0] / b[0];\n    dst[1] = a[1] / b[1];\n    dst[2] = a[2] / b[2];\n    return dst;\n}\n/**\n * Divides a vector by another vector (component-wise); assumes a and\n * b have the same length. (same as divide)\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The vector of quotients of entries of a and b.\n */\nconst div$1 = divide$1;\n/**\n * Creates a random vector\n * @param scale - Default 1\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The random vector.\n */\nfunction random(scale = 1, dst) {\n    dst = dst || new VecType$1(3);\n    const angle = Math.random() * 2 * Math.PI;\n    const z = Math.random() * 2 - 1;\n    const zScale = Math.sqrt(1 - z * z) * scale;\n    dst[0] = Math.cos(angle) * zScale;\n    dst[1] = Math.sin(angle) * zScale;\n    dst[2] = z * scale;\n    return dst;\n}\n/**\n * Zero's a vector\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The zeroed vector.\n */\nfunction zero$1(dst) {\n    dst = dst || new VecType$1(3);\n    dst[0] = 0;\n    dst[1] = 0;\n    dst[2] = 0;\n    return dst;\n}\n/**\n * transform vec3 by 4x4 matrix\n * @param v - the vector\n * @param m - The matrix.\n * @param dst - optional vec3 to store result. If not passed a new one is created.\n * @returns the transformed vector\n */\nfunction transformMat4$1(v, m, dst) {\n    dst = dst || new VecType$1(3);\n    const x = v[0];\n    const y = v[1];\n    const z = v[2];\n    const w = (m[3] * x + m[7] * y + m[11] * z + m[15]) || 1;\n    dst[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;\n    dst[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;\n    dst[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;\n    return dst;\n}\n/**\n * Transform vec4 by upper 3x3 matrix inside 4x4 matrix.\n * @param v - The direction.\n * @param m - The matrix.\n * @param dst - optional Vec3 to store result. If not passed a new one is created.\n * @returns The transformed vector.\n */\nfunction transformMat4Upper3x3(v, m, dst) {\n    dst = dst || new VecType$1(3);\n    const v0 = v[0];\n    const v1 = v[1];\n    const v2 = v[2];\n    dst[0] = v0 * m[0 * 4 + 0] + v1 * m[1 * 4 + 0] + v2 * m[2 * 4 + 0];\n    dst[1] = v0 * m[0 * 4 + 1] + v1 * m[1 * 4 + 1] + v2 * m[2 * 4 + 1];\n    dst[2] = v0 * m[0 * 4 + 2] + v1 * m[1 * 4 + 2] + v2 * m[2 * 4 + 2];\n    return dst;\n}\n/**\n * Transforms vec4 by 3x3 matrix\n *\n * @param v - the vector\n * @param m - The matrix.\n * @param dst - optional vec3 to store result. If not passed a new one is created.\n * @returns the transformed vector\n */\nfunction transformMat3(v, m, dst) {\n    dst = dst || new VecType$1(3);\n    const x = v[0];\n    const y = v[1];\n    const z = v[2];\n    dst[0] = x * m[0] + y * m[4] + z * m[8];\n    dst[1] = x * m[1] + y * m[5] + z * m[9];\n    dst[2] = x * m[2] + y * m[6] + z * m[10];\n    return dst;\n}\n/**\n * Returns the translation component of a 4-by-4 matrix as a vector with 3\n * entries.\n * @param m - The matrix.\n * @param dst - vector to hold result. If not passed a new one is created.\n * @returns The translation component of m.\n */\nfunction getTranslation$1(m, dst) {\n    dst = dst || new VecType$1(3);\n    dst[0] = m[12];\n    dst[1] = m[13];\n    dst[2] = m[14];\n    return dst;\n}\n/**\n * Returns an axis of a 4x4 matrix as a vector with 3 entries\n * @param m - The matrix.\n * @param axis - The axis 0 = x, 1 = y, 2 = z;\n * @returns The axis component of m.\n */\nfunction getAxis$1(m, axis, dst) {\n    dst = dst || new VecType$1(3);\n    const off = axis * 4;\n    dst[0] = m[off + 0];\n    dst[1] = m[off + 1];\n    dst[2] = m[off + 2];\n    return dst;\n}\n/**\n * Returns the scaling component of the matrix\n * @param m - The Matrix\n * @param dst - The vector to set. If not passed a new one is created.\n */\nfunction getScaling$1(m, dst) {\n    dst = dst || new VecType$1(3);\n    const xx = m[0];\n    const xy = m[1];\n    const xz = m[2];\n    const yx = m[4];\n    const yy = m[5];\n    const yz = m[6];\n    const zx = m[8];\n    const zy = m[9];\n    const zz = m[10];\n    dst[0] = Math.sqrt(xx * xx + xy * xy + xz * xz);\n    dst[1] = Math.sqrt(yx * yx + yy * yy + yz * yz);\n    dst[2] = Math.sqrt(zx * zx + zy * zy + zz * zz);\n    return dst;\n}\n\nvar vec3Impl = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    add: add$2,\n    addScaled: addScaled$1,\n    angle: angle$1,\n    ceil: ceil$1,\n    clamp: clamp$1,\n    clone: clone$3,\n    copy: copy$3,\n    create: create$3,\n    cross: cross,\n    dist: dist$1,\n    distSq: distSq$1,\n    distance: distance$1,\n    distanceSq: distanceSq$1,\n    div: div$1,\n    divScalar: divScalar$2,\n    divide: divide$1,\n    dot: dot$2,\n    equals: equals$3,\n    equalsApproximately: equalsApproximately$3,\n    floor: floor$1,\n    fromValues: fromValues$2,\n    getAxis: getAxis$1,\n    getScaling: getScaling$1,\n    getTranslation: getTranslation$1,\n    inverse: inverse$3,\n    invert: invert$2,\n    len: len$2,\n    lenSq: lenSq$2,\n    length: length$2,\n    lengthSq: lengthSq$2,\n    lerp: lerp$2,\n    lerpV: lerpV$1,\n    max: max$1,\n    min: min$1,\n    mul: mul$3,\n    mulScalar: mulScalar$2,\n    multiply: multiply$3,\n    negate: negate$2,\n    normalize: normalize$2,\n    random: random,\n    round: round$1,\n    scale: scale$3,\n    setDefaultType: setDefaultType$4,\n    sub: sub$2,\n    subtract: subtract$2,\n    transformMat3: transformMat3,\n    transformMat4: transformMat4$1,\n    transformMat4Upper3x3: transformMat4Upper3x3,\n    zero: zero$1\n});\n\n/**\n * 4x4 Matrix math math functions.\n *\n * Almost all functions take an optional `dst` argument. If it is not passed in the\n * functions will create a new matrix. In other words you can do this\n *\n *     const mat = mat4.translation([1, 2, 3]);  // Creates a new translation matrix\n *\n * or\n *\n *     const mat = mat4.create();\n *     mat4.translation([1, 2, 3], mat);  // Puts translation matrix in mat.\n *\n * The first style is often easier but depending on where it's used it generates garbage where\n * as there is almost never allocation with the second style.\n *\n * It is always save to pass any matrix as the destination. So for example\n *\n *     const mat = mat4.identity();\n *     const trans = mat4.translation([1, 2, 3]);\n *     mat4.multiply(mat, trans, mat);  // Multiplies mat * trans and puts result in mat.\n *\n */\nlet MatType = Float32Array;\n/**\n * Sets the type this library creates for a Mat4\n * @param ctor - the constructor for the type. Either `Float32Array`, `Float64Array`, or `Array`\n * @returns previous constructor for Mat4\n */\nfunction setDefaultType$3(ctor) {\n    const oldType = MatType;\n    MatType = ctor;\n    return oldType;\n}\n/**\n * Create a Mat4 from values\n *\n * Note: Since passing in a raw JavaScript array\n * is valid in all circumstances, if you want to\n * force a JavaScript array into a Mat4's specified type\n * it would be faster to use\n *\n * ```\n * const m = mat4.clone(someJSArray);\n * ```\n *\n * Note: a consequence of the implementation is if your Mat4Type = `Array`\n * instead of `Float32Array` or `Float64Array` then any values you\n * don't pass in will be undefined. Usually this is not an issue since\n * (a) using `Array` is rare and (b) using `mat4.create` is usually used\n * to create a Mat4 to be filled out as in\n *\n * ```\n * const m = mat4.create();\n * mat4.perspective(fov, aspect, near, far, m);\n * ```\n *\n * @param v0 - value for element 0\n * @param v1 - value for element 1\n * @param v2 - value for element 2\n * @param v3 - value for element 3\n * @param v4 - value for element 4\n * @param v5 - value for element 5\n * @param v6 - value for element 6\n * @param v7 - value for element 7\n * @param v8 - value for element 8\n * @param v9 - value for element 9\n * @param v10 - value for element 10\n * @param v11 - value for element 11\n * @param v12 - value for element 12\n * @param v13 - value for element 13\n * @param v14 - value for element 14\n * @param v15 - value for element 15\n * @returns created from values.\n */\nfunction create$2(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15) {\n    const dst = new MatType(16);\n    if (v0 !== undefined) {\n        dst[0] = v0;\n        if (v1 !== undefined) {\n            dst[1] = v1;\n            if (v2 !== undefined) {\n                dst[2] = v2;\n                if (v3 !== undefined) {\n                    dst[3] = v3;\n                    if (v4 !== undefined) {\n                        dst[4] = v4;\n                        if (v5 !== undefined) {\n                            dst[5] = v5;\n                            if (v6 !== undefined) {\n                                dst[6] = v6;\n                                if (v7 !== undefined) {\n                                    dst[7] = v7;\n                                    if (v8 !== undefined) {\n                                        dst[8] = v8;\n                                        if (v9 !== undefined) {\n                                            dst[9] = v9;\n                                            if (v10 !== undefined) {\n                                                dst[10] = v10;\n                                                if (v11 !== undefined) {\n                                                    dst[11] = v11;\n                                                    if (v12 !== undefined) {\n                                                        dst[12] = v12;\n                                                        if (v13 !== undefined) {\n                                                            dst[13] = v13;\n                                                            if (v14 !== undefined) {\n                                                                dst[14] = v14;\n                                                                if (v15 !== undefined) {\n                                                                    dst[15] = v15;\n                                                                }\n                                                            }\n                                                        }\n                                                    }\n                                                }\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return dst;\n}\n/**\n * Creates a Mat4 from a Mat3\n * @param m3 - source matrix\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns Mat4 made from m3\n */\nfunction fromMat3(m3, dst) {\n    dst = dst || new MatType(16);\n    dst[0] = m3[0];\n    dst[1] = m3[1];\n    dst[2] = m3[2];\n    dst[3] = 0;\n    dst[4] = m3[4];\n    dst[5] = m3[5];\n    dst[6] = m3[6];\n    dst[7] = 0;\n    dst[8] = m3[8];\n    dst[9] = m3[9];\n    dst[10] = m3[10];\n    dst[11] = 0;\n    dst[12] = 0;\n    dst[13] = 0;\n    dst[14] = 0;\n    dst[15] = 1;\n    return dst;\n}\n/**\n * Creates a Mat4 rotation matrix from a quaternion\n * @param q - quaternion to create matrix from\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns Mat4 made from q\n */\nfunction fromQuat(q, dst) {\n    dst = dst || new MatType(16);\n    const x = q[0];\n    const y = q[1];\n    const z = q[2];\n    const w = q[3];\n    const x2 = x + x;\n    const y2 = y + y;\n    const z2 = z + z;\n    const xx = x * x2;\n    const yx = y * x2;\n    const yy = y * y2;\n    const zx = z * x2;\n    const zy = z * y2;\n    const zz = z * z2;\n    const wx = w * x2;\n    const wy = w * y2;\n    const wz = w * z2;\n    dst[0] = 1 - yy - zz;\n    dst[1] = yx + wz;\n    dst[2] = zx - wy;\n    dst[3] = 0;\n    dst[4] = yx - wz;\n    dst[5] = 1 - xx - zz;\n    dst[6] = zy + wx;\n    dst[7] = 0;\n    dst[8] = zx + wy;\n    dst[9] = zy - wx;\n    dst[10] = 1 - xx - yy;\n    dst[11] = 0;\n    dst[12] = 0;\n    dst[13] = 0;\n    dst[14] = 0;\n    dst[15] = 1;\n    return dst;\n}\n/**\n * Negates a matrix.\n * @param m - The matrix.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns -m.\n */\nfunction negate$1(m, dst) {\n    dst = dst || new MatType(16);\n    dst[0] = -m[0];\n    dst[1] = -m[1];\n    dst[2] = -m[2];\n    dst[3] = -m[3];\n    dst[4] = -m[4];\n    dst[5] = -m[5];\n    dst[6] = -m[6];\n    dst[7] = -m[7];\n    dst[8] = -m[8];\n    dst[9] = -m[9];\n    dst[10] = -m[10];\n    dst[11] = -m[11];\n    dst[12] = -m[12];\n    dst[13] = -m[13];\n    dst[14] = -m[14];\n    dst[15] = -m[15];\n    return dst;\n}\n/**\n * Copies a matrix.\n * @param m - The matrix.\n * @param dst - The matrix. If not passed a new one is created.\n * @returns A copy of m.\n */\nfunction copy$2(m, dst) {\n    dst = dst || new MatType(16);\n    dst[0] = m[0];\n    dst[1] = m[1];\n    dst[2] = m[2];\n    dst[3] = m[3];\n    dst[4] = m[4];\n    dst[5] = m[5];\n    dst[6] = m[6];\n    dst[7] = m[7];\n    dst[8] = m[8];\n    dst[9] = m[9];\n    dst[10] = m[10];\n    dst[11] = m[11];\n    dst[12] = m[12];\n    dst[13] = m[13];\n    dst[14] = m[14];\n    dst[15] = m[15];\n    return dst;\n}\n/**\n * Copies a matrix (same as copy)\n * @param m - The matrix.\n * @param dst - The matrix. If not passed a new one is created.\n * @returns A copy of m.\n */\nconst clone$2 = copy$2;\n/**\n * Check if 2 matrices are approximately equal\n * @param a - Operand matrix.\n * @param b - Operand matrix.\n * @returns true if matrices are approximately equal\n */\nfunction equalsApproximately$2(a, b) {\n    return Math.abs(a[0] - b[0]) < EPSILON &&\n        Math.abs(a[1] - b[1]) < EPSILON &&\n        Math.abs(a[2] - b[2]) < EPSILON &&\n        Math.abs(a[3] - b[3]) < EPSILON &&\n        Math.abs(a[4] - b[4]) < EPSILON &&\n        Math.abs(a[5] - b[5]) < EPSILON &&\n        Math.abs(a[6] - b[6]) < EPSILON &&\n        Math.abs(a[7] - b[7]) < EPSILON &&\n        Math.abs(a[8] - b[8]) < EPSILON &&\n        Math.abs(a[9] - b[9]) < EPSILON &&\n        Math.abs(a[10] - b[10]) < EPSILON &&\n        Math.abs(a[11] - b[11]) < EPSILON &&\n        Math.abs(a[12] - b[12]) < EPSILON &&\n        Math.abs(a[13] - b[13]) < EPSILON &&\n        Math.abs(a[14] - b[14]) < EPSILON &&\n        Math.abs(a[15] - b[15]) < EPSILON;\n}\n/**\n * Check if 2 matrices are exactly equal\n * @param a - Operand matrix.\n * @param b - Operand matrix.\n * @returns true if matrices are exactly equal\n */\nfunction equals$2(a, b) {\n    return a[0] === b[0] &&\n        a[1] === b[1] &&\n        a[2] === b[2] &&\n        a[3] === b[3] &&\n        a[4] === b[4] &&\n        a[5] === b[5] &&\n        a[6] === b[6] &&\n        a[7] === b[7] &&\n        a[8] === b[8] &&\n        a[9] === b[9] &&\n        a[10] === b[10] &&\n        a[11] === b[11] &&\n        a[12] === b[12] &&\n        a[13] === b[13] &&\n        a[14] === b[14] &&\n        a[15] === b[15];\n}\n/**\n * Creates a 4-by-4 identity matrix.\n *\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns A 4-by-4 identity matrix.\n */\nfunction identity$1(dst) {\n    dst = dst || new MatType(16);\n    dst[0] = 1;\n    dst[1] = 0;\n    dst[2] = 0;\n    dst[3] = 0;\n    dst[4] = 0;\n    dst[5] = 1;\n    dst[6] = 0;\n    dst[7] = 0;\n    dst[8] = 0;\n    dst[9] = 0;\n    dst[10] = 1;\n    dst[11] = 0;\n    dst[12] = 0;\n    dst[13] = 0;\n    dst[14] = 0;\n    dst[15] = 1;\n    return dst;\n}\n/**\n * Takes the transpose of a matrix.\n * @param m - The matrix.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The transpose of m.\n */\nfunction transpose(m, dst) {\n    dst = dst || new MatType(16);\n    if (dst === m) {\n        let t;\n        t = m[1];\n        m[1] = m[4];\n        m[4] = t;\n        t = m[2];\n        m[2] = m[8];\n        m[8] = t;\n        t = m[3];\n        m[3] = m[12];\n        m[12] = t;\n        t = m[6];\n        m[6] = m[9];\n        m[9] = t;\n        t = m[7];\n        m[7] = m[13];\n        m[13] = t;\n        t = m[11];\n        m[11] = m[14];\n        m[14] = t;\n        return dst;\n    }\n    const m00 = m[0 * 4 + 0];\n    const m01 = m[0 * 4 + 1];\n    const m02 = m[0 * 4 + 2];\n    const m03 = m[0 * 4 + 3];\n    const m10 = m[1 * 4 + 0];\n    const m11 = m[1 * 4 + 1];\n    const m12 = m[1 * 4 + 2];\n    const m13 = m[1 * 4 + 3];\n    const m20 = m[2 * 4 + 0];\n    const m21 = m[2 * 4 + 1];\n    const m22 = m[2 * 4 + 2];\n    const m23 = m[2 * 4 + 3];\n    const m30 = m[3 * 4 + 0];\n    const m31 = m[3 * 4 + 1];\n    const m32 = m[3 * 4 + 2];\n    const m33 = m[3 * 4 + 3];\n    dst[0] = m00;\n    dst[1] = m10;\n    dst[2] = m20;\n    dst[3] = m30;\n    dst[4] = m01;\n    dst[5] = m11;\n    dst[6] = m21;\n    dst[7] = m31;\n    dst[8] = m02;\n    dst[9] = m12;\n    dst[10] = m22;\n    dst[11] = m32;\n    dst[12] = m03;\n    dst[13] = m13;\n    dst[14] = m23;\n    dst[15] = m33;\n    return dst;\n}\n/**\n * Computes the inverse of a 4-by-4 matrix.\n * @param m - The matrix.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The inverse of m.\n */\nfunction inverse$2(m, dst) {\n    dst = dst || new MatType(16);\n    const m00 = m[0 * 4 + 0];\n    const m01 = m[0 * 4 + 1];\n    const m02 = m[0 * 4 + 2];\n    const m03 = m[0 * 4 + 3];\n    const m10 = m[1 * 4 + 0];\n    const m11 = m[1 * 4 + 1];\n    const m12 = m[1 * 4 + 2];\n    const m13 = m[1 * 4 + 3];\n    const m20 = m[2 * 4 + 0];\n    const m21 = m[2 * 4 + 1];\n    const m22 = m[2 * 4 + 2];\n    const m23 = m[2 * 4 + 3];\n    const m30 = m[3 * 4 + 0];\n    const m31 = m[3 * 4 + 1];\n    const m32 = m[3 * 4 + 2];\n    const m33 = m[3 * 4 + 3];\n    const tmp0 = m22 * m33;\n    const tmp1 = m32 * m23;\n    const tmp2 = m12 * m33;\n    const tmp3 = m32 * m13;\n    const tmp4 = m12 * m23;\n    const tmp5 = m22 * m13;\n    const tmp6 = m02 * m33;\n    const tmp7 = m32 * m03;\n    const tmp8 = m02 * m23;\n    const tmp9 = m22 * m03;\n    const tmp10 = m02 * m13;\n    const tmp11 = m12 * m03;\n    const tmp12 = m20 * m31;\n    const tmp13 = m30 * m21;\n    const tmp14 = m10 * m31;\n    const tmp15 = m30 * m11;\n    const tmp16 = m10 * m21;\n    const tmp17 = m20 * m11;\n    const tmp18 = m00 * m31;\n    const tmp19 = m30 * m01;\n    const tmp20 = m00 * m21;\n    const tmp21 = m20 * m01;\n    const tmp22 = m00 * m11;\n    const tmp23 = m10 * m01;\n    const t0 = (tmp0 * m11 + tmp3 * m21 + tmp4 * m31) -\n        (tmp1 * m11 + tmp2 * m21 + tmp5 * m31);\n    const t1 = (tmp1 * m01 + tmp6 * m21 + tmp9 * m31) -\n        (tmp0 * m01 + tmp7 * m21 + tmp8 * m31);\n    const t2 = (tmp2 * m01 + tmp7 * m11 + tmp10 * m31) -\n        (tmp3 * m01 + tmp6 * m11 + tmp11 * m31);\n    const t3 = (tmp5 * m01 + tmp8 * m11 + tmp11 * m21) -\n        (tmp4 * m01 + tmp9 * m11 + tmp10 * m21);\n    const d = 1 / (m00 * t0 + m10 * t1 + m20 * t2 + m30 * t3);\n    dst[0] = d * t0;\n    dst[1] = d * t1;\n    dst[2] = d * t2;\n    dst[3] = d * t3;\n    dst[4] = d * ((tmp1 * m10 + tmp2 * m20 + tmp5 * m30) -\n        (tmp0 * m10 + tmp3 * m20 + tmp4 * m30));\n    dst[5] = d * ((tmp0 * m00 + tmp7 * m20 + tmp8 * m30) -\n        (tmp1 * m00 + tmp6 * m20 + tmp9 * m30));\n    dst[6] = d * ((tmp3 * m00 + tmp6 * m10 + tmp11 * m30) -\n        (tmp2 * m00 + tmp7 * m10 + tmp10 * m30));\n    dst[7] = d * ((tmp4 * m00 + tmp9 * m10 + tmp10 * m20) -\n        (tmp5 * m00 + tmp8 * m10 + tmp11 * m20));\n    dst[8] = d * ((tmp12 * m13 + tmp15 * m23 + tmp16 * m33) -\n        (tmp13 * m13 + tmp14 * m23 + tmp17 * m33));\n    dst[9] = d * ((tmp13 * m03 + tmp18 * m23 + tmp21 * m33) -\n        (tmp12 * m03 + tmp19 * m23 + tmp20 * m33));\n    dst[10] = d * ((tmp14 * m03 + tmp19 * m13 + tmp22 * m33) -\n        (tmp15 * m03 + tmp18 * m13 + tmp23 * m33));\n    dst[11] = d * ((tmp17 * m03 + tmp20 * m13 + tmp23 * m23) -\n        (tmp16 * m03 + tmp21 * m13 + tmp22 * m23));\n    dst[12] = d * ((tmp14 * m22 + tmp17 * m32 + tmp13 * m12) -\n        (tmp16 * m32 + tmp12 * m12 + tmp15 * m22));\n    dst[13] = d * ((tmp20 * m32 + tmp12 * m02 + tmp19 * m22) -\n        (tmp18 * m22 + tmp21 * m32 + tmp13 * m02));\n    dst[14] = d * ((tmp18 * m12 + tmp23 * m32 + tmp15 * m02) -\n        (tmp22 * m32 + tmp14 * m02 + tmp19 * m12));\n    dst[15] = d * ((tmp22 * m22 + tmp16 * m02 + tmp21 * m12) -\n        (tmp20 * m12 + tmp23 * m22 + tmp17 * m02));\n    return dst;\n}\n/**\n * Compute the determinant of a matrix\n * @param m - the matrix\n * @returns the determinant\n */\nfunction determinant(m) {\n    const m00 = m[0 * 4 + 0];\n    const m01 = m[0 * 4 + 1];\n    const m02 = m[0 * 4 + 2];\n    const m03 = m[0 * 4 + 3];\n    const m10 = m[1 * 4 + 0];\n    const m11 = m[1 * 4 + 1];\n    const m12 = m[1 * 4 + 2];\n    const m13 = m[1 * 4 + 3];\n    const m20 = m[2 * 4 + 0];\n    const m21 = m[2 * 4 + 1];\n    const m22 = m[2 * 4 + 2];\n    const m23 = m[2 * 4 + 3];\n    const m30 = m[3 * 4 + 0];\n    const m31 = m[3 * 4 + 1];\n    const m32 = m[3 * 4 + 2];\n    const m33 = m[3 * 4 + 3];\n    const tmp0 = m22 * m33;\n    const tmp1 = m32 * m23;\n    const tmp2 = m12 * m33;\n    const tmp3 = m32 * m13;\n    const tmp4 = m12 * m23;\n    const tmp5 = m22 * m13;\n    const tmp6 = m02 * m33;\n    const tmp7 = m32 * m03;\n    const tmp8 = m02 * m23;\n    const tmp9 = m22 * m03;\n    const tmp10 = m02 * m13;\n    const tmp11 = m12 * m03;\n    const t0 = (tmp0 * m11 + tmp3 * m21 + tmp4 * m31) -\n        (tmp1 * m11 + tmp2 * m21 + tmp5 * m31);\n    const t1 = (tmp1 * m01 + tmp6 * m21 + tmp9 * m31) -\n        (tmp0 * m01 + tmp7 * m21 + tmp8 * m31);\n    const t2 = (tmp2 * m01 + tmp7 * m11 + tmp10 * m31) -\n        (tmp3 * m01 + tmp6 * m11 + tmp11 * m31);\n    const t3 = (tmp5 * m01 + tmp8 * m11 + tmp11 * m21) -\n        (tmp4 * m01 + tmp9 * m11 + tmp10 * m21);\n    return m00 * t0 + m10 * t1 + m20 * t2 + m30 * t3;\n}\n/**\n * Computes the inverse of a 4-by-4 matrix. (same as inverse)\n * @param m - The matrix.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The inverse of m.\n */\nconst invert$1 = inverse$2;\n/**\n * Multiplies two 4-by-4 matrices with a on the left and b on the right\n * @param a - The matrix on the left.\n * @param b - The matrix on the right.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The matrix product of a and b.\n */\nfunction multiply$2(a, b, dst) {\n    dst = dst || new MatType(16);\n    const a00 = a[0];\n    const a01 = a[1];\n    const a02 = a[2];\n    const a03 = a[3];\n    const a10 = a[4 + 0];\n    const a11 = a[4 + 1];\n    const a12 = a[4 + 2];\n    const a13 = a[4 + 3];\n    const a20 = a[8 + 0];\n    const a21 = a[8 + 1];\n    const a22 = a[8 + 2];\n    const a23 = a[8 + 3];\n    const a30 = a[12 + 0];\n    const a31 = a[12 + 1];\n    const a32 = a[12 + 2];\n    const a33 = a[12 + 3];\n    const b00 = b[0];\n    const b01 = b[1];\n    const b02 = b[2];\n    const b03 = b[3];\n    const b10 = b[4 + 0];\n    const b11 = b[4 + 1];\n    const b12 = b[4 + 2];\n    const b13 = b[4 + 3];\n    const b20 = b[8 + 0];\n    const b21 = b[8 + 1];\n    const b22 = b[8 + 2];\n    const b23 = b[8 + 3];\n    const b30 = b[12 + 0];\n    const b31 = b[12 + 1];\n    const b32 = b[12 + 2];\n    const b33 = b[12 + 3];\n    dst[0] = a00 * b00 + a10 * b01 + a20 * b02 + a30 * b03;\n    dst[1] = a01 * b00 + a11 * b01 + a21 * b02 + a31 * b03;\n    dst[2] = a02 * b00 + a12 * b01 + a22 * b02 + a32 * b03;\n    dst[3] = a03 * b00 + a13 * b01 + a23 * b02 + a33 * b03;\n    dst[4] = a00 * b10 + a10 * b11 + a20 * b12 + a30 * b13;\n    dst[5] = a01 * b10 + a11 * b11 + a21 * b12 + a31 * b13;\n    dst[6] = a02 * b10 + a12 * b11 + a22 * b12 + a32 * b13;\n    dst[7] = a03 * b10 + a13 * b11 + a23 * b12 + a33 * b13;\n    dst[8] = a00 * b20 + a10 * b21 + a20 * b22 + a30 * b23;\n    dst[9] = a01 * b20 + a11 * b21 + a21 * b22 + a31 * b23;\n    dst[10] = a02 * b20 + a12 * b21 + a22 * b22 + a32 * b23;\n    dst[11] = a03 * b20 + a13 * b21 + a23 * b22 + a33 * b23;\n    dst[12] = a00 * b30 + a10 * b31 + a20 * b32 + a30 * b33;\n    dst[13] = a01 * b30 + a11 * b31 + a21 * b32 + a31 * b33;\n    dst[14] = a02 * b30 + a12 * b31 + a22 * b32 + a32 * b33;\n    dst[15] = a03 * b30 + a13 * b31 + a23 * b32 + a33 * b33;\n    return dst;\n}\n/**\n * Multiplies two 4-by-4 matrices with a on the left and b on the right (same as multiply)\n * @param a - The matrix on the left.\n * @param b - The matrix on the right.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The matrix product of a and b.\n */\nconst mul$2 = multiply$2;\n/**\n * Sets the translation component of a 4-by-4 matrix to the given\n * vector.\n * @param a - The matrix.\n * @param v - The vector.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The matrix with translation set.\n */\nfunction setTranslation(a, v, dst) {\n    dst = dst || identity$1();\n    if (a !== dst) {\n        dst[0] = a[0];\n        dst[1] = a[1];\n        dst[2] = a[2];\n        dst[3] = a[3];\n        dst[4] = a[4];\n        dst[5] = a[5];\n        dst[6] = a[6];\n        dst[7] = a[7];\n        dst[8] = a[8];\n        dst[9] = a[9];\n        dst[10] = a[10];\n        dst[11] = a[11];\n    }\n    dst[12] = v[0];\n    dst[13] = v[1];\n    dst[14] = v[2];\n    dst[15] = 1;\n    return dst;\n}\n/**\n * Returns the translation component of a 4-by-4 matrix as a vector with 3\n * entries.\n * @param m - The matrix.\n * @param dst - vector to hold result. If not passed a new one is created.\n * @returns The translation component of m.\n */\nfunction getTranslation(m, dst) {\n    dst = dst || create$3();\n    dst[0] = m[12];\n    dst[1] = m[13];\n    dst[2] = m[14];\n    return dst;\n}\n/**\n * Returns an axis of a 4x4 matrix as a vector with 3 entries\n * @param m - The matrix.\n * @param axis - The axis 0 = x, 1 = y, 2 = z;\n * @returns The axis component of m.\n */\nfunction getAxis(m, axis, dst) {\n    dst = dst || create$3();\n    const off = axis * 4;\n    dst[0] = m[off + 0];\n    dst[1] = m[off + 1];\n    dst[2] = m[off + 2];\n    return dst;\n}\n/**\n * Sets an axis of a 4x4 matrix as a vector with 3 entries\n * @param m - The matrix.\n * @param v - the axis vector\n * @param axis - The axis  0 = x, 1 = y, 2 = z;\n * @param dst - The matrix to set. If not passed a new one is created.\n * @returns The matrix with axis set.\n */\nfunction setAxis(a, v, axis, dst) {\n    if (dst !== a) {\n        dst = copy$2(a, dst);\n    }\n    const off = axis * 4;\n    dst[off + 0] = v[0];\n    dst[off + 1] = v[1];\n    dst[off + 2] = v[2];\n    return dst;\n}\n/**\n * Returns the scaling component of the matrix\n * @param m - The Matrix\n * @param dst - The vector to set. If not passed a new one is created.\n */\nfunction getScaling(m, dst) {\n    dst = dst || create$3();\n    const xx = m[0];\n    const xy = m[1];\n    const xz = m[2];\n    const yx = m[4];\n    const yy = m[5];\n    const yz = m[6];\n    const zx = m[8];\n    const zy = m[9];\n    const zz = m[10];\n    dst[0] = Math.sqrt(xx * xx + xy * xy + xz * xz);\n    dst[1] = Math.sqrt(yx * yx + yy * yy + yz * yz);\n    dst[2] = Math.sqrt(zx * zx + zy * zy + zz * zz);\n    return dst;\n}\n/**\n * Computes a 4-by-4 perspective transformation matrix given the angular height\n * of the frustum, the aspect ratio, and the near and far clipping planes.  The\n * arguments define a frustum extending in the negative z direction.  The given\n * angle is the vertical angle of the frustum, and the horizontal angle is\n * determined to produce the given aspect ratio.  The arguments near and far are\n * the distances to the near and far clipping planes.  Note that near and far\n * are not z coordinates, but rather they are distances along the negative\n * z-axis.  The matrix generated sends the viewing frustum to the unit box.\n * We assume a unit box extending from -1 to 1 in the x and y dimensions and\n * from 0 to 1 in the z dimension.\n *\n * Note: If you pass `Infinity` for zFar then it will produce a projection matrix\n * returns -Infinity for Z when transforming coordinates with Z <= 0 and +Infinity for Z\n * otherwise.\n *\n * @param fieldOfViewYInRadians - The camera angle from top to bottom (in radians).\n * @param aspect - The aspect ratio width / height.\n * @param zNear - The depth (negative z coordinate)\n *     of the near clipping plane.\n * @param zFar - The depth (negative z coordinate)\n *     of the far clipping plane.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The perspective matrix.\n */\nfunction perspective(fieldOfViewYInRadians, aspect, zNear, zFar, dst) {\n    dst = dst || new MatType(16);\n    const f = Math.tan(Math.PI * 0.5 - 0.5 * fieldOfViewYInRadians);\n    dst[0] = f / aspect;\n    dst[1] = 0;\n    dst[2] = 0;\n    dst[3] = 0;\n    dst[4] = 0;\n    dst[5] = f;\n    dst[6] = 0;\n    dst[7] = 0;\n    dst[8] = 0;\n    dst[9] = 0;\n    dst[11] = -1;\n    dst[12] = 0;\n    dst[13] = 0;\n    dst[15] = 0;\n    if (zFar === Infinity) {\n        dst[10] = -1;\n        dst[14] = -zNear;\n    }\n    else {\n        const rangeInv = 1 / (zNear - zFar);\n        dst[10] = zFar * rangeInv;\n        dst[14] = zFar * zNear * rangeInv;\n    }\n    return dst;\n}\n/**\n * Computes a 4-by-4 orthogonal transformation matrix that transforms from\n * the given the left, right, bottom, and top dimensions to -1 +1 in x, and y\n * and 0 to +1 in z.\n * @param left - Left side of the near clipping plane viewport.\n * @param right - Right side of the near clipping plane viewport.\n * @param bottom - Bottom of the near clipping plane viewport.\n * @param top - Top of the near clipping plane viewport.\n * @param near - The depth (negative z coordinate)\n *     of the near clipping plane.\n * @param far - The depth (negative z coordinate)\n *     of the far clipping plane.\n * @param dst - Output matrix. If not passed a new one is created.\n * @returns The orthographic projection matrix.\n */\nfunction ortho(left, right, bottom, top, near, far, dst) {\n    dst = dst || new MatType(16);\n    dst[0] = 2 / (right - left);\n    dst[1] = 0;\n    dst[2] = 0;\n    dst[3] = 0;\n    dst[4] = 0;\n    dst[5] = 2 / (top - bottom);\n    dst[6] = 0;\n    dst[7] = 0;\n    dst[8] = 0;\n    dst[9] = 0;\n    dst[10] = 1 / (near - far);\n    dst[11] = 0;\n    dst[12] = (right + left) / (left - right);\n    dst[13] = (top + bottom) / (bottom - top);\n    dst[14] = near / (near - far);\n    dst[15] = 1;\n    return dst;\n}\n/**\n * Computes a 4-by-4 perspective transformation matrix given the left, right,\n * top, bottom, near and far clipping planes. The arguments define a frustum\n * extending in the negative z direction. The arguments near and far are the\n * distances to the near and far clipping planes. Note that near and far are not\n * z coordinates, but rather they are distances along the negative z-axis. The\n * matrix generated sends the viewing frustum to the unit box. We assume a unit\n * box extending from -1 to 1 in the x and y dimensions and from 0 to 1 in the z\n * dimension.\n * @param left - The x coordinate of the left plane of the box.\n * @param right - The x coordinate of the right plane of the box.\n * @param bottom - The y coordinate of the bottom plane of the box.\n * @param top - The y coordinate of the right plane of the box.\n * @param near - The negative z coordinate of the near plane of the box.\n * @param far - The negative z coordinate of the far plane of the box.\n * @param dst - Output matrix. If not passed a new one is created.\n * @returns The perspective projection matrix.\n */\nfunction frustum(left, right, bottom, top, near, far, dst) {\n    dst = dst || new MatType(16);\n    const dx = (right - left);\n    const dy = (top - bottom);\n    const dz = (near - far);\n    dst[0] = 2 * near / dx;\n    dst[1] = 0;\n    dst[2] = 0;\n    dst[3] = 0;\n    dst[4] = 0;\n    dst[5] = 2 * near / dy;\n    dst[6] = 0;\n    dst[7] = 0;\n    dst[8] = (left + right) / dx;\n    dst[9] = (top + bottom) / dy;\n    dst[10] = far / dz;\n    dst[11] = -1;\n    dst[12] = 0;\n    dst[13] = 0;\n    dst[14] = near * far / dz;\n    dst[15] = 0;\n    return dst;\n}\nlet xAxis;\nlet yAxis;\nlet zAxis;\n/**\n * Computes a 4-by-4 aim transformation.\n *\n * This is a matrix which positions an object aiming down positive Z.\n * toward the target.\n *\n * Note: this is **NOT** the inverse of lookAt as lookAt looks at negative Z.\n *\n * @param position - The position of the object.\n * @param target - The position meant to be aimed at.\n * @param up - A vector pointing up.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The aim matrix.\n */\nfunction aim(position, target, up, dst) {\n    dst = dst || new MatType(16);\n    xAxis = xAxis || create$3();\n    yAxis = yAxis || create$3();\n    zAxis = zAxis || create$3();\n    normalize$2(subtract$2(target, position, zAxis), zAxis);\n    normalize$2(cross(up, zAxis, xAxis), xAxis);\n    normalize$2(cross(zAxis, xAxis, yAxis), yAxis);\n    dst[0] = xAxis[0];\n    dst[1] = xAxis[1];\n    dst[2] = xAxis[2];\n    dst[3] = 0;\n    dst[4] = yAxis[0];\n    dst[5] = yAxis[1];\n    dst[6] = yAxis[2];\n    dst[7] = 0;\n    dst[8] = zAxis[0];\n    dst[9] = zAxis[1];\n    dst[10] = zAxis[2];\n    dst[11] = 0;\n    dst[12] = position[0];\n    dst[13] = position[1];\n    dst[14] = position[2];\n    dst[15] = 1;\n    return dst;\n}\n/**\n * Computes a 4-by-4 camera aim transformation.\n *\n * This is a matrix which positions an object aiming down negative Z.\n * toward the target.\n *\n * Note: this is the inverse of `lookAt`\n *\n * @param eye - The position of the object.\n * @param target - The position meant to be aimed at.\n * @param up - A vector pointing up.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The aim matrix.\n */\nfunction cameraAim(eye, target, up, dst) {\n    dst = dst || new MatType(16);\n    xAxis = xAxis || create$3();\n    yAxis = yAxis || create$3();\n    zAxis = zAxis || create$3();\n    normalize$2(subtract$2(eye, target, zAxis), zAxis);\n    normalize$2(cross(up, zAxis, xAxis), xAxis);\n    normalize$2(cross(zAxis, xAxis, yAxis), yAxis);\n    dst[0] = xAxis[0];\n    dst[1] = xAxis[1];\n    dst[2] = xAxis[2];\n    dst[3] = 0;\n    dst[4] = yAxis[0];\n    dst[5] = yAxis[1];\n    dst[6] = yAxis[2];\n    dst[7] = 0;\n    dst[8] = zAxis[0];\n    dst[9] = zAxis[1];\n    dst[10] = zAxis[2];\n    dst[11] = 0;\n    dst[12] = eye[0];\n    dst[13] = eye[1];\n    dst[14] = eye[2];\n    dst[15] = 1;\n    return dst;\n}\n/**\n * Computes a 4-by-4 view transformation.\n *\n * This is a view matrix which transforms all other objects\n * to be in the space of the view defined by the parameters.\n *\n * @param eye - The position of the object.\n * @param target - The position meant to be aimed at.\n * @param up - A vector pointing up.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The look-at matrix.\n */\nfunction lookAt(eye, target, up, dst) {\n    dst = dst || new MatType(16);\n    xAxis = xAxis || create$3();\n    yAxis = yAxis || create$3();\n    zAxis = zAxis || create$3();\n    normalize$2(subtract$2(eye, target, zAxis), zAxis);\n    normalize$2(cross(up, zAxis, xAxis), xAxis);\n    normalize$2(cross(zAxis, xAxis, yAxis), yAxis);\n    dst[0] = xAxis[0];\n    dst[1] = yAxis[0];\n    dst[2] = zAxis[0];\n    dst[3] = 0;\n    dst[4] = xAxis[1];\n    dst[5] = yAxis[1];\n    dst[6] = zAxis[1];\n    dst[7] = 0;\n    dst[8] = xAxis[2];\n    dst[9] = yAxis[2];\n    dst[10] = zAxis[2];\n    dst[11] = 0;\n    dst[12] = -(xAxis[0] * eye[0] + xAxis[1] * eye[1] + xAxis[2] * eye[2]);\n    dst[13] = -(yAxis[0] * eye[0] + yAxis[1] * eye[1] + yAxis[2] * eye[2]);\n    dst[14] = -(zAxis[0] * eye[0] + zAxis[1] * eye[1] + zAxis[2] * eye[2]);\n    dst[15] = 1;\n    return dst;\n}\n/**\n * Creates a 4-by-4 matrix which translates by the given vector v.\n * @param v - The vector by\n *     which to translate.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The translation matrix.\n */\nfunction translation(v, dst) {\n    dst = dst || new MatType(16);\n    dst[0] = 1;\n    dst[1] = 0;\n    dst[2] = 0;\n    dst[3] = 0;\n    dst[4] = 0;\n    dst[5] = 1;\n    dst[6] = 0;\n    dst[7] = 0;\n    dst[8] = 0;\n    dst[9] = 0;\n    dst[10] = 1;\n    dst[11] = 0;\n    dst[12] = v[0];\n    dst[13] = v[1];\n    dst[14] = v[2];\n    dst[15] = 1;\n    return dst;\n}\n/**\n * Translates the given 4-by-4 matrix by the given vector v.\n * @param m - The matrix.\n * @param v - The vector by\n *     which to translate.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The translated matrix.\n */\nfunction translate(m, v, dst) {\n    dst = dst || new MatType(16);\n    const v0 = v[0];\n    const v1 = v[1];\n    const v2 = v[2];\n    const m00 = m[0];\n    const m01 = m[1];\n    const m02 = m[2];\n    const m03 = m[3];\n    const m10 = m[1 * 4 + 0];\n    const m11 = m[1 * 4 + 1];\n    const m12 = m[1 * 4 + 2];\n    const m13 = m[1 * 4 + 3];\n    const m20 = m[2 * 4 + 0];\n    const m21 = m[2 * 4 + 1];\n    const m22 = m[2 * 4 + 2];\n    const m23 = m[2 * 4 + 3];\n    const m30 = m[3 * 4 + 0];\n    const m31 = m[3 * 4 + 1];\n    const m32 = m[3 * 4 + 2];\n    const m33 = m[3 * 4 + 3];\n    if (m !== dst) {\n        dst[0] = m00;\n        dst[1] = m01;\n        dst[2] = m02;\n        dst[3] = m03;\n        dst[4] = m10;\n        dst[5] = m11;\n        dst[6] = m12;\n        dst[7] = m13;\n        dst[8] = m20;\n        dst[9] = m21;\n        dst[10] = m22;\n        dst[11] = m23;\n    }\n    dst[12] = m00 * v0 + m10 * v1 + m20 * v2 + m30;\n    dst[13] = m01 * v0 + m11 * v1 + m21 * v2 + m31;\n    dst[14] = m02 * v0 + m12 * v1 + m22 * v2 + m32;\n    dst[15] = m03 * v0 + m13 * v1 + m23 * v2 + m33;\n    return dst;\n}\n/**\n * Creates a 4-by-4 matrix which rotates around the x-axis by the given angle.\n * @param angleInRadians - The angle by which to rotate (in radians).\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The rotation matrix.\n */\nfunction rotationX(angleInRadians, dst) {\n    dst = dst || new MatType(16);\n    const c = Math.cos(angleInRadians);\n    const s = Math.sin(angleInRadians);\n    dst[0] = 1;\n    dst[1] = 0;\n    dst[2] = 0;\n    dst[3] = 0;\n    dst[4] = 0;\n    dst[5] = c;\n    dst[6] = s;\n    dst[7] = 0;\n    dst[8] = 0;\n    dst[9] = -s;\n    dst[10] = c;\n    dst[11] = 0;\n    dst[12] = 0;\n    dst[13] = 0;\n    dst[14] = 0;\n    dst[15] = 1;\n    return dst;\n}\n/**\n * Rotates the given 4-by-4 matrix around the x-axis by the given\n * angle.\n * @param m - The matrix.\n * @param angleInRadians - The angle by which to rotate (in radians).\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The rotated matrix.\n */\nfunction rotateX$1(m, angleInRadians, dst) {\n    dst = dst || new MatType(16);\n    const m10 = m[4];\n    const m11 = m[5];\n    const m12 = m[6];\n    const m13 = m[7];\n    const m20 = m[8];\n    const m21 = m[9];\n    const m22 = m[10];\n    const m23 = m[11];\n    const c = Math.cos(angleInRadians);\n    const s = Math.sin(angleInRadians);\n    dst[4] = c * m10 + s * m20;\n    dst[5] = c * m11 + s * m21;\n    dst[6] = c * m12 + s * m22;\n    dst[7] = c * m13 + s * m23;\n    dst[8] = c * m20 - s * m10;\n    dst[9] = c * m21 - s * m11;\n    dst[10] = c * m22 - s * m12;\n    dst[11] = c * m23 - s * m13;\n    if (m !== dst) {\n        dst[0] = m[0];\n        dst[1] = m[1];\n        dst[2] = m[2];\n        dst[3] = m[3];\n        dst[12] = m[12];\n        dst[13] = m[13];\n        dst[14] = m[14];\n        dst[15] = m[15];\n    }\n    return dst;\n}\n/**\n * Creates a 4-by-4 matrix which rotates around the y-axis by the given angle.\n * @param angleInRadians - The angle by which to rotate (in radians).\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The rotation matrix.\n */\nfunction rotationY(angleInRadians, dst) {\n    dst = dst || new MatType(16);\n    const c = Math.cos(angleInRadians);\n    const s = Math.sin(angleInRadians);\n    dst[0] = c;\n    dst[1] = 0;\n    dst[2] = -s;\n    dst[3] = 0;\n    dst[4] = 0;\n    dst[5] = 1;\n    dst[6] = 0;\n    dst[7] = 0;\n    dst[8] = s;\n    dst[9] = 0;\n    dst[10] = c;\n    dst[11] = 0;\n    dst[12] = 0;\n    dst[13] = 0;\n    dst[14] = 0;\n    dst[15] = 1;\n    return dst;\n}\n/**\n * Rotates the given 4-by-4 matrix around the y-axis by the given\n * angle.\n * @param m - The matrix.\n * @param angleInRadians - The angle by which to rotate (in radians).\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The rotated matrix.\n */\nfunction rotateY$1(m, angleInRadians, dst) {\n    dst = dst || new MatType(16);\n    const m00 = m[0 * 4 + 0];\n    const m01 = m[0 * 4 + 1];\n    const m02 = m[0 * 4 + 2];\n    const m03 = m[0 * 4 + 3];\n    const m20 = m[2 * 4 + 0];\n    const m21 = m[2 * 4 + 1];\n    const m22 = m[2 * 4 + 2];\n    const m23 = m[2 * 4 + 3];\n    const c = Math.cos(angleInRadians);\n    const s = Math.sin(angleInRadians);\n    dst[0] = c * m00 - s * m20;\n    dst[1] = c * m01 - s * m21;\n    dst[2] = c * m02 - s * m22;\n    dst[3] = c * m03 - s * m23;\n    dst[8] = c * m20 + s * m00;\n    dst[9] = c * m21 + s * m01;\n    dst[10] = c * m22 + s * m02;\n    dst[11] = c * m23 + s * m03;\n    if (m !== dst) {\n        dst[4] = m[4];\n        dst[5] = m[5];\n        dst[6] = m[6];\n        dst[7] = m[7];\n        dst[12] = m[12];\n        dst[13] = m[13];\n        dst[14] = m[14];\n        dst[15] = m[15];\n    }\n    return dst;\n}\n/**\n * Creates a 4-by-4 matrix which rotates around the z-axis by the given angle.\n * @param angleInRadians - The angle by which to rotate (in radians).\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The rotation matrix.\n */\nfunction rotationZ(angleInRadians, dst) {\n    dst = dst || new MatType(16);\n    const c = Math.cos(angleInRadians);\n    const s = Math.sin(angleInRadians);\n    dst[0] = c;\n    dst[1] = s;\n    dst[2] = 0;\n    dst[3] = 0;\n    dst[4] = -s;\n    dst[5] = c;\n    dst[6] = 0;\n    dst[7] = 0;\n    dst[8] = 0;\n    dst[9] = 0;\n    dst[10] = 1;\n    dst[11] = 0;\n    dst[12] = 0;\n    dst[13] = 0;\n    dst[14] = 0;\n    dst[15] = 1;\n    return dst;\n}\n/**\n * Rotates the given 4-by-4 matrix around the z-axis by the given\n * angle.\n * @param m - The matrix.\n * @param angleInRadians - The angle by which to rotate (in radians).\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The rotated matrix.\n */\nfunction rotateZ$1(m, angleInRadians, dst) {\n    dst = dst || new MatType(16);\n    const m00 = m[0 * 4 + 0];\n    const m01 = m[0 * 4 + 1];\n    const m02 = m[0 * 4 + 2];\n    const m03 = m[0 * 4 + 3];\n    const m10 = m[1 * 4 + 0];\n    const m11 = m[1 * 4 + 1];\n    const m12 = m[1 * 4 + 2];\n    const m13 = m[1 * 4 + 3];\n    const c = Math.cos(angleInRadians);\n    const s = Math.sin(angleInRadians);\n    dst[0] = c * m00 + s * m10;\n    dst[1] = c * m01 + s * m11;\n    dst[2] = c * m02 + s * m12;\n    dst[3] = c * m03 + s * m13;\n    dst[4] = c * m10 - s * m00;\n    dst[5] = c * m11 - s * m01;\n    dst[6] = c * m12 - s * m02;\n    dst[7] = c * m13 - s * m03;\n    if (m !== dst) {\n        dst[8] = m[8];\n        dst[9] = m[9];\n        dst[10] = m[10];\n        dst[11] = m[11];\n        dst[12] = m[12];\n        dst[13] = m[13];\n        dst[14] = m[14];\n        dst[15] = m[15];\n    }\n    return dst;\n}\n/**\n * Creates a 4-by-4 matrix which rotates around the given axis by the given\n * angle.\n * @param axis - The axis\n *     about which to rotate.\n * @param angleInRadians - The angle by which to rotate (in radians).\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns A matrix which rotates angle radians\n *     around the axis.\n */\nfunction axisRotation(axis, angleInRadians, dst) {\n    dst = dst || new MatType(16);\n    let x = axis[0];\n    let y = axis[1];\n    let z = axis[2];\n    const n = Math.sqrt(x * x + y * y + z * z);\n    x /= n;\n    y /= n;\n    z /= n;\n    const xx = x * x;\n    const yy = y * y;\n    const zz = z * z;\n    const c = Math.cos(angleInRadians);\n    const s = Math.sin(angleInRadians);\n    const oneMinusCosine = 1 - c;\n    dst[0] = xx + (1 - xx) * c;\n    dst[1] = x * y * oneMinusCosine + z * s;\n    dst[2] = x * z * oneMinusCosine - y * s;\n    dst[3] = 0;\n    dst[4] = x * y * oneMinusCosine - z * s;\n    dst[5] = yy + (1 - yy) * c;\n    dst[6] = y * z * oneMinusCosine + x * s;\n    dst[7] = 0;\n    dst[8] = x * z * oneMinusCosine + y * s;\n    dst[9] = y * z * oneMinusCosine - x * s;\n    dst[10] = zz + (1 - zz) * c;\n    dst[11] = 0;\n    dst[12] = 0;\n    dst[13] = 0;\n    dst[14] = 0;\n    dst[15] = 1;\n    return dst;\n}\n/**\n * Creates a 4-by-4 matrix which rotates around the given axis by the given\n * angle. (same as axisRotation)\n * @param axis - The axis\n *     about which to rotate.\n * @param angleInRadians - The angle by which to rotate (in radians).\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns A matrix which rotates angle radians\n *     around the axis.\n */\nconst rotation = axisRotation;\n/**\n * Rotates the given 4-by-4 matrix around the given axis by the\n * given angle.\n * @param m - The matrix.\n * @param axis - The axis\n *     about which to rotate.\n * @param angleInRadians - The angle by which to rotate (in radians).\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The rotated matrix.\n */\nfunction axisRotate(m, axis, angleInRadians, dst) {\n    dst = dst || new MatType(16);\n    let x = axis[0];\n    let y = axis[1];\n    let z = axis[2];\n    const n = Math.sqrt(x * x + y * y + z * z);\n    x /= n;\n    y /= n;\n    z /= n;\n    const xx = x * x;\n    const yy = y * y;\n    const zz = z * z;\n    const c = Math.cos(angleInRadians);\n    const s = Math.sin(angleInRadians);\n    const oneMinusCosine = 1 - c;\n    const r00 = xx + (1 - xx) * c;\n    const r01 = x * y * oneMinusCosine + z * s;\n    const r02 = x * z * oneMinusCosine - y * s;\n    const r10 = x * y * oneMinusCosine - z * s;\n    const r11 = yy + (1 - yy) * c;\n    const r12 = y * z * oneMinusCosine + x * s;\n    const r20 = x * z * oneMinusCosine + y * s;\n    const r21 = y * z * oneMinusCosine - x * s;\n    const r22 = zz + (1 - zz) * c;\n    const m00 = m[0];\n    const m01 = m[1];\n    const m02 = m[2];\n    const m03 = m[3];\n    const m10 = m[4];\n    const m11 = m[5];\n    const m12 = m[6];\n    const m13 = m[7];\n    const m20 = m[8];\n    const m21 = m[9];\n    const m22 = m[10];\n    const m23 = m[11];\n    dst[0] = r00 * m00 + r01 * m10 + r02 * m20;\n    dst[1] = r00 * m01 + r01 * m11 + r02 * m21;\n    dst[2] = r00 * m02 + r01 * m12 + r02 * m22;\n    dst[3] = r00 * m03 + r01 * m13 + r02 * m23;\n    dst[4] = r10 * m00 + r11 * m10 + r12 * m20;\n    dst[5] = r10 * m01 + r11 * m11 + r12 * m21;\n    dst[6] = r10 * m02 + r11 * m12 + r12 * m22;\n    dst[7] = r10 * m03 + r11 * m13 + r12 * m23;\n    dst[8] = r20 * m00 + r21 * m10 + r22 * m20;\n    dst[9] = r20 * m01 + r21 * m11 + r22 * m21;\n    dst[10] = r20 * m02 + r21 * m12 + r22 * m22;\n    dst[11] = r20 * m03 + r21 * m13 + r22 * m23;\n    if (m !== dst) {\n        dst[12] = m[12];\n        dst[13] = m[13];\n        dst[14] = m[14];\n        dst[15] = m[15];\n    }\n    return dst;\n}\n/**\n * Rotates the given 4-by-4 matrix around the given axis by the\n * given angle. (same as rotate)\n * @param m - The matrix.\n * @param axis - The axis\n *     about which to rotate.\n * @param angleInRadians - The angle by which to rotate (in radians).\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The rotated matrix.\n */\nconst rotate = axisRotate;\n/**\n * Creates a 4-by-4 matrix which scales in each dimension by an amount given by\n * the corresponding entry in the given vector; assumes the vector has three\n * entries.\n * @param v - A vector of\n *     three entries specifying the factor by which to scale in each dimension.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The scaling matrix.\n */\nfunction scaling(v, dst) {\n    dst = dst || new MatType(16);\n    dst[0] = v[0];\n    dst[1] = 0;\n    dst[2] = 0;\n    dst[3] = 0;\n    dst[4] = 0;\n    dst[5] = v[1];\n    dst[6] = 0;\n    dst[7] = 0;\n    dst[8] = 0;\n    dst[9] = 0;\n    dst[10] = v[2];\n    dst[11] = 0;\n    dst[12] = 0;\n    dst[13] = 0;\n    dst[14] = 0;\n    dst[15] = 1;\n    return dst;\n}\n/**\n * Scales the given 4-by-4 matrix in each dimension by an amount\n * given by the corresponding entry in the given vector; assumes the vector has\n * three entries.\n * @param m - The matrix to be modified.\n * @param v - A vector of three entries specifying the\n *     factor by which to scale in each dimension.\n * @param dst - matrix to hold result. If not passed a new one is created.\n * @returns The scaled matrix.\n */\nfunction scale$2(m, v, dst) {\n    dst = dst || new MatType(16);\n    const v0 = v[0];\n    const v1 = v[1];\n    const v2 = v[2];\n    dst[0] = v0 * m[0 * 4 + 0];\n    dst[1] = v0 * m[0 * 4 + 1];\n    dst[2] = v0 * m[0 * 4 + 2];\n    dst[3] = v0 * m[0 * 4 + 3];\n    dst[4] = v1 * m[1 * 4 + 0];\n    dst[5] = v1 * m[1 * 4 + 1];\n    dst[6] = v1 * m[1 * 4 + 2];\n    dst[7] = v1 * m[1 * 4 + 3];\n    dst[8] = v2 * m[2 * 4 + 0];\n    dst[9] = v2 * m[2 * 4 + 1];\n    dst[10] = v2 * m[2 * 4 + 2];\n    dst[11] = v2 * m[2 * 4 + 3];\n    if (m !== dst) {\n        dst[12] = m[12];\n        dst[13] = m[13];\n        dst[14] = m[14];\n        dst[15] = m[15];\n    }\n    return dst;\n}\n\nvar mat4Impl = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    aim: aim,\n    axisRotate: axisRotate,\n    axisRotation: axisRotation,\n    cameraAim: cameraAim,\n    clone: clone$2,\n    copy: copy$2,\n    create: create$2,\n    determinant: determinant,\n    equals: equals$2,\n    equalsApproximately: equalsApproximately$2,\n    fromMat3: fromMat3,\n    fromQuat: fromQuat,\n    frustum: frustum,\n    getAxis: getAxis,\n    getScaling: getScaling,\n    getTranslation: getTranslation,\n    identity: identity$1,\n    inverse: inverse$2,\n    invert: invert$1,\n    lookAt: lookAt,\n    mul: mul$2,\n    multiply: multiply$2,\n    negate: negate$1,\n    ortho: ortho,\n    perspective: perspective,\n    rotate: rotate,\n    rotateX: rotateX$1,\n    rotateY: rotateY$1,\n    rotateZ: rotateZ$1,\n    rotation: rotation,\n    rotationX: rotationX,\n    rotationY: rotationY,\n    rotationZ: rotationZ,\n    scale: scale$2,\n    scaling: scaling,\n    setAxis: setAxis,\n    setDefaultType: setDefaultType$3,\n    setTranslation: setTranslation,\n    translate: translate,\n    translation: translation,\n    transpose: transpose\n});\n\n/**\n *\n * Quat4 math functions.\n *\n * Almost all functions take an optional `dst` argument. If it is not passed in the\n * functions will create a new `Quat4`. In other words you can do this\n *\n *     const v = quat4.cross(v1, v2);  // Creates a new Quat4 with the cross product of v1 x v2.\n *\n * or\n *\n *     const v = quat4.create();\n *     quat4.cross(v1, v2, v);  // Puts the cross product of v1 x v2 in v\n *\n * The first style is often easier but depending on where it's used it generates garbage where\n * as there is almost never allocation with the second style.\n *\n * It is always safe to pass any vector as the destination. So for example\n *\n *     quat4.cross(v1, v2, v1);  // Puts the cross product of v1 x v2 in v1\n *\n */\nlet QuatType = Float32Array;\n/**\n * Sets the type this library creates for a Quat4\n * @param ctor - the constructor for the type. Either `Float32Array`, `Float64Array`, or `Array`\n * @returns previous constructor for Quat4\n */\nfunction setDefaultType$2(ctor) {\n    const oldType = QuatType;\n    QuatType = ctor;\n    return oldType;\n}\n/**\n * Creates a quat4; may be called with x, y, z to set initial values.\n * @param x - Initial x value.\n * @param y - Initial y value.\n * @param z - Initial z value.\n * @param w - Initial w value.\n * @returns the created vector\n */\nfunction create$1(x, y, z, w) {\n    const dst = new QuatType(4);\n    if (x !== undefined) {\n        dst[0] = x;\n        if (y !== undefined) {\n            dst[1] = y;\n            if (z !== undefined) {\n                dst[2] = z;\n                if (w !== undefined) {\n                    dst[3] = w;\n                }\n            }\n        }\n    }\n    return dst;\n}\n\n/*\n * Copyright 2022 Gregg Tavares\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n/**\n * Creates a Quat; may be called with x, y, z to set initial values. (same as create)\n * @param x - Initial x value.\n * @param y - Initial y value.\n * @param z - Initial z value.\n * @param z - Initial w value.\n * @returns the created vector\n */\nconst fromValues$1 = create$1;\n/**\n * Sets a quaternion from the given angle and  axis,\n * then returns it.\n *\n * @param axis - the axis to rotate around\n * @param angleInRadians - the angle\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns The quaternion that represents the given axis and angle\n **/\nfunction fromAxisAngle(axis, angleInRadians, dst) {\n    dst = dst || new QuatType(4);\n    const halfAngle = angleInRadians * 0.5;\n    const s = Math.sin(halfAngle);\n    dst[0] = s * axis[0];\n    dst[1] = s * axis[1];\n    dst[2] = s * axis[2];\n    dst[3] = Math.cos(halfAngle);\n    return dst;\n}\n/**\n * Gets the rotation axis and angle\n * @param q - quaternion to compute from\n * @param dst - Vec3 to hold result. If not passed in a new one is created.\n * @return angle and axis\n */\nfunction toAxisAngle(q, dst) {\n    dst = dst || create$3(4);\n    const angle = Math.acos(q[3]) * 2;\n    const s = Math.sin(angle * 0.5);\n    if (s > EPSILON) {\n        dst[0] = q[0] / s;\n        dst[1] = q[1] / s;\n        dst[2] = q[2] / s;\n    }\n    else {\n        dst[0] = 1;\n        dst[1] = 0;\n        dst[2] = 0;\n    }\n    return { angle, axis: dst };\n}\n/**\n * Returns the angle in degrees between two rotations a and b.\n * @param a - quaternion a\n * @param b - quaternion b\n * @return angle in radians between the two quaternions\n */\nfunction angle(a, b) {\n    const d = dot$1(a, b);\n    return Math.acos(2 * d * d - 1);\n}\n/**\n * Multiplies two quaternions\n *\n * @param a - the first quaternion\n * @param b - the second quaternion\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns A quaternion that is the result of a * b\n */\nfunction multiply$1(a, b, dst) {\n    dst = dst || new QuatType(4);\n    const ax = a[0];\n    const ay = a[1];\n    const az = a[2];\n    const aw = a[3];\n    const bx = b[0];\n    const by = b[1];\n    const bz = b[2];\n    const bw = b[3];\n    dst[0] = ax * bw + aw * bx + ay * bz - az * by;\n    dst[1] = ay * bw + aw * by + az * bx - ax * bz;\n    dst[2] = az * bw + aw * bz + ax * by - ay * bx;\n    dst[3] = aw * bw - ax * bx - ay * by - az * bz;\n    return dst;\n}\n/**\n * Multiplies two quaternions\n *\n * @param a - the first quaternion\n * @param b - the second quaternion\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns A quaternion that is the result of a * b\n */\nconst mul$1 = multiply$1;\n/**\n * Rotates the given quaternion around the X axis by the given angle.\n * @param q - quaternion to rotate\n * @param angleInRadians - The angle by which to rotate\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns A quaternion that is the result of a * b\n */\nfunction rotateX(q, angleInRadians, dst) {\n    dst = dst || new QuatType(4);\n    const halfAngle = angleInRadians * 0.5;\n    const qx = q[0];\n    const qy = q[1];\n    const qz = q[2];\n    const qw = q[3];\n    const bx = Math.sin(halfAngle);\n    const bw = Math.cos(halfAngle);\n    dst[0] = qx * bw + qw * bx;\n    dst[1] = qy * bw + qz * bx;\n    dst[2] = qz * bw - qy * bx;\n    dst[3] = qw * bw - qx * bx;\n    return dst;\n}\n/**\n * Rotates the given quaternion around the Y axis by the given angle.\n * @param q - quaternion to rotate\n * @param angleInRadians - The angle by which to rotate\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns A quaternion that is the result of a * b\n */\nfunction rotateY(q, angleInRadians, dst) {\n    dst = dst || new QuatType(4);\n    const halfAngle = angleInRadians * 0.5;\n    const qx = q[0];\n    const qy = q[1];\n    const qz = q[2];\n    const qw = q[3];\n    const by = Math.sin(halfAngle);\n    const bw = Math.cos(halfAngle);\n    dst[0] = qx * bw - qz * by;\n    dst[1] = qy * bw + qw * by;\n    dst[2] = qz * bw + qx * by;\n    dst[3] = qw * bw - qy * by;\n    return dst;\n}\n/**\n * Rotates the given quaternion around the Z axis by the given angle.\n * @param q - quaternion to rotate\n * @param angleInRadians - The angle by which to rotate\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns A quaternion that is the result of a * b\n */\nfunction rotateZ(q, angleInRadians, dst) {\n    dst = dst || new QuatType(4);\n    const halfAngle = angleInRadians * 0.5;\n    const qx = q[0];\n    const qy = q[1];\n    const qz = q[2];\n    const qw = q[3];\n    const bz = Math.sin(halfAngle);\n    const bw = Math.cos(halfAngle);\n    dst[0] = qx * bw + qy * bz;\n    dst[1] = qy * bw - qx * bz;\n    dst[2] = qz * bw + qw * bz;\n    dst[3] = qw * bw - qz * bz;\n    return dst;\n}\n/**\n * Spherically linear interpolate between two quaternions\n *\n * @param a - starting value\n * @param b - ending value\n * @param t - value where 0 = a and 1 = b\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns A quaternion that is the result of a * b\n */\nfunction slerp(a, b, t, dst) {\n    dst = dst || new QuatType(4);\n    const ax = a[0];\n    const ay = a[1];\n    const az = a[2];\n    const aw = a[3];\n    let bx = b[0];\n    let by = b[1];\n    let bz = b[2];\n    let bw = b[3];\n    let cosOmega = ax * bx + ay * by + az * bz + aw * bw;\n    if (cosOmega < 0) {\n        cosOmega = -cosOmega;\n        bx = -bx;\n        by = -by;\n        bz = -bz;\n        bw = -bw;\n    }\n    let scale0;\n    let scale1;\n    if (1.0 - cosOmega > EPSILON) {\n        const omega = Math.acos(cosOmega);\n        const sinOmega = Math.sin(omega);\n        scale0 = Math.sin((1 - t) * omega) / sinOmega;\n        scale1 = Math.sin(t * omega) / sinOmega;\n    }\n    else {\n        scale0 = 1.0 - t;\n        scale1 = t;\n    }\n    dst[0] = scale0 * ax + scale1 * bx;\n    dst[1] = scale0 * ay + scale1 * by;\n    dst[2] = scale0 * az + scale1 * bz;\n    dst[3] = scale0 * aw + scale1 * bw;\n    return dst;\n}\n/**\n * Compute the inverse of a quaternion\n *\n * @param q - quaternion to compute the inverse of\n * @returns A quaternion that is the result of a * b\n */\nfunction inverse$1(q, dst) {\n    dst = dst || new QuatType(4);\n    const a0 = q[0];\n    const a1 = q[1];\n    const a2 = q[2];\n    const a3 = q[3];\n    const dot = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3;\n    const invDot = dot ? 1 / dot : 0;\n    dst[0] = -a0 * invDot;\n    dst[1] = -a1 * invDot;\n    dst[2] = -a2 * invDot;\n    dst[3] = a3 * invDot;\n    return dst;\n}\n/**\n * Compute the conjugate of a quaternion\n * For quaternions with a magnitude of 1 (a unit quaternion)\n * this returns the same as the inverse but is faster to calculate.\n *\n * @param q - quaternion to compute the conjugate of.\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns The conjugate of q\n */\nfunction conjugate(q, dst) {\n    dst = dst || new QuatType(4);\n    dst[0] = -q[0];\n    dst[1] = -q[1];\n    dst[2] = -q[2];\n    dst[3] = q[3];\n    return dst;\n}\n/**\n * Creates a quaternion from the given rotation matrix.\n *\n * The created quaternion is not normalized.\n *\n * @param m - rotation matrix\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns the result\n */\nfunction fromMat(m, dst) {\n    dst = dst || new QuatType(4);\n    /*\n    0 1 2\n    3 4 5\n    6 7 8\n  \n    0 1 2\n    4 5 6\n    8 9 10\n     */\n    // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes\n    // article \"Quaternion Calculus and Fast Animation\".\n    const trace = m[0] + m[5] + m[10];\n    if (trace > 0.0) {\n        // |w| > 1/2, may as well choose w > 1/2\n        const root = Math.sqrt(trace + 1); // 2w\n        dst[3] = 0.5 * root;\n        const invRoot = 0.5 / root; // 1/(4w)\n        dst[0] = (m[6] - m[9]) * invRoot;\n        dst[1] = (m[8] - m[2]) * invRoot;\n        dst[2] = (m[1] - m[4]) * invRoot;\n    }\n    else {\n        // |w| <= 1/2\n        let i = 0;\n        if (m[5] > m[0]) {\n            i = 1;\n        }\n        if (m[10] > m[i * 4 + i]) {\n            i = 2;\n        }\n        const j = (i + 1) % 3;\n        const k = (i + 2) % 3;\n        const root = Math.sqrt(m[i * 4 + i] - m[j * 4 + j] - m[k * 4 + k] + 1.0);\n        dst[i] = 0.5 * root;\n        const invRoot = 0.5 / root;\n        dst[3] = (m[j * 4 + k] - m[k * 4 + j]) * invRoot;\n        dst[j] = (m[j * 4 + i] + m[i * 4 + j]) * invRoot;\n        dst[k] = (m[k * 4 + i] + m[i * 4 + k]) * invRoot;\n    }\n    return dst;\n}\n/**\n * Creates a quaternion from the given euler angle x, y, z using the provided intrinsic order for the conversion.\n *\n * @param xAngleInRadians - angle to rotate around X axis in radians.\n * @param yAngleInRadians - angle to rotate around Y axis in radians.\n * @param zAngleInRadians - angle to rotate around Z axis in radians.\n * @param order - order to apply euler angles\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns A quaternion representing the same rotation as the euler angles applied in the given order\n */\nfunction fromEuler(xAngleInRadians, yAngleInRadians, zAngleInRadians, order, dst) {\n    dst = dst || new QuatType(4);\n    const xHalfAngle = xAngleInRadians * 0.5;\n    const yHalfAngle = yAngleInRadians * 0.5;\n    const zHalfAngle = zAngleInRadians * 0.5;\n    const sx = Math.sin(xHalfAngle);\n    const cx = Math.cos(xHalfAngle);\n    const sy = Math.sin(yHalfAngle);\n    const cy = Math.cos(yHalfAngle);\n    const sz = Math.sin(zHalfAngle);\n    const cz = Math.cos(zHalfAngle);\n    switch (order) {\n        case 'xyz':\n            dst[0] = sx * cy * cz + cx * sy * sz;\n            dst[1] = cx * sy * cz - sx * cy * sz;\n            dst[2] = cx * cy * sz + sx * sy * cz;\n            dst[3] = cx * cy * cz - sx * sy * sz;\n            break;\n        case 'xzy':\n            dst[0] = sx * cy * cz - cx * sy * sz;\n            dst[1] = cx * sy * cz - sx * cy * sz;\n            dst[2] = cx * cy * sz + sx * sy * cz;\n            dst[3] = cx * cy * cz + sx * sy * sz;\n            break;\n        case 'yxz':\n            dst[0] = sx * cy * cz + cx * sy * sz;\n            dst[1] = cx * sy * cz - sx * cy * sz;\n            dst[2] = cx * cy * sz - sx * sy * cz;\n            dst[3] = cx * cy * cz + sx * sy * sz;\n            break;\n        case 'yzx':\n            dst[0] = sx * cy * cz + cx * sy * sz;\n            dst[1] = cx * sy * cz + sx * cy * sz;\n            dst[2] = cx * cy * sz - sx * sy * cz;\n            dst[3] = cx * cy * cz - sx * sy * sz;\n            break;\n        case 'zxy':\n            dst[0] = sx * cy * cz - cx * sy * sz;\n            dst[1] = cx * sy * cz + sx * cy * sz;\n            dst[2] = cx * cy * sz + sx * sy * cz;\n            dst[3] = cx * cy * cz - sx * sy * sz;\n            break;\n        case 'zyx':\n            dst[0] = sx * cy * cz - cx * sy * sz;\n            dst[1] = cx * sy * cz + sx * cy * sz;\n            dst[2] = cx * cy * sz - sx * sy * cz;\n            dst[3] = cx * cy * cz + sx * sy * sz;\n            break;\n        default:\n            throw new Error(`Unknown rotation order: ${order}`);\n    }\n    return dst;\n}\n/**\n * Copies a quaternion. (same as clone)\n * @param q - The quaternion.\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns A quaternion that is a copy of q\n */\nfunction copy$1(q, dst) {\n    dst = dst || new QuatType(4);\n    dst[0] = q[0];\n    dst[1] = q[1];\n    dst[2] = q[2];\n    dst[3] = q[3];\n    return dst;\n}\n/**\n * Clones a quaternion. (same as copy)\n * @param q - The quaternion.\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns A copy of q.\n */\nconst clone$1 = copy$1;\n/**\n * Adds two quaternions; assumes a and b have the same dimension.\n * @param a - Operand quaternion.\n * @param b - Operand quaternion.\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns A quaternion that is the sum of a and b.\n */\nfunction add$1(a, b, dst) {\n    dst = dst || new QuatType(4);\n    dst[0] = a[0] + b[0];\n    dst[1] = a[1] + b[1];\n    dst[2] = a[2] + b[2];\n    dst[3] = a[3] + b[3];\n    return dst;\n}\n/**\n * Subtracts two quaternions.\n * @param a - Operand quaternion.\n * @param b - Operand quaternion.\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns A quaternion that is the difference of a and b.\n */\nfunction subtract$1(a, b, dst) {\n    dst = dst || new QuatType(4);\n    dst[0] = a[0] - b[0];\n    dst[1] = a[1] - b[1];\n    dst[2] = a[2] - b[2];\n    dst[3] = a[3] - b[3];\n    return dst;\n}\n/**\n * Subtracts two quaternions.\n * @param a - Operand quaternion.\n * @param b - Operand quaternion.\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns A quaternion that is the difference of a and b.\n */\nconst sub$1 = subtract$1;\n/**\n * Multiplies a quaternion by a scalar.\n * @param v - The quaternion.\n * @param k - The scalar.\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns The scaled quaternion.\n */\nfunction mulScalar$1(v, k, dst) {\n    dst = dst || new QuatType(4);\n    dst[0] = v[0] * k;\n    dst[1] = v[1] * k;\n    dst[2] = v[2] * k;\n    dst[3] = v[3] * k;\n    return dst;\n}\n/**\n * Multiplies a quaternion by a scalar. (same as mulScalar)\n * @param v - The quaternion.\n * @param k - The scalar.\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns The scaled quaternion.\n */\nconst scale$1 = mulScalar$1;\n/**\n * Divides a vector by a scalar.\n * @param v - The vector.\n * @param k - The scalar.\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns The scaled quaternion.\n */\nfunction divScalar$1(v, k, dst) {\n    dst = dst || new QuatType(4);\n    dst[0] = v[0] / k;\n    dst[1] = v[1] / k;\n    dst[2] = v[2] / k;\n    dst[3] = v[3] / k;\n    return dst;\n}\n/**\n * Computes the dot product of two quaternions\n * @param a - Operand quaternion.\n * @param b - Operand quaternion.\n * @returns dot product\n */\nfunction dot$1(a, b) {\n    return (a[0] * b[0]) + (a[1] * b[1]) + (a[2] * b[2]) + (a[3] * b[3]);\n}\n/**\n * Performs linear interpolation on two quaternions.\n * Given quaternions a and b and interpolation coefficient t, returns\n * a + t * (b - a).\n * @param a - Operand quaternion.\n * @param b - Operand quaternion.\n * @param t - Interpolation coefficient.\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns The linear interpolated result.\n */\nfunction lerp$1(a, b, t, dst) {\n    dst = dst || new QuatType(4);\n    dst[0] = a[0] + t * (b[0] - a[0]);\n    dst[1] = a[1] + t * (b[1] - a[1]);\n    dst[2] = a[2] + t * (b[2] - a[2]);\n    dst[3] = a[3] + t * (b[3] - a[3]);\n    return dst;\n}\n/**\n * Computes the length of quaternion\n * @param v - quaternion.\n * @returns length of quaternion.\n */\nfunction length$1(v) {\n    const v0 = v[0];\n    const v1 = v[1];\n    const v2 = v[2];\n    const v3 = v[3];\n    return Math.sqrt(v0 * v0 + v1 * v1 + v2 * v2 + v3 * v3);\n}\n/**\n * Computes the length of quaternion (same as length)\n * @param v - quaternion.\n * @returns length of quaternion.\n */\nconst len$1 = length$1;\n/**\n * Computes the square of the length of quaternion\n * @param v - quaternion.\n * @returns square of the length of quaternion.\n */\nfunction lengthSq$1(v) {\n    const v0 = v[0];\n    const v1 = v[1];\n    const v2 = v[2];\n    const v3 = v[3];\n    return v0 * v0 + v1 * v1 + v2 * v2 + v3 * v3;\n}\n/**\n * Computes the square of the length of quaternion (same as lengthSq)\n * @param v - quaternion.\n * @returns square of the length of quaternion.\n */\nconst lenSq$1 = lengthSq$1;\n/**\n * Divides a quaternion by its Euclidean length and returns the quotient.\n * @param v - The quaternion.\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns The normalized quaternion.\n */\nfunction normalize$1(v, dst) {\n    dst = dst || new QuatType(4);\n    const v0 = v[0];\n    const v1 = v[1];\n    const v2 = v[2];\n    const v3 = v[3];\n    const len = Math.sqrt(v0 * v0 + v1 * v1 + v2 * v2 + v3 * v3);\n    if (len > 0.00001) {\n        dst[0] = v0 / len;\n        dst[1] = v1 / len;\n        dst[2] = v2 / len;\n        dst[3] = v3 / len;\n    }\n    else {\n        dst[0] = 0;\n        dst[1] = 0;\n        dst[2] = 0;\n        dst[3] = 0;\n    }\n    return dst;\n}\n/**\n * Check if 2 quaternions are approximately equal\n * @param a - Operand quaternion.\n * @param b - Operand quaternion.\n * @returns true if quaternions are approximately equal\n */\nfunction equalsApproximately$1(a, b) {\n    return Math.abs(a[0] - b[0]) < EPSILON &&\n        Math.abs(a[1] - b[1]) < EPSILON &&\n        Math.abs(a[2] - b[2]) < EPSILON &&\n        Math.abs(a[3] - b[3]) < EPSILON;\n}\n/**\n * Check if 2 quaternions are exactly equal\n * @param a - Operand quaternion.\n * @param b - Operand quaternion.\n * @returns true if quaternions are exactly equal\n */\nfunction equals$1(a, b) {\n    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];\n}\n/**\n * Creates an identity quaternion\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns an identity quaternion\n */\nfunction identity(dst) {\n    dst = dst || new QuatType(4);\n    dst[0] = 0;\n    dst[1] = 0;\n    dst[2] = 0;\n    dst[3] = 1;\n    return dst;\n}\nlet tempVec3;\nlet xUnitVec3;\nlet yUnitVec3;\n/**\n * Computes a quaternion to represent the shortest rotation from one vector to another.\n *\n * @param aUnit - the start vector\n * @param bUnit - the end vector\n * @param dst - quaternion to hold result. If not passed in a new one is created.\n * @returns the result\n */\nfunction rotationTo(aUnit, bUnit, dst) {\n    dst = dst || new QuatType(4);\n    tempVec3 = tempVec3 || create$3();\n    xUnitVec3 = xUnitVec3 || create$3(1, 0, 0);\n    yUnitVec3 = yUnitVec3 || create$3(0, 1, 0);\n    const dot = dot$2(aUnit, bUnit);\n    if (dot < -0.999999) {\n        cross(xUnitVec3, aUnit, tempVec3);\n        if (len$2(tempVec3) < 0.000001) {\n            cross(yUnitVec3, aUnit, tempVec3);\n        }\n        normalize$2(tempVec3, tempVec3);\n        fromAxisAngle(tempVec3, Math.PI, dst);\n        return dst;\n    }\n    else if (dot > 0.999999) {\n        dst[0] = 0;\n        dst[1] = 0;\n        dst[2] = 0;\n        dst[3] = 1;\n        return dst;\n    }\n    else {\n        cross(aUnit, bUnit, tempVec3);\n        dst[0] = tempVec3[0];\n        dst[1] = tempVec3[1];\n        dst[2] = tempVec3[2];\n        dst[3] = 1 + dot;\n        return normalize$1(dst, dst);\n    }\n}\nlet tempQuat1;\nlet tempQuat2;\n/**\n * Performs a spherical linear interpolation with two control points\n *\n * @param a - the first quaternion\n * @param b - the second quaternion\n * @param c - the third quaternion\n * @param d - the fourth quaternion\n * @param t - Interpolation coefficient 0 to 1\n * @returns result\n */\nfunction sqlerp(a, b, c, d, t, dst) {\n    dst = dst || new QuatType(4);\n    tempQuat1 = tempQuat1 || new QuatType(4);\n    tempQuat2 = tempQuat2 || new QuatType(4);\n    slerp(a, d, t, tempQuat1);\n    slerp(b, c, t, tempQuat2);\n    slerp(tempQuat1, tempQuat2, 2 * t * (1 - t), dst);\n    return dst;\n}\n\nvar quatImpl = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    add: add$1,\n    angle: angle,\n    clone: clone$1,\n    conjugate: conjugate,\n    copy: copy$1,\n    create: create$1,\n    divScalar: divScalar$1,\n    dot: dot$1,\n    equals: equals$1,\n    equalsApproximately: equalsApproximately$1,\n    fromAxisAngle: fromAxisAngle,\n    fromEuler: fromEuler,\n    fromMat: fromMat,\n    fromValues: fromValues$1,\n    identity: identity,\n    inverse: inverse$1,\n    len: len$1,\n    lenSq: lenSq$1,\n    length: length$1,\n    lengthSq: lengthSq$1,\n    lerp: lerp$1,\n    mul: mul$1,\n    mulScalar: mulScalar$1,\n    multiply: multiply$1,\n    normalize: normalize$1,\n    rotateX: rotateX,\n    rotateY: rotateY,\n    rotateZ: rotateZ,\n    rotationTo: rotationTo,\n    scale: scale$1,\n    setDefaultType: setDefaultType$2,\n    slerp: slerp,\n    sqlerp: sqlerp,\n    sub: sub$1,\n    subtract: subtract$1,\n    toAxisAngle: toAxisAngle\n});\n\n/**\n *\n * Vec4 math functions.\n *\n * Almost all functions take an optional `dst` argument. If it is not passed in the\n * functions will create a new `Vec4`. In other words you can do this\n *\n *     const v = vec4.cross(v1, v2);  // Creates a new Vec4 with the cross product of v1 x v2.\n *\n * or\n *\n *     const v = vec4.create();\n *     vec4.cross(v1, v2, v);  // Puts the cross product of v1 x v2 in v\n *\n * The first style is often easier but depending on where it's used it generates garbage where\n * as there is almost never allocation with the second style.\n *\n * It is always safe to pass any vector as the destination. So for example\n *\n *     vec4.cross(v1, v2, v1);  // Puts the cross product of v1 x v2 in v1\n *\n */\nlet VecType = Float32Array;\n/**\n * Sets the type this library creates for a Vec4\n * @param ctor - the constructor for the type. Either `Float32Array`, `Float64Array`, or `Array`\n * @returns previous constructor for Vec4\n */\nfunction setDefaultType$1(ctor) {\n    const oldType = VecType;\n    VecType = ctor;\n    return oldType;\n}\n/**\n * Creates a vec4; may be called with x, y, z to set initial values.\n * @param x - Initial x value.\n * @param y - Initial y value.\n * @param z - Initial z value.\n * @param w - Initial w value.\n * @returns the created vector\n */\nfunction create(x, y, z, w) {\n    const dst = new VecType(4);\n    if (x !== undefined) {\n        dst[0] = x;\n        if (y !== undefined) {\n            dst[1] = y;\n            if (z !== undefined) {\n                dst[2] = z;\n                if (w !== undefined) {\n                    dst[3] = w;\n                }\n            }\n        }\n    }\n    return dst;\n}\n\n/*\n * Copyright 2022 Gregg Tavares\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n/**\n * Creates a vec4; may be called with x, y, z to set initial values. (same as create)\n * @param x - Initial x value.\n * @param y - Initial y value.\n * @param z - Initial z value.\n * @param z - Initial w value.\n * @returns the created vector\n */\nconst fromValues = create;\n/**\n * Applies Math.ceil to each element of vector\n * @param v - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that is the ceil of each element of v.\n */\nfunction ceil(v, dst) {\n    dst = dst || new VecType(4);\n    dst[0] = Math.ceil(v[0]);\n    dst[1] = Math.ceil(v[1]);\n    dst[2] = Math.ceil(v[2]);\n    dst[3] = Math.ceil(v[3]);\n    return dst;\n}\n/**\n * Applies Math.floor to each element of vector\n * @param v - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that is the floor of each element of v.\n */\nfunction floor(v, dst) {\n    dst = dst || new VecType(4);\n    dst[0] = Math.floor(v[0]);\n    dst[1] = Math.floor(v[1]);\n    dst[2] = Math.floor(v[2]);\n    dst[3] = Math.floor(v[3]);\n    return dst;\n}\n/**\n * Applies Math.round to each element of vector\n * @param v - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that is the round of each element of v.\n */\nfunction round(v, dst) {\n    dst = dst || new VecType(4);\n    dst[0] = Math.round(v[0]);\n    dst[1] = Math.round(v[1]);\n    dst[2] = Math.round(v[2]);\n    dst[3] = Math.round(v[3]);\n    return dst;\n}\n/**\n * Clamp each element of vector between min and max\n * @param v - Operand vector.\n * @param max - Min value, default 0\n * @param min - Max value, default 1\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that the clamped value of each element of v.\n */\nfunction clamp(v, min = 0, max = 1, dst) {\n    dst = dst || new VecType(4);\n    dst[0] = Math.min(max, Math.max(min, v[0]));\n    dst[1] = Math.min(max, Math.max(min, v[1]));\n    dst[2] = Math.min(max, Math.max(min, v[2]));\n    dst[3] = Math.min(max, Math.max(min, v[3]));\n    return dst;\n}\n/**\n * Adds two vectors; assumes a and b have the same dimension.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that is the sum of a and b.\n */\nfunction add(a, b, dst) {\n    dst = dst || new VecType(4);\n    dst[0] = a[0] + b[0];\n    dst[1] = a[1] + b[1];\n    dst[2] = a[2] + b[2];\n    dst[3] = a[3] + b[3];\n    return dst;\n}\n/**\n * Adds two vectors, scaling the 2nd; assumes a and b have the same dimension.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param scale - Amount to scale b\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that is the sum of a + b * scale.\n */\nfunction addScaled(a, b, scale, dst) {\n    dst = dst || new VecType(4);\n    dst[0] = a[0] + b[0] * scale;\n    dst[1] = a[1] + b[1] * scale;\n    dst[2] = a[2] + b[2] * scale;\n    dst[3] = a[3] + b[3] * scale;\n    return dst;\n}\n/**\n * Subtracts two vectors.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that is the difference of a and b.\n */\nfunction subtract(a, b, dst) {\n    dst = dst || new VecType(4);\n    dst[0] = a[0] - b[0];\n    dst[1] = a[1] - b[1];\n    dst[2] = a[2] - b[2];\n    dst[3] = a[3] - b[3];\n    return dst;\n}\n/**\n * Subtracts two vectors.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A vector that is the difference of a and b.\n */\nconst sub = subtract;\n/**\n * Check if 2 vectors are approximately equal\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @returns true if vectors are approximately equal\n */\nfunction equalsApproximately(a, b) {\n    return Math.abs(a[0] - b[0]) < EPSILON &&\n        Math.abs(a[1] - b[1]) < EPSILON &&\n        Math.abs(a[2] - b[2]) < EPSILON &&\n        Math.abs(a[3] - b[3]) < EPSILON;\n}\n/**\n * Check if 2 vectors are exactly equal\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @returns true if vectors are exactly equal\n */\nfunction equals(a, b) {\n    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];\n}\n/**\n * Performs linear interpolation on two vectors.\n * Given vectors a and b and interpolation coefficient t, returns\n * a + t * (b - a).\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param t - Interpolation coefficient.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The linear interpolated result.\n */\nfunction lerp(a, b, t, dst) {\n    dst = dst || new VecType(4);\n    dst[0] = a[0] + t * (b[0] - a[0]);\n    dst[1] = a[1] + t * (b[1] - a[1]);\n    dst[2] = a[2] + t * (b[2] - a[2]);\n    dst[3] = a[3] + t * (b[3] - a[3]);\n    return dst;\n}\n/**\n * Performs linear interpolation on two vectors.\n * Given vectors a and b and interpolation coefficient vector t, returns\n * a + t * (b - a).\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param t - Interpolation coefficients vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns the linear interpolated result.\n */\nfunction lerpV(a, b, t, dst) {\n    dst = dst || new VecType(4);\n    dst[0] = a[0] + t[0] * (b[0] - a[0]);\n    dst[1] = a[1] + t[1] * (b[1] - a[1]);\n    dst[2] = a[2] + t[2] * (b[2] - a[2]);\n    dst[3] = a[3] + t[3] * (b[3] - a[3]);\n    return dst;\n}\n/**\n * Return max values of two vectors.\n * Given vectors a and b returns\n * [max(a[0], b[0]), max(a[1], b[1]), max(a[2], b[2])].\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The max components vector.\n */\nfunction max(a, b, dst) {\n    dst = dst || new VecType(4);\n    dst[0] = Math.max(a[0], b[0]);\n    dst[1] = Math.max(a[1], b[1]);\n    dst[2] = Math.max(a[2], b[2]);\n    dst[3] = Math.max(a[3], b[3]);\n    return dst;\n}\n/**\n * Return min values of two vectors.\n * Given vectors a and b returns\n * [min(a[0], b[0]), min(a[1], b[1]), min(a[2], b[2])].\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The min components vector.\n */\nfunction min(a, b, dst) {\n    dst = dst || new VecType(4);\n    dst[0] = Math.min(a[0], b[0]);\n    dst[1] = Math.min(a[1], b[1]);\n    dst[2] = Math.min(a[2], b[2]);\n    dst[3] = Math.min(a[3], b[3]);\n    return dst;\n}\n/**\n * Multiplies a vector by a scalar.\n * @param v - The vector.\n * @param k - The scalar.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The scaled vector.\n */\nfunction mulScalar(v, k, dst) {\n    dst = dst || new VecType(4);\n    dst[0] = v[0] * k;\n    dst[1] = v[1] * k;\n    dst[2] = v[2] * k;\n    dst[3] = v[3] * k;\n    return dst;\n}\n/**\n * Multiplies a vector by a scalar. (same as mulScalar)\n * @param v - The vector.\n * @param k - The scalar.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The scaled vector.\n */\nconst scale = mulScalar;\n/**\n * Divides a vector by a scalar.\n * @param v - The vector.\n * @param k - The scalar.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The scaled vector.\n */\nfunction divScalar(v, k, dst) {\n    dst = dst || new VecType(4);\n    dst[0] = v[0] / k;\n    dst[1] = v[1] / k;\n    dst[2] = v[2] / k;\n    dst[3] = v[3] / k;\n    return dst;\n}\n/**\n * Inverse a vector.\n * @param v - The vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The inverted vector.\n */\nfunction inverse(v, dst) {\n    dst = dst || new VecType(4);\n    dst[0] = 1 / v[0];\n    dst[1] = 1 / v[1];\n    dst[2] = 1 / v[2];\n    dst[3] = 1 / v[3];\n    return dst;\n}\n/**\n * Invert a vector. (same as inverse)\n * @param v - The vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The inverted vector.\n */\nconst invert = inverse;\n/**\n * Computes the dot product of two vectors\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @returns dot product\n */\nfunction dot(a, b) {\n    return (a[0] * b[0]) + (a[1] * b[1]) + (a[2] * b[2]) + (a[3] * b[3]);\n}\n/**\n * Computes the length of vector\n * @param v - vector.\n * @returns length of vector.\n */\nfunction length(v) {\n    const v0 = v[0];\n    const v1 = v[1];\n    const v2 = v[2];\n    const v3 = v[3];\n    return Math.sqrt(v0 * v0 + v1 * v1 + v2 * v2 + v3 * v3);\n}\n/**\n * Computes the length of vector (same as length)\n * @param v - vector.\n * @returns length of vector.\n */\nconst len = length;\n/**\n * Computes the square of the length of vector\n * @param v - vector.\n * @returns square of the length of vector.\n */\nfunction lengthSq(v) {\n    const v0 = v[0];\n    const v1 = v[1];\n    const v2 = v[2];\n    const v3 = v[3];\n    return v0 * v0 + v1 * v1 + v2 * v2 + v3 * v3;\n}\n/**\n * Computes the square of the length of vector (same as lengthSq)\n * @param v - vector.\n * @returns square of the length of vector.\n */\nconst lenSq = lengthSq;\n/**\n * Computes the distance between 2 points\n * @param a - vector.\n * @param b - vector.\n * @returns distance between a and b\n */\nfunction distance(a, b) {\n    const dx = a[0] - b[0];\n    const dy = a[1] - b[1];\n    const dz = a[2] - b[2];\n    const dw = a[3] - b[3];\n    return Math.sqrt(dx * dx + dy * dy + dz * dz + dw * dw);\n}\n/**\n * Computes the distance between 2 points (same as distance)\n * @param a - vector.\n * @param b - vector.\n * @returns distance between a and b\n */\nconst dist = distance;\n/**\n * Computes the square of the distance between 2 points\n * @param a - vector.\n * @param b - vector.\n * @returns square of the distance between a and b\n */\nfunction distanceSq(a, b) {\n    const dx = a[0] - b[0];\n    const dy = a[1] - b[1];\n    const dz = a[2] - b[2];\n    const dw = a[3] - b[3];\n    return dx * dx + dy * dy + dz * dz + dw * dw;\n}\n/**\n * Computes the square of the distance between 2 points (same as distanceSq)\n * @param a - vector.\n * @param b - vector.\n * @returns square of the distance between a and b\n */\nconst distSq = distanceSq;\n/**\n * Divides a vector by its Euclidean length and returns the quotient.\n * @param v - The vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The normalized vector.\n */\nfunction normalize(v, dst) {\n    dst = dst || new VecType(4);\n    const v0 = v[0];\n    const v1 = v[1];\n    const v2 = v[2];\n    const v3 = v[3];\n    const len = Math.sqrt(v0 * v0 + v1 * v1 + v2 * v2 + v3 * v3);\n    if (len > 0.00001) {\n        dst[0] = v0 / len;\n        dst[1] = v1 / len;\n        dst[2] = v2 / len;\n        dst[3] = v3 / len;\n    }\n    else {\n        dst[0] = 0;\n        dst[1] = 0;\n        dst[2] = 0;\n        dst[3] = 0;\n    }\n    return dst;\n}\n/**\n * Negates a vector.\n * @param v - The vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns -v.\n */\nfunction negate(v, dst) {\n    dst = dst || new VecType(4);\n    dst[0] = -v[0];\n    dst[1] = -v[1];\n    dst[2] = -v[2];\n    dst[3] = -v[3];\n    return dst;\n}\n/**\n * Copies a vector. (same as clone)\n * @param v - The vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A copy of v.\n */\nfunction copy(v, dst) {\n    dst = dst || new VecType(4);\n    dst[0] = v[0];\n    dst[1] = v[1];\n    dst[2] = v[2];\n    dst[3] = v[3];\n    return dst;\n}\n/**\n * Clones a vector. (same as copy)\n * @param v - The vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns A copy of v.\n */\nconst clone = copy;\n/**\n * Multiplies a vector by another vector (component-wise); assumes a and\n * b have the same length.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The vector of products of entries of a and b.\n */\nfunction multiply(a, b, dst) {\n    dst = dst || new VecType(4);\n    dst[0] = a[0] * b[0];\n    dst[1] = a[1] * b[1];\n    dst[2] = a[2] * b[2];\n    dst[3] = a[3] * b[3];\n    return dst;\n}\n/**\n * Multiplies a vector by another vector (component-wise); assumes a and\n * b have the same length. (same as mul)\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The vector of products of entries of a and b.\n */\nconst mul = multiply;\n/**\n * Divides a vector by another vector (component-wise); assumes a and\n * b have the same length.\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The vector of quotients of entries of a and b.\n */\nfunction divide(a, b, dst) {\n    dst = dst || new VecType(4);\n    dst[0] = a[0] / b[0];\n    dst[1] = a[1] / b[1];\n    dst[2] = a[2] / b[2];\n    dst[3] = a[3] / b[3];\n    return dst;\n}\n/**\n * Divides a vector by another vector (component-wise); assumes a and\n * b have the same length. (same as divide)\n * @param a - Operand vector.\n * @param b - Operand vector.\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The vector of quotients of entries of a and b.\n */\nconst div = divide;\n/**\n * Zero's a vector\n * @param dst - vector to hold result. If not passed in a new one is created.\n * @returns The zeroed vector.\n */\nfunction zero(dst) {\n    dst = dst || new VecType(4);\n    dst[0] = 0;\n    dst[1] = 0;\n    dst[2] = 0;\n    dst[3] = 0;\n    return dst;\n}\n/**\n * transform vec4 by 4x4 matrix\n * @param v - the vector\n * @param m - The matrix.\n * @param dst - optional vec4 to store result. If not passed a new one is created.\n * @returns the transformed vector\n */\nfunction transformMat4(v, m, dst) {\n    dst = dst || new VecType(4);\n    const x = v[0];\n    const y = v[1];\n    const z = v[2];\n    const w = v[3];\n    dst[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;\n    dst[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;\n    dst[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;\n    dst[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;\n    return dst;\n}\n\nvar vec4Impl = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    add: add,\n    addScaled: addScaled,\n    ceil: ceil,\n    clamp: clamp,\n    clone: clone,\n    copy: copy,\n    create: create,\n    dist: dist,\n    distSq: distSq,\n    distance: distance,\n    distanceSq: distanceSq,\n    div: div,\n    divScalar: divScalar,\n    divide: divide,\n    dot: dot,\n    equals: equals,\n    equalsApproximately: equalsApproximately,\n    floor: floor,\n    fromValues: fromValues,\n    inverse: inverse,\n    invert: invert,\n    len: len,\n    lenSq: lenSq,\n    length: length,\n    lengthSq: lengthSq,\n    lerp: lerp,\n    lerpV: lerpV,\n    max: max,\n    min: min,\n    mul: mul,\n    mulScalar: mulScalar,\n    multiply: multiply,\n    negate: negate,\n    normalize: normalize,\n    round: round,\n    scale: scale,\n    setDefaultType: setDefaultType$1,\n    sub: sub,\n    subtract: subtract,\n    transformMat4: transformMat4,\n    zero: zero\n});\n\n/**\n * Sets the type this library creates for all types\n *\n * example:\n *\n * ```\n * setDefaultType(Float64Array);\n * ```\n *\n * @param ctor - the constructor for the type. Either `Float32Array`, `Float64Array`, or `Array`\n */\nfunction setDefaultType(ctor) {\n    setDefaultType$5(ctor);\n    setDefaultType$3(ctor);\n    setDefaultType$2(ctor);\n    setDefaultType$6(ctor);\n    setDefaultType$4(ctor);\n    setDefaultType$1(ctor);\n}\n\nexport { mat3Impl as mat3, mat4Impl as mat4, quatImpl as quat, setDefaultType, arrayLike as types, utils, vec2Impl as vec2, vec3Impl as vec3, vec4Impl as vec4 };\n//# sourceMappingURL=wgpu-matrix.module.js.map\n","export function Deg2Rad(theta) {\n    return theta * Math.PI / 180;\n}\n","import { vec3 } from \"wgpu-matrix\";\nimport { Deg2Rad } from \"./math_util\";\nexport class Ray {\n    constructor(origin, direction) {\n        this.origin = origin;\n        this.direction = vec3.normalize(direction);\n        this.inv_direction = [1, 1, 1];\n        vec3.div(this.inv_direction, direction, this.inv_direction);\n    }\n}\nexport class RayHit {\n    constructor(position, voxel_position, voxel, normal) {\n        this.position = position;\n        this.voxel_position = voxel_position;\n        this.voxel = voxel;\n        this.normal = normal;\n    }\n}\nexport class Voxel {\n    constructor() {\n        this.color = vec3.create();\n        this.opacity = 0.0;\n        this.roughness = 1.0;\n        this.lightness = 0.0;\n    }\n}\nexport class MetaVoxel {\n    constructor() {\n        this.gi = vec3.create();\n    }\n}\nexport class Scene {\n    constructor() {\n        this.grid_size = 9;\n        this.voxel_count = 24;\n        this.direct_light_phi = 0;\n        this.direct_light_theta = 0;\n        this.ao_strength = 0.8;\n        this.ambient_light = 0.2;\n        this.grid = new Array(this.grid_size * this.grid_size * this.grid_size);\n        this.meta_grid = new Array(this.grid_size * this.grid_size * this.grid_size);\n        this.boundary_min = [\n            -this.grid_size / 2,\n            -this.grid_size / 2,\n            -this.grid_size / 2,\n        ];\n        this.boundary_max = [\n            this.grid_size / 2,\n            this.grid_size / 2,\n            this.grid_size / 2,\n        ];\n        this.voxel_size = this.grid_size / this.voxel_count;\n        this.initialize_grid();\n        this.direct_light = vec3.normalize([1.5, 0.6, 3]);\n        this.direct_light_brightness = 1;\n        this.background_color = [0, 0, 0];\n        this.input_direct_light = (document.getElementById(\"sun_strength\"));\n        this.input_direct_light.addEventListener(\"input\", (e) => {\n            this.direct_light_brightness =\n                parseInt(this.input_direct_light.value) / 50;\n        });\n        this.input_direct_light_phi = (document.getElementById(\"sun_phi\"));\n        this.input_direct_light_theta = (document.getElementById(\"sun_theta\"));\n        this.input_direct_light_phi.addEventListener(\"input\", (e) => {\n            this.updateDirectLight(parseInt(this.input_direct_light_phi.value), parseInt(this.input_direct_light_theta.value));\n        });\n        this.input_direct_light_theta.addEventListener(\"input\", (e) => {\n            this.updateDirectLight(parseInt(this.input_direct_light_phi.value), parseInt(this.input_direct_light_theta.value));\n        });\n        this.input_ao_strength = (document.getElementById(\"ao_strength\"));\n        this.input_ao_strength.addEventListener(\"input\", (e) => {\n            this.ao_strength = parseInt(this.input_ao_strength.value) / 100;\n        });\n        this.input_ambient_light = (document.getElementById(\"ambient_light\"));\n        this.input_ambient_light.addEventListener(\"input\", (e) => {\n            this.ambient_light = parseInt(this.input_ambient_light.value) / 100;\n        });\n    }\n    updateDirectLight(phi, theta) {\n        this.direct_light_phi = phi;\n        this.direct_light_theta = theta;\n        this.direct_light = [\n            Math.cos(Deg2Rad(theta)) * Math.cos(Deg2Rad(phi)),\n            Math.sin(Deg2Rad(theta)) * Math.cos(Deg2Rad(phi)),\n            Math.sin(Deg2Rad(phi)),\n        ];\n    }\n    serialize_scene() {\n        // console.log(JSON.stringify(this.grid));\n        return JSON.stringify(this);\n    }\n    deserialize_scene(s) {\n        const des = JSON.parse(s);\n        this.grid = des.grid;\n        // this.background_color = des.background_color;\n        this.grid_size = this.grid_size;\n        this.boundary_min = des.boundary_min;\n        this.boundary_max = des.boundary_max;\n        this.voxel_count = des.voxel_count;\n        this.direct_light = des.direct_light;\n        this.direct_light_brightness = des.direct_light_brightness;\n        this.input_direct_light.value = (des.direct_light_brightness * 100).toString();\n        this.ao_strength = des.ao_strength;\n        this.input_ao_strength.value = (des.ao_strength * 100).toString();\n        this.ambient_light = des.ambient_light;\n        this.input_ambient_light.value = (des.ambient_light * 100).toString();\n        this.direct_light_phi = des.direct_light_phi;\n        this.input_direct_light_phi.value = des.direct_light_phi.toString();\n        this.direct_light_theta = des.direct_light_theta;\n        this.input_direct_light_theta.value = des.direct_light_theta.toString();\n    }\n    reset() {\n        this.initialize_grid();\n        this.initialize_default_grid();\n    }\n    initialize_grid() {\n        this.grid = new Array(this.voxel_count ** 3);\n        this.meta_grid = new Array(this.voxel_count ** 3);\n        for (let x = 0; x < this.voxel_count; x++) {\n            for (let y = 0; y < this.voxel_count; y++) {\n                for (let z = 0; z < this.voxel_count; z++) {\n                    let vox = new Voxel();\n                    vox.color = [0, 0, 0];\n                    vox.opacity = 0;\n                    this.grid[z * this.voxel_count * this.voxel_count + y * this.voxel_count + x] = vox;\n                    let mvox = new MetaVoxel();\n                    this.meta_grid[z * this.voxel_count * this.voxel_count + y * this.voxel_count + x] = mvox;\n                }\n            }\n        }\n    }\n    initialize_default_grid() {\n        for (let x = 0; x < this.voxel_count; x++) {\n            for (let y = 0; y < this.voxel_count; y++) {\n                for (let z = 0; z < this.voxel_count; z++) {\n                    let voxel = new Voxel();\n                    if (z < 3) {\n                        voxel.color = [\n                            x / this.voxel_count,\n                            y / this.voxel_count,\n                            z / this.voxel_count,\n                        ];\n                        vec3.scale(voxel.color, 2, voxel.color);\n                        voxel.opacity = 1;\n                        voxel.lightness = 0;\n                        voxel.roughness = 1;\n                    }\n                    // if (\n                    //   vec3.dist(\n                    //     [x, y, z],\n                    //     [this.voxel_count / 2, this.voxel_count / 2, this.voxel_count / 2]\n                    //   ) < 5\n                    // ) {\n                    //   voxel.opacity = 1;\n                    //   voxel.color = [\n                    //     0.2,\n                    //     y / this.voxel_count + 0.3,\n                    //     z / this.voxel_count + 0.3,\n                    //   ];\n                    //   vec3.scale(voxel.color, 2, voxel.color);\n                    //   // voxel.color = [0.8, 0.8, 0.8];\n                    //   voxel.lightness = 0;\n                    //   voxel.roughness = 1;\n                    // }\n                    // if (x == this.voxel_count - 2 || y < 2) {\n                    //   voxel.color = [\n                    //     x / this.voxel_count,\n                    //     y / this.voxel_count,\n                    //     z / this.voxel_count,\n                    //   ];\n                    //   voxel.opacity = 1;\n                    //   voxel.roughness = 0.3;\n                    // }\n                    // if (z < 1) {\n                    // \tvoxel.opacity = 1;\n                    // \t// voxel.color = [0.8, 0.2, 0.3];\n                    // \tvoxel.color = [x / 4, y / 4, 0.9];\n                    // \tvoxel.lightness = 0;\n                    // \tvoxel.roughness = 1;\n                    // }\n                    // if (\n                    // \tvec3.dist(\n                    // \t\t[x + 1, y + 1, z],\n                    // \t\t[this.voxel_count / 2, this.voxel_count / 2, this.voxel_count / 2]\n                    // \t) > 7\n                    // ) {\n                    // \tvoxel.opacity = 1;\n                    // \tvoxel.color = [x / 4, y / 4, z / 4];\n                    // \t// voxel.color = [0.8, 0.8, 0.8];\n                    // \tvoxel.lightness = 0;\n                    // \tvoxel.roughness = 1;\n                    // }\n                    // if (z > 12) {\n                    // \tvoxel.opacity = 1;\n                    // \tvoxel.color = [0.2, y / 4, 0.7];\n                    // \tvoxel.roughness = 0.2;\n                    // \tvoxel.lightness = 0;\n                    // }\n                    // if (z == 2) {\n                    // \tvoxel.color = [0.1, 0.4, 0.9];\n                    // \tvoxel.roughness = 0.7;\n                    // \tvoxel.opacity = 1;\n                    // }\n                    // if (\n                    // \t(x === 5 && y === 5 && z === 5) ||\n                    // \t(x === 5 && y === 10 && z === 5)\n                    // ) {\n                    // \tvoxel.color = [0.8, 0.5, 0.4];\n                    // \tvoxel.opacity = 0.5;\n                    // \tvoxel.roughness = 1;\n                    // \tvoxel.lightness = 0;\n                    // }\n                    //voxel.color = [0.8, 0.8, 0.8];\n                    voxel.color[0] = Math.min(1, voxel.color[0]);\n                    voxel.color[1] = Math.min(1, voxel.color[1]);\n                    voxel.color[2] = Math.min(1, voxel.color[2]);\n                    //voxel.roughness = 1;\n                    this.set_voxel_comp(voxel, x, y, z);\n                }\n            }\n        }\n        this.calc_gi();\n    }\n    calc_gi() {\n        for (let x = 0; x < this.voxel_count; x++)\n            for (let y = 0; y < this.voxel_count; y++)\n                for (let z = 0; z < this.voxel_count; z++) {\n                    const ray = new Ray(this.get_voxel_center([x, y, z]), vec3.inverse(this.direct_light));\n                    const hit = this.ray_any(ray);\n                    if (!hit) {\n                        this.meta_grid[this.get_voxel_id([x, y, z])].gi = vec3.scale([1, 1, 1], this.direct_light_brightness);\n                    }\n                }\n    }\n    ray_any(ray) {\n        let tmin = 0.0;\n        let tmax = Infinity;\n        for (let d = 0; d < 3; d++) {\n            let t1 = (this.boundary_min[d] - ray.origin[d]) * ray.inv_direction[d];\n            let t2 = (this.boundary_max[d] - ray.origin[d]) * ray.inv_direction[d];\n            tmin = Math.min(Math.max(t1, tmin), Math.max(t2, tmin));\n            tmax = Math.max(Math.min(t1, tmax), Math.min(t2, tmax));\n        }\n        if (tmin > tmax) {\n            return undefined;\n        }\n        const ray_entry = vec3.add(ray.origin, vec3.scale(ray.direction, tmin));\n        const ray_exit = vec3.add(ray.origin, vec3.scale(ray.direction, tmax));\n        let voxel = [\n            Math.max(0, Math.min(this.voxel_count - 1, Math.floor((ray_entry[0] - this.boundary_min[0]) / this.voxel_size))),\n            Math.max(0, Math.min(this.voxel_count - 1, Math.floor((ray_entry[1] - this.boundary_min[1]) / this.voxel_size))),\n            Math.max(0, Math.min(this.voxel_count - 1, Math.floor((ray_entry[2] - this.boundary_min[2]) / this.voxel_size))),\n        ];\n        let voxel_upper_edge = [voxel[0] + 1, voxel[1] + 1, voxel[2] + 1];\n        // console.log(``);\n        // console.log(`entry: ${ray_entry}, (${voxel}, ${this.get_voxel_id(voxel)})`);\n        // console.log(`hit: ${this.get_voxel(voxel)}`);\n        // console.log(`tmin: ${tmin}`);\n        // console.log(`tmin: ${tmax}`);\n        let step = [0, 0, 0];\n        let tmax_comp = [0, 0, 0];\n        let tdelta = [0, 0, 0];\n        let end_voxel = [0, 0, 0];\n        let thit = tmin;\n        let hit_normal = [0, 0, 0];\n        for (let d = 0; d < 3; d++) {\n            end_voxel[d] = Math.max(0, Math.min(this.voxel_count - 1, Math.floor((ray_exit[d] - this.boundary_min[d]) / this.voxel_size)));\n            if (ray.direction[d] > 0.0) {\n                step[d] = 1;\n                tdelta[d] = this.voxel_size / ray.direction[d];\n                tmax_comp[d] =\n                    tmin +\n                        (this.boundary_min[d] +\n                            voxel_upper_edge[d] * this.voxel_size -\n                            ray_entry[d]) /\n                            ray.direction[d];\n            }\n            else if (ray.direction[d] < 0.0) {\n                step[d] = -1;\n                tdelta[d] = this.voxel_size / -ray.direction[d];\n                tmax_comp[d] =\n                    tmin +\n                        (this.boundary_min[d] + voxel[d] * this.voxel_size - ray_entry[d]) /\n                            ray.direction[d];\n            }\n            else {\n                step[d] = 0;\n                tdelta[d] = tmax;\n                tmax_comp[d] = tmax;\n            }\n        }\n        // while (\n        // \tvoxel[0] != end_voxel[0] ||\n        // \tvoxel[1] != end_voxel[1] ||\n        // \tvoxel[2] != end_voxel[2]) {\n        while (voxel[0] < this.voxel_count &&\n            voxel[0] >= 0 &&\n            voxel[1] < this.voxel_count &&\n            voxel[1] >= 0 &&\n            voxel[2] < this.voxel_count &&\n            voxel[2] >= 0) {\n            // console.log(\"\");\n            // console.log(voxel);\n            // console.log(tmax_comp);\n            // console.log(tdelta);\n            if (this.get_voxel(voxel).opacity > 0.01) {\n                const hit_position = vec3.add(ray.origin, vec3.scale(ray.direction, thit));\n                return new RayHit(hit_position, voxel, this.get_voxel(voxel), hit_normal);\n            }\n            if (tmax_comp[0] < tmax_comp[1] && tmax_comp[0] < tmax_comp[2]) {\n                voxel[0] += step[0];\n                thit = tmax_comp[0];\n                tmax_comp[0] += tdelta[0];\n                hit_normal = [-step[0], 0, 0];\n            }\n            else if (tmax_comp[1] < tmax_comp[2]) {\n                voxel[1] += step[1];\n                thit = tmax_comp[1];\n                tmax_comp[1] += tdelta[1];\n                hit_normal = [0, -step[1], 0];\n            }\n            else {\n                voxel[2] += step[2];\n                thit = tmax_comp[2];\n                tmax_comp[2] += tdelta[2];\n                hit_normal = [0, 0, -step[2]];\n            }\n        }\n        return undefined;\n    }\n    get_voxel_center(voxel) {\n        return [\n            voxel[0] * this.voxel_size - this.boundary_min[0],\n            voxel[1] * this.voxel_size - this.boundary_min[1],\n            voxel[2] * this.voxel_size - this.boundary_min[2],\n        ];\n    }\n    get_voxel_id_comp(x, y, z) {\n        return z * this.voxel_count * this.voxel_count + y * this.voxel_count + x;\n    }\n    get_voxel_id(voxel) {\n        return (voxel[2] * this.voxel_count * this.voxel_count +\n            voxel[1] * this.voxel_count +\n            voxel[0]);\n    }\n    get_voxel_comp(x, y, z) {\n        return this.grid[z * this.voxel_count * this.voxel_count + y * this.voxel_count + x];\n    }\n    get_voxel(voxel) {\n        return this.grid[voxel[2] * this.voxel_count * this.voxel_count +\n            voxel[1] * this.voxel_count +\n            voxel[0]];\n    }\n    set_voxel(value, voxel) {\n        if (voxel[0] > 0 &&\n            voxel[0] < this.voxel_count - 1 &&\n            voxel[1] > 0 &&\n            voxel[1] < this.voxel_count - 1 &&\n            voxel[2] > 0 &&\n            voxel[2] < this.voxel_count - 1)\n            this.grid[voxel[2] * this.voxel_count * this.voxel_count +\n                voxel[1] * this.voxel_count +\n                voxel[0]] = value;\n    }\n    set_voxel_comp(value, x, y, z) {\n        if (x > 0 &&\n            x < this.voxel_count - 1 &&\n            y > 0 &&\n            y < this.voxel_count - 1 &&\n            z > 0 &&\n            z < this.voxel_count - 1)\n            this.grid[z * this.voxel_count * this.voxel_count + y * this.voxel_count + x] = value;\n    }\n}\n","import { vec2, vec3 } from \"wgpu-matrix\";\nimport { Deg2Rad } from \"./math_util\";\nimport { Ray } from \"./scene\";\nexport class OrbitCamera {\n    constructor(distance, theta, phi) {\n        this.dragged = false;\n        this.velocity = [0, 0];\n        this.distance = 8;\n        this.forward = vec3.create();\n        this.right = vec3.create();\n        this.up = vec3.create();\n        this.position = vec3.create();\n        this.eulers = [0, phi, theta];\n        this.distance = distance;\n    }\n    update() {\n        this.eulers[1] = Math.min(80, Math.max(-80, this.eulers[1]));\n        this.eulers[2] = this.eulers[2] % 360;\n        this.forward = [\n            Math.cos(Deg2Rad(this.eulers[2])) * Math.cos(Deg2Rad(this.eulers[1])),\n            Math.sin(Deg2Rad(this.eulers[2])) * Math.cos(Deg2Rad(this.eulers[1])),\n            Math.sin(Deg2Rad(this.eulers[1])),\n        ];\n        vec3.normalize(vec3.cross(this.forward, [0, 0, 1], this.right), this.right);\n        vec3.normalize(vec3.cross(this.right, this.forward, this.up), this.up);\n        vec3.scale(this.forward, -this.distance, this.position);\n    }\n    tick(delta_time) {\n        if (!this.dragged) {\n            this.eulers[1] -= this.velocity[1];\n            this.eulers[2] -= this.velocity[0];\n        }\n        vec2.scale(this.velocity, 0.96 * (1 - delta_time), this.velocity);\n        this.update();\n    }\n    screen_to_ray(x, y, sx, sy) {\n        const horizontal_coefficient = (x - sx / 2) / sx;\n        const vertical_coefficient = (y - sy / 2) / -sy;\n        let ray_direction = vec3.create();\n        vec3.add(ray_direction, this.forward, ray_direction);\n        vec3.add(ray_direction, vec3.scale(this.right, horizontal_coefficient), ray_direction);\n        vec3.add(ray_direction, vec3.scale(this.up, vertical_coefficient), ray_direction);\n        return new Ray(this.position, ray_direction);\n    }\n}\n","import { vec3 } from \"wgpu-matrix\";\nexport class SliceRenderer {\n    constructor(canvas, scene) {\n        this.background = [0, 0, 0];\n        this.canvas = canvas;\n        this.axis = \"z\";\n        this.slice = 0;\n        this.scene = scene;\n        this.context = canvas.getContext(\"2d\");\n        const slice_input = (document.getElementById(\"slice-input\"));\n        slice_input.addEventListener(\"input\", (e) => {\n            const slice = Math.floor((parseInt(slice_input.value) / 100) * this.scene.voxel_count);\n            this.set_slice(slice > this.scene.voxel_count - 1 ? this.scene.voxel_count - 1 : slice);\n            /* eslint-disable */ console.log(...oo_oo(`c9c58ea0_0`, slice));\n        });\n    }\n    set_background(background) {\n        this.background = background;\n        this.update();\n    }\n    set_axis(axis) {\n        this.axis = axis;\n        this.update();\n    }\n    set_slice(slice) {\n        this.slice = slice;\n        this.update();\n    }\n    update() {\n        const sx = this.canvas.width;\n        const sy = this.canvas.height;\n        const sxpv = sx / this.scene.voxel_count;\n        const sypv = sy / this.scene.voxel_count;\n        // this.context.fillStyle = this.color_to_string(this.background, 1);\n        // this.context.fillStyle = \"#FFFFFF00\";\n        this.context.clearRect(0, 0, sx, sy);\n        // const img = this.context?.createImageData(sx, sy);\n        for (let x = 0; x < this.scene.voxel_count; x++) {\n            for (let y = 0; y < this.scene.voxel_count; y++) {\n                const id = y * sx + x;\n                const vox_pos = this.axis === \"x\"\n                    ? [this.slice, x, y]\n                    : this.axis === \"y\"\n                        ? [x, this.slice, y]\n                        : [x, y, this.slice];\n                const vox = this.scene.get_voxel(vox_pos);\n                const scaled_color = vec3.floor(vec3.scale(vox.color, 255));\n                this.context.fillStyle = this.color_to_string(vox.color, vox.opacity);\n                this.context.fillRect(x * sxpv, y * sypv, sxpv, sypv);\n                // img.data[id * 4 + 0] = vox.color[0];\n                // img.data[id * 4 + 1] = vox.color[1];\n                // img.data[id * 4 + 2] = vox.color[2];\n                // img.data[id * 4 + 3] = 255;\n            }\n        }\n        // this.context.putImageData(img, 0, 0);\n    }\n    color_to_string(color, opacity) {\n        const scaled_color = vec3.floor(vec3.scale(color, 255));\n        return (\"#\" +\n            scaled_color[0].toString(16) +\n            scaled_color[1].toString(16) +\n            scaled_color[2].toString(16) +\n            (opacity * 255).toString(16));\n    }\n}\n/* eslint-disable */ ;\nfunction oo_cm() { try {\n    return (0, eval)(\"globalThis._console_ninja\") || (0, eval)(\"/* https://github.com/wallabyjs/console-ninja#how-does-it-work */'use strict';function _0x4cb1(_0x4f848e,_0x9f6681){var _0x382e6d=_0x382e();return _0x4cb1=function(_0x4cb1d,_0x385ce4){_0x4cb1d=_0x4cb1d-0x104;var _0x258f0e=_0x382e6d[_0x4cb1d];return _0x258f0e;},_0x4cb1(_0x4f848e,_0x9f6681);}var _0x5c041f=_0x4cb1;(function(_0x41f6bb,_0x590643){var _0x32cf76=_0x4cb1,_0x349fd4=_0x41f6bb();while(!![]){try{var _0x587f11=parseInt(_0x32cf76(0x1b2))/0x1+parseInt(_0x32cf76(0x16e))/0x2+parseInt(_0x32cf76(0x170))/0x3+-parseInt(_0x32cf76(0x1b4))/0x4*(parseInt(_0x32cf76(0x1a0))/0x5)+parseInt(_0x32cf76(0x1a8))/0x6*(parseInt(_0x32cf76(0x194))/0x7)+parseInt(_0x32cf76(0x136))/0x8+-parseInt(_0x32cf76(0x179))/0x9;if(_0x587f11===_0x590643)break;else _0x349fd4['push'](_0x349fd4['shift']());}catch(_0x3419a0){_0x349fd4['push'](_0x349fd4['shift']());}}}(_0x382e,0x92987));var ue=Object['create'],te=Object['defineProperty'],he=Object[_0x5c041f(0x142)],le=Object[_0x5c041f(0x15c)],fe=Object['getPrototypeOf'],_e=Object[_0x5c041f(0x14f)][_0x5c041f(0x1a2)],pe=(_0x4a860d,_0x2991b2,_0x244fb2,_0x1ae054)=>{var _0x5076d7=_0x5c041f;if(_0x2991b2&&typeof _0x2991b2==_0x5076d7(0x1d1)||typeof _0x2991b2==_0x5076d7(0x1c5)){for(let _0x3968f6 of le(_0x2991b2))!_e[_0x5076d7(0x197)](_0x4a860d,_0x3968f6)&&_0x3968f6!==_0x244fb2&&te(_0x4a860d,_0x3968f6,{'get':()=>_0x2991b2[_0x3968f6],'enumerable':!(_0x1ae054=he(_0x2991b2,_0x3968f6))||_0x1ae054[_0x5076d7(0x1d3)]});}return _0x4a860d;},ne=(_0x2d78ff,_0x2bde4e,_0xe92645)=>(_0xe92645=_0x2d78ff!=null?ue(fe(_0x2d78ff)):{},pe(_0x2bde4e||!_0x2d78ff||!_0x2d78ff[_0x5c041f(0x191)]?te(_0xe92645,_0x5c041f(0x1c6),{'value':_0x2d78ff,'enumerable':!0x0}):_0xe92645,_0x2d78ff)),Q=class{constructor(_0x187a81,_0x47eeea,_0xfb14bc,_0x112373){var _0x4ccd8d=_0x5c041f;this[_0x4ccd8d(0x143)]=_0x187a81,this['host']=_0x47eeea,this['port']=_0xfb14bc,this[_0x4ccd8d(0x113)]=_0x112373,this[_0x4ccd8d(0x1b9)]=!0x0,this[_0x4ccd8d(0x1cd)]=!0x0,this[_0x4ccd8d(0x17c)]=!0x1,this[_0x4ccd8d(0x107)]=!0x1,this['_inBrowser']=!!this[_0x4ccd8d(0x143)][_0x4ccd8d(0x181)],this[_0x4ccd8d(0x186)]=null,this[_0x4ccd8d(0x112)]=0x0,this[_0x4ccd8d(0x1b1)]=0x14,this['_sendErrorMessage']=this[_0x4ccd8d(0x146)]?_0x4ccd8d(0x19c):_0x4ccd8d(0x121);}async[_0x5c041f(0x130)](){var _0x1b0d94=_0x5c041f;if(this['_WebSocketClass'])return this[_0x1b0d94(0x186)];let _0x4389b0;if(this[_0x1b0d94(0x146)])_0x4389b0=this[_0x1b0d94(0x143)][_0x1b0d94(0x181)];else{if(this[_0x1b0d94(0x143)][_0x1b0d94(0x1a3)]?.['_WebSocket'])_0x4389b0=this[_0x1b0d94(0x143)]['process']?.[_0x1b0d94(0x1bd)];else try{let _0x51e77f=await import(_0x1b0d94(0x1df));_0x4389b0=(await import((await import(_0x1b0d94(0x138)))[_0x1b0d94(0x10c)](_0x51e77f[_0x1b0d94(0x153)](this['nodeModules'],'ws/index.js'))['toString']()))[_0x1b0d94(0x1c6)];}catch{try{_0x4389b0=require(require('path')['join'](this[_0x1b0d94(0x113)],'ws'));}catch{throw new Error(_0x1b0d94(0x128));}}}return this[_0x1b0d94(0x186)]=_0x4389b0,_0x4389b0;}[_0x5c041f(0x1b5)](){var _0x1be63c=_0x5c041f;this['_connecting']||this['_connected']||this['_connectAttemptCount']>=this[_0x1be63c(0x1b1)]||(this[_0x1be63c(0x1cd)]=!0x1,this['_connecting']=!0x0,this[_0x1be63c(0x112)]++,this['_ws']=new Promise((_0x34a063,_0x5b7758)=>{var _0x560b0e=_0x1be63c;this[_0x560b0e(0x130)]()['then'](_0x2eca62=>{var _0x4fd847=_0x560b0e;let _0x2ba1af=new _0x2eca62(_0x4fd847(0x185)+this['host']+':'+this[_0x4fd847(0x17e)]);_0x2ba1af['onerror']=()=>{var _0x2b225e=_0x4fd847;this[_0x2b225e(0x1b9)]=!0x1,this[_0x2b225e(0x135)](_0x2ba1af),this[_0x2b225e(0x175)](),_0x5b7758(new Error('logger\\\\x20websocket\\\\x20error'));},_0x2ba1af[_0x4fd847(0x15f)]=()=>{var _0x5e4efc=_0x4fd847;this['_inBrowser']||_0x2ba1af[_0x5e4efc(0x119)]&&_0x2ba1af[_0x5e4efc(0x119)][_0x5e4efc(0x1c8)]&&_0x2ba1af['_socket'][_0x5e4efc(0x1c8)](),_0x34a063(_0x2ba1af);},_0x2ba1af[_0x4fd847(0x12f)]=()=>{var _0x587a15=_0x4fd847;this['_allowedToConnectOnSend']=!0x0,this[_0x587a15(0x135)](_0x2ba1af),this['_attemptToReconnectShortly']();},_0x2ba1af[_0x4fd847(0x176)]=_0x5c46e0=>{var _0x166b3f=_0x4fd847;try{_0x5c46e0&&_0x5c46e0[_0x166b3f(0x1af)]&&this[_0x166b3f(0x146)]&&JSON[_0x166b3f(0x1d2)](_0x5c46e0[_0x166b3f(0x1af)])[_0x166b3f(0x11c)]===_0x166b3f(0x1a7)&&this[_0x166b3f(0x143)][_0x166b3f(0x180)][_0x166b3f(0x1a7)]();}catch{}};})['then'](_0x2a47ca=>(this[_0x560b0e(0x17c)]=!0x0,this[_0x560b0e(0x107)]=!0x1,this['_allowedToConnectOnSend']=!0x1,this[_0x560b0e(0x1b9)]=!0x0,this[_0x560b0e(0x112)]=0x0,_0x2a47ca))[_0x560b0e(0x13f)](_0x449b17=>(this['_connected']=!0x1,this[_0x560b0e(0x107)]=!0x1,_0x5b7758(new Error(_0x560b0e(0x1ce)+(_0x449b17&&_0x449b17[_0x560b0e(0x155)])))));}));}[_0x5c041f(0x135)](_0x11dfe2){var _0x35b03a=_0x5c041f;this[_0x35b03a(0x17c)]=!0x1,this['_connecting']=!0x1;try{_0x11dfe2['onclose']=null,_0x11dfe2[_0x35b03a(0x1c9)]=null,_0x11dfe2['onopen']=null;}catch{}try{_0x11dfe2[_0x35b03a(0x15d)]<0x2&&_0x11dfe2[_0x35b03a(0x13c)]();}catch{}}[_0x5c041f(0x175)](){var _0x31aeaf=_0x5c041f;clearTimeout(this[_0x31aeaf(0x1d0)]),!(this[_0x31aeaf(0x112)]>=this[_0x31aeaf(0x1b1)])&&(this[_0x31aeaf(0x1d0)]=setTimeout(()=>{var _0x395757=_0x31aeaf;this[_0x395757(0x17c)]||this['_connecting']||(this['_connectToHostNow'](),this[_0x395757(0x156)]?.[_0x395757(0x13f)](()=>this['_attemptToReconnectShortly']()));},0x1f4),this[_0x31aeaf(0x1d0)][_0x31aeaf(0x1c8)]&&this[_0x31aeaf(0x1d0)][_0x31aeaf(0x1c8)]());}async['send'](_0x353d6f){var _0x36feac=_0x5c041f;try{if(!this[_0x36feac(0x1b9)])return;this[_0x36feac(0x1cd)]&&this[_0x36feac(0x1b5)](),(await this[_0x36feac(0x156)])['send'](JSON[_0x36feac(0x183)](_0x353d6f));}catch(_0xea0863){console[_0x36feac(0x137)](this[_0x36feac(0x159)]+':\\\\x20'+(_0xea0863&&_0xea0863[_0x36feac(0x155)])),this[_0x36feac(0x1b9)]=!0x1,this[_0x36feac(0x175)]();}}};function V(_0x316ec2,_0x37b6b9,_0x242e78,_0x2a8d2f,_0x23fccf){var _0x12a29b=_0x5c041f;let _0xd77357=_0x242e78[_0x12a29b(0x1cc)](',')['map'](_0xe82dc7=>{var _0x319735=_0x12a29b;try{_0x316ec2[_0x319735(0x1d6)]||((_0x23fccf===_0x319735(0x140)||_0x23fccf===_0x319735(0x1cf)||_0x23fccf===_0x319735(0x1dd))&&(_0x23fccf+=_0x316ec2['process']?.[_0x319735(0x168)]?.['node']?_0x319735(0x1a1):_0x319735(0x150)),_0x316ec2[_0x319735(0x1d6)]={'id':+new Date(),'tool':_0x23fccf});let _0x16f072=new Q(_0x316ec2,_0x37b6b9,_0xe82dc7,_0x2a8d2f);return _0x16f072[_0x319735(0x1b0)]['bind'](_0x16f072);}catch(_0x5c7fa8){return console[_0x319735(0x137)](_0x319735(0x10a),_0x5c7fa8&&_0x5c7fa8[_0x319735(0x155)]),()=>{};}});return _0x502d2e=>_0xd77357[_0x12a29b(0x1ab)](_0x43bc6b=>_0x43bc6b(_0x502d2e));}function H(_0x5af7b2){var _0x44da05=_0x5c041f;let _0x4d0c7c=function(_0x2df01d,_0x18687f){return _0x18687f-_0x2df01d;},_0x5b3ffd;if(_0x5af7b2['performance'])_0x5b3ffd=function(){var _0x18cc82=_0x4cb1;return _0x5af7b2[_0x18cc82(0x187)][_0x18cc82(0x1b8)]();};else{if(_0x5af7b2[_0x44da05(0x1a3)]&&_0x5af7b2[_0x44da05(0x1a3)]['hrtime'])_0x5b3ffd=function(){var _0x36a33e=_0x44da05;return _0x5af7b2['process'][_0x36a33e(0x104)]();},_0x4d0c7c=function(_0x17a6ca,_0x1ffd49){return 0x3e8*(_0x1ffd49[0x0]-_0x17a6ca[0x0])+(_0x1ffd49[0x1]-_0x17a6ca[0x1])/0xf4240;};else try{let {performance:_0x280329}=require('perf_hooks');_0x5b3ffd=function(){return _0x280329['now']();};}catch{_0x5b3ffd=function(){return+new Date();};}}return{'elapsed':_0x4d0c7c,'timeStamp':_0x5b3ffd,'now':()=>Date['now']()};}function X(_0x12e8bd,_0x14d6a9,_0xacee0b){var _0x30debf=_0x5c041f;if(_0x12e8bd[_0x30debf(0x14a)]!==void 0x0)return _0x12e8bd[_0x30debf(0x14a)];let _0x3a35d6=_0x12e8bd[_0x30debf(0x1a3)]?.[_0x30debf(0x168)]?.[_0x30debf(0x1da)];return _0x3a35d6&&_0xacee0b===_0x30debf(0x147)?_0x12e8bd['_consoleNinjaAllowedToStart']=!0x1:_0x12e8bd[_0x30debf(0x14a)]=_0x3a35d6||!_0x14d6a9||_0x12e8bd[_0x30debf(0x180)]?.[_0x30debf(0x13b)]&&_0x14d6a9[_0x30debf(0x18d)](_0x12e8bd[_0x30debf(0x180)][_0x30debf(0x13b)]),_0x12e8bd[_0x30debf(0x14a)];}function _0x382e(){var _0x3f78a3=['_setNodeExpressionPath','location','WebSocket','bigint','stringify','substr','ws://','_WebSocketClass','performance','stackTraceLimit','type','1.0.0','_console_ninja','_isUndefined','includes','[object\\\\x20BigInt]','autoExpandMaxDepth','timeEnd','__es'+'Module','parent','_type','635201aILuEg','Map','_setNodeQueryPath','call',[\\\"localhost\\\",\\\"127.0.0.1\\\",\\\"example.cypress.io\\\",\\\"csys\\\",\\\"192.168.178.20\\\"],'NEGATIVE_INFINITY','_undefined','webpack','Console\\\\x20Ninja\\\\x20failed\\\\x20to\\\\x20send\\\\x20logs,\\\\x20refreshing\\\\x20the\\\\x20page\\\\x20may\\\\x20help','disabledLog','reduceLimits','_getOwnPropertyNames','280CWoCPm','\\\\x20server','hasOwnProperty','process','HTMLAllCollection','[object\\\\x20Set]','console','reload','54LRIPsv','argumentResolutionError','value','forEach','push','_property','_treeNodePropertiesAfterFullValue','data','send','_maxConnectAttemptCount','935776dwgaDu','sortProps','64072xQAqIr','_connectToHostNow','log','autoExpand','now','_allowedToSend','slice','count','negativeInfinity','_WebSocket','constructor','hits','_getOwnPropertyDescriptor','date','_isPrimitiveType','_addFunctionsNode','root_exp','function','default','valueOf','unref','onerror','cappedElements','number','split','_allowedToConnectOnSend','failed\\\\x20to\\\\x20connect\\\\x20to\\\\x20host:\\\\x20','remix','_reconnectTimeout','object','parse','enumerable','_cleanNode','_quotedRegExp','_console_ninja_session','','_capIfString','Set','node','[object\\\\x20Map]','_isPrimitiveWrapperType','astro','replace','path','elements','concat','[object\\\\x20Array]','undefined','_blacklistedProperty','match','root_exp_id','_isNegativeZero','hrtime','String','_numberRegExp','_connecting','current','_keyStrRegExp','logger\\\\x20failed\\\\x20to\\\\x20connect\\\\x20to\\\\x20host','_setNodeId','pathToFileURL','level','Number','autoExpandPreviousObjects','name','serialize','_connectAttemptCount','nodeModules','RegExp','_propertyName','trace','expressionsToEvaluate','...','_socket','indexOf','_addLoadNode','method','autoExpandPropertyCount','unshift','props','_p_length','Console\\\\x20Ninja\\\\x20failed\\\\x20to\\\\x20send\\\\x20logs,\\\\x20restarting\\\\x20the\\\\x20process\\\\x20may\\\\x20help','capped','length','127.0.0.1','pop','array','_treeNodePropertiesBeforeFullValue','failed\\\\x20to\\\\x20find\\\\x20and\\\\x20load\\\\x20WebSocket','isExpressionToEvaluate','_addProperty','error','totalStrLength','autoExpandLimit','negativeZero','onclose','getWebSocketClass','_regExpToString','isArray',':logPointId:','_setNodePermissions','_disposeWebsocket','7576168RoOoLU','warn','url','getOwnPropertySymbols','_hasSetOnItsPath','hostname','close','_additionalMetadata','strLength','catch','next.js','rootExpression','getOwnPropertyDescriptor','global','symbol','boolean','_inBrowser','nuxt','time','[object\\\\x20Date]','_consoleNinjaAllowedToStart','depth','Error','positiveInfinity','string','prototype','\\\\x20browser','_addObjectProperty','_p_','join','_sortProps','message','_ws','_isMap','noFunctions','_sendErrorMessage','_Symbol','_setNodeExpandableState','getOwnPropertyNames','readyState','_objectToString','onopen','51961','_hasMapOnItsPath','elapsed','index','nan','resolveGetters','test','_HTMLAllCollection','versions','_setNodeLabel','null','toLowerCase','_isSet','_dateToString','1039862BHuYnR','disabledTrace','1272669ZnImvB','expId','_isArray','unknown',\\\"c:\\\\\\\\Users\\\\\\\\c\\\\\\\\.vscode\\\\\\\\extensions\\\\\\\\wallabyjs.console-ninja-0.0.154\\\\\\\\node_modules\\\",'_attemptToReconnectShortly','onmessage','Symbol','toString','19315575hkRJHr','_processTreeNodeResult','allStrLength','_connected','1687331417795','port'];_0x382e=function(){return _0x3f78a3;};return _0x382e();}((_0x5b4790,_0x458f21,_0x149466,_0x506ad4,_0x4f07aa,_0x3fd8d0,_0x20a513,_0x2e806b,_0x2df5e3)=>{var _0x27b5f4=_0x5c041f;if(_0x5b4790['_console_ninja'])return _0x5b4790['_console_ninja'];if(!X(_0x5b4790,_0x2e806b,_0x4f07aa))return _0x5b4790[_0x27b5f4(0x18b)]={'consoleLog':()=>{},'consoleTrace':()=>{},'consoleTime':()=>{},'consoleTimeEnd':()=>{},'autoLog':()=>{},'autoTrace':()=>{},'autoTime':()=>{},'autoTimeEnd':()=>{}},_0x5b4790[_0x27b5f4(0x18b)];let _0x538d0c={'props':0x64,'elements':0x64,'strLength':0x400*0x32,'totalStrLength':0x400*0x32,'autoExpandLimit':0x1388,'autoExpandMaxDepth':0xa},_0x5df0c1={'props':0x5,'elements':0x5,'strLength':0x100,'totalStrLength':0x100*0x3,'autoExpandLimit':0x1e,'autoExpandMaxDepth':0x2},_0xe984aa=H(_0x5b4790),_0x272fdc=_0xe984aa[_0x27b5f4(0x162)],_0x4d049a=_0xe984aa['timeStamp'],_0x2f3f4d=_0xe984aa['now'],_0xe1c80c={'hits':{},'ts':{}},_0x3d77ad=_0x1f3b96=>{_0xe1c80c['ts'][_0x1f3b96]=_0x4d049a();},_0xe06796=(_0x13f02a,_0x2be50f)=>{let _0x40e934=_0xe1c80c['ts'][_0x2be50f];if(delete _0xe1c80c['ts'][_0x2be50f],_0x40e934){let _0x5274bc=_0x272fdc(_0x40e934,_0x4d049a());_0x4b1f73(_0x4ef4d5('time',_0x13f02a,_0x2f3f4d(),_0x5ef367,[_0x5274bc],_0x2be50f));}},_0x47ca51=_0x35ae2c=>_0x568830=>{var _0x5cbfae=_0x27b5f4;try{_0x3d77ad(_0x568830),_0x35ae2c(_0x568830);}finally{_0x5b4790[_0x5cbfae(0x1a6)]['time']=_0x35ae2c;}},_0x34454b=_0x46ef29=>_0x2cac3c=>{var _0x4e0ff3=_0x27b5f4;try{let [_0x38e816,_0xa70aed]=_0x2cac3c[_0x4e0ff3(0x1cc)](_0x4e0ff3(0x133));_0xe06796(_0xa70aed,_0x38e816),_0x46ef29(_0x38e816);}finally{_0x5b4790['console'][_0x4e0ff3(0x190)]=_0x46ef29;}};_0x5b4790['_console_ninja']={'consoleLog':(_0xbf4b2a,_0x4ee11d)=>{var _0x27c615=_0x27b5f4;_0x5b4790[_0x27c615(0x1a6)][_0x27c615(0x1b6)][_0x27c615(0x110)]!==_0x27c615(0x19d)&&_0x4b1f73(_0x4ef4d5(_0x27c615(0x1b6),_0xbf4b2a,_0x2f3f4d(),_0x5ef367,_0x4ee11d));},'consoleTrace':(_0x380929,_0x5c69db)=>{var _0x2e9541=_0x27b5f4;_0x5b4790[_0x2e9541(0x1a6)][_0x2e9541(0x1b6)][_0x2e9541(0x110)]!==_0x2e9541(0x16f)&&_0x4b1f73(_0x4ef4d5(_0x2e9541(0x116),_0x380929,_0x2f3f4d(),_0x5ef367,_0x5c69db));},'consoleTime':()=>{var _0xac082f=_0x27b5f4;_0x5b4790[_0xac082f(0x1a6)][_0xac082f(0x148)]=_0x47ca51(_0x5b4790[_0xac082f(0x1a6)][_0xac082f(0x148)]);},'consoleTimeEnd':()=>{var _0x3a096b=_0x27b5f4;_0x5b4790['console'][_0x3a096b(0x190)]=_0x34454b(_0x5b4790[_0x3a096b(0x1a6)][_0x3a096b(0x190)]);},'autoLog':(_0x400d6e,_0x1ef64c)=>{_0x4b1f73(_0x4ef4d5('log',_0x1ef64c,_0x2f3f4d(),_0x5ef367,[_0x400d6e]));},'autoTrace':(_0x5e343b,_0x2b5d86)=>{var _0x53ff97=_0x27b5f4;_0x4b1f73(_0x4ef4d5(_0x53ff97(0x116),_0x2b5d86,_0x2f3f4d(),_0x5ef367,[_0x5e343b]));},'autoTime':(_0x555514,_0x466fce,_0x7d1fbf)=>{_0x3d77ad(_0x7d1fbf);},'autoTimeEnd':(_0x596063,_0x24d50a,_0x257617)=>{_0xe06796(_0x24d50a,_0x257617);}};let _0x4b1f73=V(_0x5b4790,_0x458f21,_0x149466,_0x506ad4,_0x4f07aa),_0x5ef367=_0x5b4790['_console_ninja_session'];class _0x7302f2{constructor(){var _0x2530cf=_0x27b5f4;this[_0x2530cf(0x109)]=/^(?!(?:do|if|in|for|let|new|try|var|case|else|enum|eval|false|null|this|true|void|with|break|catch|class|const|super|throw|while|yield|delete|export|import|public|return|static|switch|typeof|default|extends|finally|package|private|continue|debugger|function|arguments|interface|protected|implements|instanceof)$)[_$a-zA-Z\\\\xA0-\\\\uFFFF][_$a-zA-Z0-9\\\\xA0-\\\\uFFFF]*$/,this[_0x2530cf(0x106)]=/^(0|[1-9][0-9]*)$/,this[_0x2530cf(0x1d5)]=/'([^\\\\\\\\']|\\\\\\\\')*'/,this[_0x2530cf(0x19a)]=_0x5b4790[_0x2530cf(0x1e3)],this[_0x2530cf(0x167)]=_0x5b4790[_0x2530cf(0x1a4)],this[_0x2530cf(0x1c0)]=Object[_0x2530cf(0x142)],this[_0x2530cf(0x19f)]=Object['getOwnPropertyNames'],this[_0x2530cf(0x15a)]=_0x5b4790[_0x2530cf(0x177)],this[_0x2530cf(0x131)]=RegExp[_0x2530cf(0x14f)][_0x2530cf(0x178)],this['_dateToString']=Date['prototype'][_0x2530cf(0x178)];}[_0x27b5f4(0x111)](_0x4c4a88,_0x2bf3b0,_0x363f5d,_0x49674b){var _0x377020=_0x27b5f4,_0x277dde=this,_0x2bc8b0=_0x363f5d['autoExpand'];function _0x41b795(_0x639564,_0x42158d,_0x6a91ba){var _0x49c916=_0x4cb1;_0x42158d[_0x49c916(0x189)]=_0x49c916(0x173),_0x42158d[_0x49c916(0x12b)]=_0x639564['message'],_0x15be58=_0x6a91ba['node'][_0x49c916(0x108)],_0x6a91ba[_0x49c916(0x1da)][_0x49c916(0x108)]=_0x42158d,_0x277dde[_0x49c916(0x127)](_0x42158d,_0x6a91ba);}if(_0x2bf3b0&&_0x2bf3b0[_0x377020(0x1a9)])_0x41b795(_0x2bf3b0,_0x4c4a88,_0x363f5d);else try{_0x363f5d[_0x377020(0x10d)]++,_0x363f5d[_0x377020(0x1b7)]&&_0x363f5d[_0x377020(0x10f)]['push'](_0x2bf3b0);var _0x18fcbd,_0x433fb1,_0x474096,_0x5d1925,_0x4376b6=[],_0x410b80=[],_0x1c2cde,_0x4e4ecd=this[_0x377020(0x193)](_0x2bf3b0),_0x4ab547=_0x4e4ecd==='array',_0x1715f4=!0x1,_0x2b510e=_0x4e4ecd==='function',_0x33450e=this[_0x377020(0x1c2)](_0x4e4ecd),_0x1a4f47=this[_0x377020(0x1dc)](_0x4e4ecd),_0x51c872=_0x33450e||_0x1a4f47,_0x5bab85={},_0xeee57b=0x0,_0x3447ef=!0x1,_0x15be58,_0x2144f8=/^(([1-9]{1}[0-9]*)|0)$/;if(_0x363f5d[_0x377020(0x14b)]){if(_0x4ab547){if(_0x433fb1=_0x2bf3b0[_0x377020(0x123)],_0x433fb1>_0x363f5d['elements']){for(_0x474096=0x0,_0x5d1925=_0x363f5d[_0x377020(0x1e0)],_0x18fcbd=_0x474096;_0x18fcbd<_0x5d1925;_0x18fcbd++)_0x410b80[_0x377020(0x1ac)](_0x277dde[_0x377020(0x12a)](_0x4376b6,_0x2bf3b0,_0x4e4ecd,_0x18fcbd,_0x363f5d));_0x4c4a88[_0x377020(0x1ca)]=!0x0;}else{for(_0x474096=0x0,_0x5d1925=_0x433fb1,_0x18fcbd=_0x474096;_0x18fcbd<_0x5d1925;_0x18fcbd++)_0x410b80[_0x377020(0x1ac)](_0x277dde[_0x377020(0x12a)](_0x4376b6,_0x2bf3b0,_0x4e4ecd,_0x18fcbd,_0x363f5d));}_0x363f5d[_0x377020(0x11d)]+=_0x410b80[_0x377020(0x123)];}if(!(_0x4e4ecd===_0x377020(0x16a)||_0x4e4ecd===_0x377020(0x1e3))&&!_0x33450e&&_0x4e4ecd!==_0x377020(0x105)&&_0x4e4ecd!=='Buffer'&&_0x4e4ecd!==_0x377020(0x182)){var _0x42c5c6=_0x49674b[_0x377020(0x11f)]||_0x363f5d[_0x377020(0x11f)];if(this[_0x377020(0x16c)](_0x2bf3b0)?(_0x18fcbd=0x0,_0x2bf3b0[_0x377020(0x1ab)](function(_0x387777){var _0x5be22f=_0x377020;if(_0xeee57b++,_0x363f5d[_0x5be22f(0x11d)]++,_0xeee57b>_0x42c5c6){_0x3447ef=!0x0;return;}if(!_0x363f5d[_0x5be22f(0x129)]&&_0x363f5d[_0x5be22f(0x1b7)]&&_0x363f5d[_0x5be22f(0x11d)]>_0x363f5d[_0x5be22f(0x12d)]){_0x3447ef=!0x0;return;}_0x410b80[_0x5be22f(0x1ac)](_0x277dde[_0x5be22f(0x12a)](_0x4376b6,_0x2bf3b0,_0x5be22f(0x1d9),_0x18fcbd++,_0x363f5d,function(_0x2a9834){return function(){return _0x2a9834;};}(_0x387777)));})):this['_isMap'](_0x2bf3b0)&&_0x2bf3b0[_0x377020(0x1ab)](function(_0x316b01,_0x47e14e){var _0x48f2d9=_0x377020;if(_0xeee57b++,_0x363f5d[_0x48f2d9(0x11d)]++,_0xeee57b>_0x42c5c6){_0x3447ef=!0x0;return;}if(!_0x363f5d[_0x48f2d9(0x129)]&&_0x363f5d[_0x48f2d9(0x1b7)]&&_0x363f5d[_0x48f2d9(0x11d)]>_0x363f5d[_0x48f2d9(0x12d)]){_0x3447ef=!0x0;return;}var _0x3e2f2f=_0x47e14e[_0x48f2d9(0x178)]();_0x3e2f2f[_0x48f2d9(0x123)]>0x64&&(_0x3e2f2f=_0x3e2f2f[_0x48f2d9(0x1ba)](0x0,0x64)+_0x48f2d9(0x118)),_0x410b80[_0x48f2d9(0x1ac)](_0x277dde[_0x48f2d9(0x12a)](_0x4376b6,_0x2bf3b0,_0x48f2d9(0x195),_0x3e2f2f,_0x363f5d,function(_0x2f0290){return function(){return _0x2f0290;};}(_0x316b01)));}),!_0x1715f4){try{for(_0x1c2cde in _0x2bf3b0)if(!(_0x4ab547&&_0x2144f8[_0x377020(0x166)](_0x1c2cde))&&!this[_0x377020(0x1e4)](_0x2bf3b0,_0x1c2cde,_0x363f5d)){if(_0xeee57b++,_0x363f5d[_0x377020(0x11d)]++,_0xeee57b>_0x42c5c6){_0x3447ef=!0x0;break;}if(!_0x363f5d['isExpressionToEvaluate']&&_0x363f5d[_0x377020(0x1b7)]&&_0x363f5d['autoExpandPropertyCount']>_0x363f5d[_0x377020(0x12d)]){_0x3447ef=!0x0;break;}_0x410b80[_0x377020(0x1ac)](_0x277dde[_0x377020(0x151)](_0x4376b6,_0x5bab85,_0x2bf3b0,_0x4e4ecd,_0x1c2cde,_0x363f5d));}}catch{}if(_0x5bab85[_0x377020(0x120)]=!0x0,_0x2b510e&&(_0x5bab85['_p_name']=!0x0),!_0x3447ef){var _0x591c0f=[][_0x377020(0x1e1)](this[_0x377020(0x19f)](_0x2bf3b0))['concat'](this['_getOwnPropertySymbols'](_0x2bf3b0));for(_0x18fcbd=0x0,_0x433fb1=_0x591c0f['length'];_0x18fcbd<_0x433fb1;_0x18fcbd++)if(_0x1c2cde=_0x591c0f[_0x18fcbd],!(_0x4ab547&&_0x2144f8[_0x377020(0x166)](_0x1c2cde[_0x377020(0x178)]()))&&!this['_blacklistedProperty'](_0x2bf3b0,_0x1c2cde,_0x363f5d)&&!_0x5bab85['_p_'+_0x1c2cde[_0x377020(0x178)]()]){if(_0xeee57b++,_0x363f5d[_0x377020(0x11d)]++,_0xeee57b>_0x42c5c6){_0x3447ef=!0x0;break;}if(!_0x363f5d[_0x377020(0x129)]&&_0x363f5d[_0x377020(0x1b7)]&&_0x363f5d[_0x377020(0x11d)]>_0x363f5d[_0x377020(0x12d)]){_0x3447ef=!0x0;break;}_0x410b80[_0x377020(0x1ac)](_0x277dde['_addObjectProperty'](_0x4376b6,_0x5bab85,_0x2bf3b0,_0x4e4ecd,_0x1c2cde,_0x363f5d));}}}}}if(_0x4c4a88[_0x377020(0x189)]=_0x4e4ecd,_0x51c872?(_0x4c4a88[_0x377020(0x1aa)]=_0x2bf3b0[_0x377020(0x1c7)](),this[_0x377020(0x1d8)](_0x4e4ecd,_0x4c4a88,_0x363f5d,_0x49674b)):_0x4e4ecd===_0x377020(0x1c1)?_0x4c4a88[_0x377020(0x1aa)]=this[_0x377020(0x16d)][_0x377020(0x197)](_0x2bf3b0):_0x4e4ecd==='bigint'?_0x4c4a88[_0x377020(0x1aa)]=_0x2bf3b0[_0x377020(0x178)]():_0x4e4ecd===_0x377020(0x114)?_0x4c4a88['value']=this['_regExpToString'][_0x377020(0x197)](_0x2bf3b0):_0x4e4ecd===_0x377020(0x144)&&this['_Symbol']?_0x4c4a88[_0x377020(0x1aa)]=this[_0x377020(0x15a)][_0x377020(0x14f)]['toString']['call'](_0x2bf3b0):!_0x363f5d[_0x377020(0x14b)]&&!(_0x4e4ecd===_0x377020(0x16a)||_0x4e4ecd===_0x377020(0x1e3))&&(delete _0x4c4a88[_0x377020(0x1aa)],_0x4c4a88[_0x377020(0x122)]=!0x0),_0x3447ef&&(_0x4c4a88['cappedProps']=!0x0),_0x15be58=_0x363f5d[_0x377020(0x1da)][_0x377020(0x108)],_0x363f5d['node'][_0x377020(0x108)]=_0x4c4a88,this['_treeNodePropertiesBeforeFullValue'](_0x4c4a88,_0x363f5d),_0x410b80[_0x377020(0x123)]){for(_0x18fcbd=0x0,_0x433fb1=_0x410b80[_0x377020(0x123)];_0x18fcbd<_0x433fb1;_0x18fcbd++)_0x410b80[_0x18fcbd](_0x18fcbd);}_0x4376b6[_0x377020(0x123)]&&(_0x4c4a88['props']=_0x4376b6);}catch(_0x1fa9b2){_0x41b795(_0x1fa9b2,_0x4c4a88,_0x363f5d);}return this[_0x377020(0x13d)](_0x2bf3b0,_0x4c4a88),this[_0x377020(0x1ae)](_0x4c4a88,_0x363f5d),_0x363f5d[_0x377020(0x1da)]['current']=_0x15be58,_0x363f5d['level']--,_0x363f5d[_0x377020(0x1b7)]=_0x2bc8b0,_0x363f5d[_0x377020(0x1b7)]&&_0x363f5d['autoExpandPreviousObjects'][_0x377020(0x125)](),_0x4c4a88;}['_getOwnPropertySymbols'](_0xb5846){var _0x52041f=_0x27b5f4;return Object['getOwnPropertySymbols']?Object[_0x52041f(0x139)](_0xb5846):[];}[_0x27b5f4(0x16c)](_0x5282f4){var _0x3228cc=_0x27b5f4;return!!(_0x5282f4&&_0x5b4790[_0x3228cc(0x1d9)]&&this[_0x3228cc(0x15e)](_0x5282f4)===_0x3228cc(0x1a5)&&_0x5282f4[_0x3228cc(0x1ab)]);}['_blacklistedProperty'](_0x3e1e02,_0x19f7da,_0x2ed27d){var _0x3d5f32=_0x27b5f4;return _0x2ed27d[_0x3d5f32(0x158)]?typeof _0x3e1e02[_0x19f7da]==_0x3d5f32(0x1c5):!0x1;}[_0x27b5f4(0x193)](_0x1d8bce){var _0xf22702=_0x27b5f4,_0x8f3c98='';return _0x8f3c98=typeof _0x1d8bce,_0x8f3c98==='object'?this[_0xf22702(0x15e)](_0x1d8bce)===_0xf22702(0x1e2)?_0x8f3c98=_0xf22702(0x126):this[_0xf22702(0x15e)](_0x1d8bce)===_0xf22702(0x149)?_0x8f3c98=_0xf22702(0x1c1):this[_0xf22702(0x15e)](_0x1d8bce)===_0xf22702(0x18e)?_0x8f3c98='bigint':_0x1d8bce===null?_0x8f3c98=_0xf22702(0x16a):_0x1d8bce['constructor']&&(_0x8f3c98=_0x1d8bce[_0xf22702(0x1be)][_0xf22702(0x110)]||_0x8f3c98):_0x8f3c98===_0xf22702(0x1e3)&&this['_HTMLAllCollection']&&_0x1d8bce instanceof this['_HTMLAllCollection']&&(_0x8f3c98='HTMLAllCollection'),_0x8f3c98;}['_objectToString'](_0x362d66){var _0x3c798c=_0x27b5f4;return Object[_0x3c798c(0x14f)][_0x3c798c(0x178)][_0x3c798c(0x197)](_0x362d66);}['_isPrimitiveType'](_0x291f7d){var _0x5359d4=_0x27b5f4;return _0x291f7d===_0x5359d4(0x145)||_0x291f7d===_0x5359d4(0x14e)||_0x291f7d==='number';}[_0x27b5f4(0x1dc)](_0x4cbff7){var _0x3ee85a=_0x27b5f4;return _0x4cbff7==='Boolean'||_0x4cbff7===_0x3ee85a(0x105)||_0x4cbff7===_0x3ee85a(0x10e);}['_addProperty'](_0x2378df,_0x35fcbe,_0x1b181f,_0xaf562b,_0xd53cb8,_0x399f00){var _0x452e20=this;return function(_0x144d49){var _0x201876=_0x4cb1,_0x46a7c6=_0xd53cb8[_0x201876(0x1da)][_0x201876(0x108)],_0x3d1f64=_0xd53cb8[_0x201876(0x1da)][_0x201876(0x163)],_0x411984=_0xd53cb8['node'][_0x201876(0x192)];_0xd53cb8[_0x201876(0x1da)][_0x201876(0x192)]=_0x46a7c6,_0xd53cb8['node'][_0x201876(0x163)]=typeof _0xaf562b==_0x201876(0x1cb)?_0xaf562b:_0x144d49,_0x2378df['push'](_0x452e20['_property'](_0x35fcbe,_0x1b181f,_0xaf562b,_0xd53cb8,_0x399f00)),_0xd53cb8[_0x201876(0x1da)][_0x201876(0x192)]=_0x411984,_0xd53cb8['node'][_0x201876(0x163)]=_0x3d1f64;};}[_0x27b5f4(0x151)](_0x447828,_0x14c2cb,_0x2514be,_0x499052,_0x3ac241,_0x50d530,_0x5931a7){var _0x5d6f85=_0x27b5f4,_0x22fac8=this;return _0x14c2cb[_0x5d6f85(0x152)+_0x3ac241[_0x5d6f85(0x178)]()]=!0x0,function(_0x2163ab){var _0x46ef79=_0x5d6f85,_0x4e6994=_0x50d530['node'][_0x46ef79(0x108)],_0x379fad=_0x50d530[_0x46ef79(0x1da)][_0x46ef79(0x163)],_0x4648ab=_0x50d530[_0x46ef79(0x1da)]['parent'];_0x50d530[_0x46ef79(0x1da)][_0x46ef79(0x192)]=_0x4e6994,_0x50d530[_0x46ef79(0x1da)][_0x46ef79(0x163)]=_0x2163ab,_0x447828[_0x46ef79(0x1ac)](_0x22fac8[_0x46ef79(0x1ad)](_0x2514be,_0x499052,_0x3ac241,_0x50d530,_0x5931a7)),_0x50d530[_0x46ef79(0x1da)]['parent']=_0x4648ab,_0x50d530['node']['index']=_0x379fad;};}[_0x27b5f4(0x1ad)](_0x11ba45,_0x2c8472,_0x75afa4,_0xef2682,_0x2e97cf){var _0x5d139e=_0x27b5f4,_0x2f2ead=this;_0x2e97cf||(_0x2e97cf=function(_0x2f3675,_0x36e0f8){return _0x2f3675[_0x36e0f8];});var _0x1d0670=_0x75afa4['toString'](),_0x127b27=_0xef2682['expressionsToEvaluate']||{},_0x3818ef=_0xef2682[_0x5d139e(0x14b)],_0x501535=_0xef2682[_0x5d139e(0x129)];try{var _0x1654e3=this[_0x5d139e(0x157)](_0x11ba45),_0x22d9d0=_0x1d0670;_0x1654e3&&_0x22d9d0[0x0]==='\\\\x27'&&(_0x22d9d0=_0x22d9d0[_0x5d139e(0x184)](0x1,_0x22d9d0[_0x5d139e(0x123)]-0x2));var _0x10bfe0=_0xef2682[_0x5d139e(0x117)]=_0x127b27[_0x5d139e(0x152)+_0x22d9d0];_0x10bfe0&&(_0xef2682[_0x5d139e(0x14b)]=_0xef2682['depth']+0x1),_0xef2682[_0x5d139e(0x129)]=!!_0x10bfe0;var _0x108f45=typeof _0x75afa4==_0x5d139e(0x144),_0x289b97={'name':_0x108f45||_0x1654e3?_0x1d0670:this[_0x5d139e(0x115)](_0x1d0670)};if(_0x108f45&&(_0x289b97[_0x5d139e(0x144)]=!0x0),!(_0x2c8472===_0x5d139e(0x126)||_0x2c8472===_0x5d139e(0x14c))){var _0x2bf7ad=this[_0x5d139e(0x1c0)](_0x11ba45,_0x75afa4);if(_0x2bf7ad&&(_0x2bf7ad['set']&&(_0x289b97['setter']=!0x0),_0x2bf7ad['get']&&!_0x10bfe0&&!_0xef2682[_0x5d139e(0x165)]))return _0x289b97['getter']=!0x0,this[_0x5d139e(0x17a)](_0x289b97,_0xef2682),_0x289b97;}var _0x1f14f8;try{_0x1f14f8=_0x2e97cf(_0x11ba45,_0x75afa4);}catch(_0x309f6f){return _0x289b97={'name':_0x1d0670,'type':_0x5d139e(0x173),'error':_0x309f6f[_0x5d139e(0x155)]},this['_processTreeNodeResult'](_0x289b97,_0xef2682),_0x289b97;}var _0x19f7d6=this[_0x5d139e(0x193)](_0x1f14f8),_0x21be7b=this[_0x5d139e(0x1c2)](_0x19f7d6);if(_0x289b97[_0x5d139e(0x189)]=_0x19f7d6,_0x21be7b)this['_processTreeNodeResult'](_0x289b97,_0xef2682,_0x1f14f8,function(){var _0x24bfe4=_0x5d139e;_0x289b97[_0x24bfe4(0x1aa)]=_0x1f14f8[_0x24bfe4(0x1c7)](),!_0x10bfe0&&_0x2f2ead[_0x24bfe4(0x1d8)](_0x19f7d6,_0x289b97,_0xef2682,{});});else{var _0x24f667=_0xef2682['autoExpand']&&_0xef2682['level']<_0xef2682[_0x5d139e(0x18f)]&&_0xef2682[_0x5d139e(0x10f)][_0x5d139e(0x11a)](_0x1f14f8)<0x0&&_0x19f7d6!==_0x5d139e(0x1c5)&&_0xef2682[_0x5d139e(0x11d)]<_0xef2682['autoExpandLimit'];_0x24f667||_0xef2682['level']<_0x3818ef||_0x10bfe0?(this[_0x5d139e(0x111)](_0x289b97,_0x1f14f8,_0xef2682,_0x10bfe0||{}),this[_0x5d139e(0x13d)](_0x1f14f8,_0x289b97)):this['_processTreeNodeResult'](_0x289b97,_0xef2682,_0x1f14f8,function(){var _0x55b27e=_0x5d139e;_0x19f7d6===_0x55b27e(0x16a)||_0x19f7d6==='undefined'||(delete _0x289b97[_0x55b27e(0x1aa)],_0x289b97['capped']=!0x0);});}return _0x289b97;}finally{_0xef2682[_0x5d139e(0x117)]=_0x127b27,_0xef2682[_0x5d139e(0x14b)]=_0x3818ef,_0xef2682[_0x5d139e(0x129)]=_0x501535;}}[_0x27b5f4(0x1d8)](_0x345b2b,_0x37826c,_0x493a0b,_0x5bbe39){var _0x41c5d3=_0x27b5f4,_0x4e7ce2=_0x5bbe39[_0x41c5d3(0x13e)]||_0x493a0b[_0x41c5d3(0x13e)];if((_0x345b2b==='string'||_0x345b2b==='String')&&_0x37826c[_0x41c5d3(0x1aa)]){let _0x58e7f0=_0x37826c['value'][_0x41c5d3(0x123)];_0x493a0b[_0x41c5d3(0x17b)]+=_0x58e7f0,_0x493a0b[_0x41c5d3(0x17b)]>_0x493a0b['totalStrLength']?(_0x37826c[_0x41c5d3(0x122)]='',delete _0x37826c[_0x41c5d3(0x1aa)]):_0x58e7f0>_0x4e7ce2&&(_0x37826c[_0x41c5d3(0x122)]=_0x37826c[_0x41c5d3(0x1aa)][_0x41c5d3(0x184)](0x0,_0x4e7ce2),delete _0x37826c[_0x41c5d3(0x1aa)]);}}[_0x27b5f4(0x157)](_0x27e462){var _0x52af29=_0x27b5f4;return!!(_0x27e462&&_0x5b4790[_0x52af29(0x195)]&&this[_0x52af29(0x15e)](_0x27e462)===_0x52af29(0x1db)&&_0x27e462[_0x52af29(0x1ab)]);}['_propertyName'](_0x4009b0){var _0xaac64b=_0x27b5f4;if(_0x4009b0[_0xaac64b(0x1e5)](/^\\\\d+$/))return _0x4009b0;var _0x3df4b1;try{_0x3df4b1=JSON[_0xaac64b(0x183)](''+_0x4009b0);}catch{_0x3df4b1='\\\\x22'+this[_0xaac64b(0x15e)](_0x4009b0)+'\\\\x22';}return _0x3df4b1[_0xaac64b(0x1e5)](/^\\\"([a-zA-Z_][a-zA-Z_0-9]*)\\\"$/)?_0x3df4b1=_0x3df4b1['substr'](0x1,_0x3df4b1[_0xaac64b(0x123)]-0x2):_0x3df4b1=_0x3df4b1[_0xaac64b(0x1de)](/'/g,'\\\\x5c\\\\x27')[_0xaac64b(0x1de)](/\\\\\\\\\\\"/g,'\\\\x22')[_0xaac64b(0x1de)](/(^\\\"|\\\"$)/g,'\\\\x27'),_0x3df4b1;}['_processTreeNodeResult'](_0x19824d,_0x5c5e8f,_0x1680fa,_0x5b0779){var _0x3d2550=_0x27b5f4;this['_treeNodePropertiesBeforeFullValue'](_0x19824d,_0x5c5e8f),_0x5b0779&&_0x5b0779(),this[_0x3d2550(0x13d)](_0x1680fa,_0x19824d),this[_0x3d2550(0x1ae)](_0x19824d,_0x5c5e8f);}[_0x27b5f4(0x127)](_0x5aff2e,_0x47d2f7){var _0x5cd962=_0x27b5f4;this[_0x5cd962(0x10b)](_0x5aff2e,_0x47d2f7),this[_0x5cd962(0x196)](_0x5aff2e,_0x47d2f7),this[_0x5cd962(0x17f)](_0x5aff2e,_0x47d2f7),this[_0x5cd962(0x134)](_0x5aff2e,_0x47d2f7);}['_setNodeId'](_0x452ae7,_0x297f1b){}[_0x27b5f4(0x196)](_0xece9cb,_0x4e0399){}['_setNodeLabel'](_0x2c0a1b,_0x23ac11){}[_0x27b5f4(0x18c)](_0x41f0d5){var _0x5db41b=_0x27b5f4;return _0x41f0d5===this[_0x5db41b(0x19a)];}[_0x27b5f4(0x1ae)](_0x327dda,_0x2ed747){var _0x28aea0=_0x27b5f4;this['_setNodeLabel'](_0x327dda,_0x2ed747),this[_0x28aea0(0x15b)](_0x327dda),_0x2ed747['sortProps']&&this[_0x28aea0(0x154)](_0x327dda),this[_0x28aea0(0x1c3)](_0x327dda,_0x2ed747),this[_0x28aea0(0x11b)](_0x327dda,_0x2ed747),this[_0x28aea0(0x1d4)](_0x327dda);}[_0x27b5f4(0x13d)](_0x28ed57,_0x2f9ad0){var _0x2f2aa2=_0x27b5f4;try{_0x28ed57&&typeof _0x28ed57[_0x2f2aa2(0x123)]==_0x2f2aa2(0x1cb)&&(_0x2f9ad0[_0x2f2aa2(0x123)]=_0x28ed57[_0x2f2aa2(0x123)]);}catch{}if(_0x2f9ad0[_0x2f2aa2(0x189)]===_0x2f2aa2(0x1cb)||_0x2f9ad0['type']==='Number'){if(isNaN(_0x2f9ad0['value']))_0x2f9ad0[_0x2f2aa2(0x164)]=!0x0,delete _0x2f9ad0['value'];else switch(_0x2f9ad0[_0x2f2aa2(0x1aa)]){case Number['POSITIVE_INFINITY']:_0x2f9ad0[_0x2f2aa2(0x14d)]=!0x0,delete _0x2f9ad0[_0x2f2aa2(0x1aa)];break;case Number[_0x2f2aa2(0x199)]:_0x2f9ad0[_0x2f2aa2(0x1bc)]=!0x0,delete _0x2f9ad0[_0x2f2aa2(0x1aa)];break;case 0x0:this[_0x2f2aa2(0x1e7)](_0x2f9ad0[_0x2f2aa2(0x1aa)])&&(_0x2f9ad0[_0x2f2aa2(0x12e)]=!0x0);break;}}else _0x2f9ad0[_0x2f2aa2(0x189)]===_0x2f2aa2(0x1c5)&&typeof _0x28ed57[_0x2f2aa2(0x110)]=='string'&&_0x28ed57[_0x2f2aa2(0x110)]&&_0x2f9ad0[_0x2f2aa2(0x110)]&&_0x28ed57[_0x2f2aa2(0x110)]!==_0x2f9ad0['name']&&(_0x2f9ad0['funcName']=_0x28ed57[_0x2f2aa2(0x110)]);}[_0x27b5f4(0x1e7)](_0x2ebacd){return 0x1/_0x2ebacd===Number['NEGATIVE_INFINITY'];}[_0x27b5f4(0x154)](_0x33f55f){var _0x2880b5=_0x27b5f4;!_0x33f55f[_0x2880b5(0x11f)]||!_0x33f55f['props'][_0x2880b5(0x123)]||_0x33f55f[_0x2880b5(0x189)]==='array'||_0x33f55f[_0x2880b5(0x189)]===_0x2880b5(0x195)||_0x33f55f[_0x2880b5(0x189)]===_0x2880b5(0x1d9)||_0x33f55f[_0x2880b5(0x11f)]['sort'](function(_0xeb1d3d,_0x1e5ad8){var _0x465665=_0x2880b5,_0x228711=_0xeb1d3d[_0x465665(0x110)][_0x465665(0x16b)](),_0x4a8d2e=_0x1e5ad8[_0x465665(0x110)][_0x465665(0x16b)]();return _0x228711<_0x4a8d2e?-0x1:_0x228711>_0x4a8d2e?0x1:0x0;});}['_addFunctionsNode'](_0x44bb25,_0x246ec6){var _0x22ee2b=_0x27b5f4;if(!(_0x246ec6['noFunctions']||!_0x44bb25[_0x22ee2b(0x11f)]||!_0x44bb25[_0x22ee2b(0x11f)][_0x22ee2b(0x123)])){for(var _0xdec3bc=[],_0x3df253=[],_0x3979be=0x0,_0x45594a=_0x44bb25[_0x22ee2b(0x11f)][_0x22ee2b(0x123)];_0x3979be<_0x45594a;_0x3979be++){var _0x5162e2=_0x44bb25[_0x22ee2b(0x11f)][_0x3979be];_0x5162e2[_0x22ee2b(0x189)]==='function'?_0xdec3bc[_0x22ee2b(0x1ac)](_0x5162e2):_0x3df253[_0x22ee2b(0x1ac)](_0x5162e2);}if(!(!_0x3df253[_0x22ee2b(0x123)]||_0xdec3bc['length']<=0x1)){_0x44bb25[_0x22ee2b(0x11f)]=_0x3df253;var _0x21a1e2={'functionsNode':!0x0,'props':_0xdec3bc};this[_0x22ee2b(0x10b)](_0x21a1e2,_0x246ec6),this[_0x22ee2b(0x169)](_0x21a1e2,_0x246ec6),this[_0x22ee2b(0x15b)](_0x21a1e2),this[_0x22ee2b(0x134)](_0x21a1e2,_0x246ec6),_0x21a1e2['id']+='\\\\x20f',_0x44bb25[_0x22ee2b(0x11f)][_0x22ee2b(0x11e)](_0x21a1e2);}}}[_0x27b5f4(0x11b)](_0x4447de,_0x39bc80){}[_0x27b5f4(0x15b)](_0x2ad7d8){}[_0x27b5f4(0x172)](_0x21c674){var _0x201530=_0x27b5f4;return Array[_0x201530(0x132)](_0x21c674)||typeof _0x21c674==_0x201530(0x1d1)&&this[_0x201530(0x15e)](_0x21c674)===_0x201530(0x1e2);}['_setNodePermissions'](_0x2c4127,_0x25c7dc){}[_0x27b5f4(0x1d4)](_0x368d9f){var _0x1076c1=_0x27b5f4;delete _0x368d9f['_hasSymbolPropertyOnItsPath'],delete _0x368d9f[_0x1076c1(0x13a)],delete _0x368d9f[_0x1076c1(0x161)];}[_0x27b5f4(0x17f)](_0x3b452d,_0x210ca2){}['_propertyAccessor'](_0x40ae2e){var _0x9d2342=_0x27b5f4;return _0x40ae2e?_0x40ae2e[_0x9d2342(0x1e5)](this[_0x9d2342(0x106)])?'['+_0x40ae2e+']':_0x40ae2e[_0x9d2342(0x1e5)](this['_keyStrRegExp'])?'.'+_0x40ae2e:_0x40ae2e[_0x9d2342(0x1e5)](this['_quotedRegExp'])?'['+_0x40ae2e+']':'[\\\\x27'+_0x40ae2e+'\\\\x27]':'';}}let _0x103982=new _0x7302f2();function _0x4ef4d5(_0x447b63,_0x2ac7e6,_0x1a6859,_0x160f8a,_0x430090,_0x134fa9){var _0x27e421=_0x27b5f4;let _0x16431e,_0x4089ff;try{_0x4089ff=_0x4d049a(),_0x16431e=_0xe1c80c[_0x2ac7e6],!_0x16431e||_0x4089ff-_0x16431e['ts']>0x1f4&&_0x16431e[_0x27e421(0x1bb)]&&_0x16431e[_0x27e421(0x148)]/_0x16431e['count']<0x64?(_0xe1c80c[_0x2ac7e6]=_0x16431e={'count':0x0,'time':0x0,'ts':_0x4089ff},_0xe1c80c['hits']={}):_0x4089ff-_0xe1c80c[_0x27e421(0x1bf)]['ts']>0x32&&_0xe1c80c[_0x27e421(0x1bf)]['count']&&_0xe1c80c['hits'][_0x27e421(0x148)]/_0xe1c80c[_0x27e421(0x1bf)][_0x27e421(0x1bb)]<0x64&&(_0xe1c80c[_0x27e421(0x1bf)]={});let _0x2f24ca=[],_0x2739a9=_0x16431e[_0x27e421(0x19e)]||_0xe1c80c[_0x27e421(0x1bf)][_0x27e421(0x19e)]?_0x5df0c1:_0x538d0c,_0x147472=_0x372ec9=>{var _0x4a7838=_0x27e421;let _0x5c2b64={};return _0x5c2b64[_0x4a7838(0x11f)]=_0x372ec9['props'],_0x5c2b64[_0x4a7838(0x1e0)]=_0x372ec9[_0x4a7838(0x1e0)],_0x5c2b64[_0x4a7838(0x13e)]=_0x372ec9[_0x4a7838(0x13e)],_0x5c2b64[_0x4a7838(0x12c)]=_0x372ec9[_0x4a7838(0x12c)],_0x5c2b64[_0x4a7838(0x12d)]=_0x372ec9['autoExpandLimit'],_0x5c2b64['autoExpandMaxDepth']=_0x372ec9[_0x4a7838(0x18f)],_0x5c2b64[_0x4a7838(0x1b3)]=!0x1,_0x5c2b64[_0x4a7838(0x158)]=!_0x2df5e3,_0x5c2b64[_0x4a7838(0x14b)]=0x1,_0x5c2b64[_0x4a7838(0x10d)]=0x0,_0x5c2b64[_0x4a7838(0x171)]=_0x4a7838(0x1e6),_0x5c2b64[_0x4a7838(0x141)]=_0x4a7838(0x1c4),_0x5c2b64['autoExpand']=!0x0,_0x5c2b64['autoExpandPreviousObjects']=[],_0x5c2b64[_0x4a7838(0x11d)]=0x0,_0x5c2b64['resolveGetters']=!0x0,_0x5c2b64[_0x4a7838(0x17b)]=0x0,_0x5c2b64[_0x4a7838(0x1da)]={'current':void 0x0,'parent':void 0x0,'index':0x0},_0x5c2b64;};for(var _0x1e1001=0x0;_0x1e1001<_0x430090[_0x27e421(0x123)];_0x1e1001++)_0x2f24ca[_0x27e421(0x1ac)](_0x103982['serialize']({'timeNode':_0x447b63===_0x27e421(0x148)||void 0x0},_0x430090[_0x1e1001],_0x147472(_0x2739a9),{}));if(_0x447b63==='trace'){let _0x58fe7f=Error['stackTraceLimit'];try{Error['stackTraceLimit']=0x1/0x0,_0x2f24ca[_0x27e421(0x1ac)](_0x103982[_0x27e421(0x111)]({'stackNode':!0x0},new Error()['stack'],_0x147472(_0x2739a9),{'strLength':0x1/0x0}));}finally{Error[_0x27e421(0x188)]=_0x58fe7f;}}return{'method':_0x27e421(0x1b6),'version':_0x3fd8d0,'args':[{'ts':_0x1a6859,'session':_0x160f8a,'args':_0x2f24ca,'id':_0x2ac7e6,'context':_0x134fa9}]};}catch(_0xe8878a){return{'method':_0x27e421(0x1b6),'version':_0x3fd8d0,'args':[{'ts':_0x1a6859,'session':_0x160f8a,'args':[{'type':'unknown','error':_0xe8878a&&_0xe8878a[_0x27e421(0x155)]}],'id':_0x2ac7e6,'context':_0x134fa9}]};}finally{try{if(_0x16431e&&_0x4089ff){let _0x956241=_0x4d049a();_0x16431e[_0x27e421(0x1bb)]++,_0x16431e[_0x27e421(0x148)]+=_0x272fdc(_0x4089ff,_0x956241),_0x16431e['ts']=_0x956241,_0xe1c80c[_0x27e421(0x1bf)][_0x27e421(0x1bb)]++,_0xe1c80c[_0x27e421(0x1bf)][_0x27e421(0x148)]+=_0x272fdc(_0x4089ff,_0x956241),_0xe1c80c['hits']['ts']=_0x956241,(_0x16431e[_0x27e421(0x1bb)]>0x32||_0x16431e['time']>0x64)&&(_0x16431e[_0x27e421(0x19e)]=!0x0),(_0xe1c80c[_0x27e421(0x1bf)][_0x27e421(0x1bb)]>0x3e8||_0xe1c80c['hits'][_0x27e421(0x148)]>0x12c)&&(_0xe1c80c[_0x27e421(0x1bf)]['reduceLimits']=!0x0);}}catch{}}}return _0x5b4790[_0x27b5f4(0x18b)];})(globalThis,_0x5c041f(0x124),_0x5c041f(0x160),_0x5c041f(0x174),_0x5c041f(0x19b),_0x5c041f(0x18a),_0x5c041f(0x17d),_0x5c041f(0x198),_0x5c041f(0x1d7));\");\n}\ncatch (e) { } }\n;\nfunction oo_oo(i, ...v) { try {\n    oo_cm().consoleLog(i, v);\n}\ncatch (e) { } return v; }\n;\noo_oo;\nfunction oo_tr(i, ...v) { try {\n    oo_cm().consoleTrace(i, v);\n}\ncatch (e) { } return v; }\n;\noo_tr;\nfunction oo_ts() { try {\n    oo_cm().consoleTime();\n}\ncatch (e) { } }\n;\noo_ts;\nfunction oo_te() { try {\n    oo_cm().consoleTimeEnd();\n}\ncatch (e) { } }\n;\noo_te; /*eslint eslint-comments/disable-enable-pair:,eslint-comments/no-unlimited-disable:,eslint-comments/no-aggregating-enable:,eslint-comments/no-duplicate-disable:,eslint-comments/no-unused-disable:,eslint-comments/no-unused-enable:,*/\n","import { Renderer } from \"./renderer\";\nimport { Scene } from \"./scene\";\nimport { Controller } from \"./controller\";\nimport { switch_latte, switch_mocha } from \"./theme_switch\";\nimport { SliceRenderer } from \"./slice_renderer\";\nconst canvas = document.getElementById(\"canv\");\nconst fps = document.getElementById(\"fps\");\nconst img = document.getElementById(\"kloppenheim_02\");\nconst slice_canvas = document.getElementById(\"slice-canvas\");\n//let camera = new FPCamera([-8.0, 0.0, 0.0], 0.0, 50.0);\nconst scene = new Scene();\nlet controller = new Controller(scene, canvas, 12, 0.0, 0.0);\nlet renderer = new Renderer(canvas, scene, controller.camera);\nscene.initialize_default_grid();\nrenderer.initialize(false);\nlet slice_renderer = new SliceRenderer(slice_canvas, scene);\nslice_renderer.slice = 6;\nslice_renderer.background = [30 / 255, 30 / 255, 46 / 255];\nslice_renderer.update();\nlet last_time = performance.now();\nlet camera_active = false;\n// const btn_renderer = <HTMLInputElement>document.getElementById(\"renderer\");\n// btn_renderer.addEventListener(\"change\", (e) => {\n//   renderer.shutdown();\n//   renderer.initialize((<HTMLInputElement>e.target).checked);\n// });\n//\naddEventListener(\"scroll\", () => {\n    // console.log(`${window.scrollY} / ${window.innerHeight}`);\n    let t = Math.min(2, window.scrollY / window.innerHeight);\n    // console.log(window.scrollY / window.innerHeight);\n    document.documentElement.style.setProperty(\"--canv-offset\", t.toString());\n    // document.documentElement.dataset.scroll = window.scrollY.toString();\n});\nrequestAnimationFrame(function tick() {\n    renderer.render();\n    const elapsed = performance.now() - last_time;\n    controller.tick(elapsed / 1000);\n    last_time = performance.now();\n    fps.innerText = Math.round((1 / elapsed) * 1000).toString() + \" fps\";\n    requestAnimationFrame(tick);\n});\naddEventListener(\"mousedown\", (e) => {\n    if (e.button == 2)\n        camera_active = true;\n});\nlet theme = \"mocha\";\nconst btn_switch_theme = document.getElementById(\"menu_switch_theme\");\nbtn_switch_theme === null || btn_switch_theme === void 0 ? void 0 : btn_switch_theme.addEventListener(\"click\", (e) => {\n    if (theme === \"mocha\") {\n        theme = \"latte\";\n        switch_latte();\n        scene.background_color = [204 / 255, 208 / 255, 218 / 255];\n        slice_renderer.set_background([204 / 255, 208 / 255, 218 / 255]);\n    }\n    else {\n        theme = \"mocha\";\n        switch_mocha();\n        scene.background_color = [30 / 255, 30 / 255, 46 / 255];\n        slice_renderer.set_background([30 / 255, 30 / 255, 46 / 255]);\n    }\n});\nscene.background_color = [30 / 255, 30 / 255, 46 / 255];\nconst btn_rescale_canvas = document.getElementById(\"menu_rescale_canvas\");\nfunction rescale() {\n    const root = document.querySelector(\":root\");\n    const scaled = Math.min(window.innerWidth, window.innerHeight) * 0.8;\n    root.style.setProperty(\"--canv-x\", scaled.toString() + \"px\");\n    root.style.setProperty(\"--canv-y\", scaled.toString() + \"px\");\n    canvas.height = scaled;\n    canvas.width = scaled;\n    renderer.shutdown();\n    renderer.initialize(renderer.pathtracing);\n}\nbtn_rescale_canvas === null || btn_rescale_canvas === void 0 ? void 0 : btn_rescale_canvas.addEventListener(\"click\", (e) => {\n    rescale();\n});\nrescale();\nconst btn_save_scene = document.getElementById(\"menu_save_scene\");\nfunction save() {\n    const file = new Blob([scene.serialize_scene()], { type: \"text/json\" });\n    const a = document.createElement(\"a\");\n    a.href = URL.createObjectURL(file);\n    a.download = \"scene.json\";\n    a.click();\n    URL.revokeObjectURL(a.href);\n}\nbtn_save_scene === null || btn_save_scene === void 0 ? void 0 : btn_save_scene.addEventListener(\"click\", (e) => {\n    save();\n});\nconst btn_load_scene = document.getElementById(\"menu_load_scene\");\nfunction load() {\n    const input = document.createElement(\"input\");\n    input.type = \"file\";\n    input.addEventListener(\"change\", (e) => {\n        const file = (input === null || input === void 0 ? void 0 : input.files)[0];\n        const reader = new FileReader();\n        reader.readAsText(file, \"UTF-8\");\n        reader.addEventListener(\"load\", (e) => {\n            var _a;\n            const content = (_a = e.target) === null || _a === void 0 ? void 0 : _a.result;\n            scene.deserialize_scene(content);\n            renderer.shutdown();\n            renderer.initialize(renderer.pathtracing);\n        });\n    });\n    input.click();\n}\nbtn_load_scene === null || btn_load_scene === void 0 ? void 0 : btn_load_scene.addEventListener(\"click\", (e) => {\n    load();\n});\nconst btn_reset = document.getElementById(\"menu_reset\");\nfunction reset() {\n    scene.reset();\n}\nbtn_reset === null || btn_reset === void 0 ? void 0 : btn_reset.addEventListener(\"click\", (e) => {\n    reset();\n});\n// addEventListener(\"mouseup\", (e) => {\n// \tif (e.button == 2) camera_active = false;\n// \tif (e.button == 0) {\n// \t\tconst rect = canvas.getBoundingClientRect();\n// \t\tconst x = e.clientX - rect.left;\n// \t\tconst y = e.clientY - rect.top;\n// \t\tconst hit = scene.ray_any(camera.screen_to_ray(x, y, canvas.width, canvas.height));\n// \t\tif (hit) {\n// \t\t\tlet voxel = new Voxel();\n// \t\t\tvoxel.opacity = 0;\n// \t\t\tscene.set_voxel(voxel, hit.voxel_position);\n// \t\t}\n// \t}\n// });\naddEventListener(\"contextmenu\", (e) => {\n    e.preventDefault();\n    // const rect = canvas.getBoundingClientRect();\n    // const x = e.clientX - rect.left;\n    // const y = e.clientY - rect.top;\n    // renderer.shoot_ray(x, y);\n    return false;\n});\n","import { vec2, vec3 } from \"wgpu-matrix\";\nimport { OrbitCamera } from \"./orbit_camera\";\nimport { Voxel } from \"./scene\";\nexport class Controller {\n    constructor(scene, canvas, distance, theta, phi) {\n        this.mouse_down = false;\n        this.mouse_dragged = false;\n        this.over_canvas = false;\n        this.last_move = 0;\n        this.velocity = [0, 0];\n        this.selected_color = [0, 0, 0];\n        this.selected_roughness = 1;\n        this.selected_opacity = 1;\n        this.selected_lightness = 0;\n        this.multidraw = false;\n        this.last_drawn = [0, 0, 0];\n        this.camera = new OrbitCamera(distance, theta, phi);\n        this.last_move = performance.now();\n        this.last_movement = [0, 0];\n        this.scene = scene;\n        this.canvas = canvas;\n        this.selected_tool = \"place\";\n        this.blub_high = document.getElementById(\"blub_high\");\n        this.blub_low = document.getElementById(\"blub_low\");\n        this.setup();\n    }\n    tick(delta_time) {\n        this.camera.tick(delta_time);\n    }\n    setup() {\n        var _a, _b, _c, _d, _e, _f, _g;\n        this.canvas.addEventListener(\"mouseover\", (e) => {\n            this.over_canvas = true;\n        });\n        this.canvas.addEventListener(\"mouseout\", (e) => {\n            this.over_canvas = false;\n        });\n        addEventListener(\"mousedown\", (e) => {\n            if (this.over_canvas && e.button == 0) {\n                if (e.shiftKey) {\n                    this.multidraw = true;\n                }\n                this.mouse_down = true;\n                this.mouse_dragged = false;\n                this.camera.dragged = true;\n                this.last_move = performance.now();\n            }\n        });\n        addEventListener(\"mouseup\", (e) => {\n            if (e.button == 0) {\n                if (this.mouse_down)\n                    this.camera.velocity = [...this.velocity];\n                this.mouse_down = false;\n                this.camera.dragged = false;\n                this.multidraw = false;\n                if (!this.mouse_dragged) {\n                    const rect = this.canvas.getBoundingClientRect();\n                    const x = e.clientX - rect.left;\n                    const y = e.clientY - rect.top;\n                    let voxel = this.scene.ray_any(this.camera.screen_to_ray(x, y, rect.width, rect.height));\n                    if (voxel) {\n                        switch (this.selected_tool) {\n                            case \"place\":\n                                let n_voxel = new Voxel();\n                                n_voxel.color = this.selected_color;\n                                n_voxel.roughness = this.selected_roughness;\n                                n_voxel.lightness = this.selected_lightness;\n                                n_voxel.opacity = this.selected_opacity;\n                                let n_voxel_pos = voxel.voxel_position.map((val, i) => val + voxel.normal[i]);\n                                this.scene.set_voxel(n_voxel, n_voxel_pos);\n                                this.blub_high.play();\n                                this.last_drawn = n_voxel_pos;\n                                break;\n                            case \"replace\":\n                                let r_voxel = new Voxel();\n                                r_voxel.color = this.selected_color;\n                                r_voxel.roughness = this.selected_roughness;\n                                r_voxel.lightness = this.selected_lightness;\n                                r_voxel.opacity = this.selected_opacity;\n                                this.scene.set_voxel(r_voxel, voxel.voxel_position);\n                                this.blub_high.play();\n                                this.last_drawn = voxel.voxel_position;\n                                break;\n                            case \"remove\":\n                                let d_voxel = new Voxel();\n                                d_voxel.opacity = 0;\n                                this.scene.set_voxel(d_voxel, voxel.voxel_position);\n                                this.blub_low.play();\n                                break;\n                        }\n                    }\n                }\n            }\n        });\n        addEventListener(\"mousemove\", (e) => {\n            this.last_movement = vec2.scale([e.movementX, e.movementY], 0.2);\n            if (this.mouse_down) {\n                this.mouse_drag(e);\n                if (this.multidraw) {\n                    const rect = this.canvas.getBoundingClientRect();\n                    const x = e.clientX - rect.left;\n                    const y = e.clientY - rect.top;\n                    let voxel = this.scene.ray_any(this.camera.screen_to_ray(x, y, rect.width, rect.height));\n                    if (voxel && voxel.voxel_position.toString() !== this.last_drawn.toString()) {\n                        if (this.selected_tool == \"place\") {\n                            let n_voxel = new Voxel();\n                            n_voxel.color = this.selected_color;\n                            n_voxel.roughness = this.selected_roughness;\n                            n_voxel.lightness = this.selected_lightness;\n                            n_voxel.opacity = this.selected_opacity;\n                            let n_voxel_pos = voxel.voxel_position.map((val, i) => val + voxel.normal[i]);\n                            this.scene.set_voxel(n_voxel, n_voxel_pos);\n                            this.blub_high.play();\n                            this.last_drawn = n_voxel_pos;\n                        }\n                        if (this.selected_tool == \"replace\") {\n                            let r_voxel = new Voxel();\n                            r_voxel.color = this.selected_color;\n                            r_voxel.roughness = this.selected_roughness;\n                            r_voxel.lightness = this.selected_lightness;\n                            r_voxel.opacity = this.selected_opacity;\n                            this.scene.set_voxel(r_voxel, voxel.voxel_position);\n                            this.blub_high.play();\n                            this.last_drawn = voxel.voxel_position;\n                        }\n                        if (this.selected_tool == \"remove\") {\n                            let d_voxel = new Voxel();\n                            d_voxel.opacity = 0;\n                            this.scene.set_voxel(d_voxel, voxel.voxel_position);\n                            this.blub_low.play();\n                            let nvoxel = this.scene.ray_any(this.camera.screen_to_ray(x, y, rect.width, rect.height));\n                            if (nvoxel) {\n                                this.last_drawn = nvoxel.voxel_position;\n                            }\n                        }\n                    }\n                }\n            }\n            this.calculate_velocity();\n            this.last_move = performance.now();\n        });\n        (_a = document.getElementById(\"color_value\")) === null || _a === void 0 ? void 0 : _a.addEventListener(\"input\", (e) => {\n            var _a;\n            const col = e.target.value;\n            this.selected_color = vec3.scale((_a = col.match(/\\w\\w/g)) === null || _a === void 0 ? void 0 : _a.map((x) => parseInt(x, 16)), 1 / 255);\n        });\n        (_b = document\n            .getElementById(\"roughness_value\")) === null || _b === void 0 ? void 0 : _b.addEventListener(\"input\", (e) => {\n            this.selected_roughness =\n                1 - parseInt(e.target.value) / 100;\n        });\n        (_c = document\n            .getElementById(\"lightness_value\")) === null || _c === void 0 ? void 0 : _c.addEventListener(\"input\", (e) => {\n            this.selected_lightness =\n                parseInt(e.target.value) / 25;\n        });\n        (_d = document.getElementById(\"opacity_value\")) === null || _d === void 0 ? void 0 : _d.addEventListener(\"input\", (e) => {\n            this.selected_opacity =\n                parseInt(e.target.value) / 100;\n        });\n        (_e = document\n            .getElementById(\"tool-place-button\")) === null || _e === void 0 ? void 0 : _e.addEventListener(\"change\", (e) => {\n            this.selected_tool = \"place\";\n        });\n        (_f = document\n            .getElementById(\"tool-replace-button\")) === null || _f === void 0 ? void 0 : _f.addEventListener(\"change\", (e) => {\n            this.selected_tool = \"replace\";\n        });\n        (_g = document\n            .getElementById(\"tool-remove-button\")) === null || _g === void 0 ? void 0 : _g.addEventListener(\"change\", (e) => {\n            this.selected_tool = \"remove\";\n        });\n    }\n    calculate_velocity() {\n        const t = performance.now() - this.last_move;\n        vec2.scale(this.last_movement, 1 / t, this.velocity);\n    }\n    mouse_drag(e) {\n        if (this.multidraw)\n            return;\n        this.camera.eulers[1] = this.camera.eulers[1] - this.last_movement[1];\n        this.camera.eulers[2] = this.camera.eulers[2] - this.last_movement[0];\n        // this.camera.velocity = [e.movementY, e.movementX];\n        this.mouse_dragged = true;\n    }\n}\n","export default \"const light_scatter_samples: i32 = 2;\\r\\n\\r\\nfn gamma_correct(color: vec3<f32>) -> vec3<f32> {\\r\\n    let correction = 1.0 / f32(samples);\\r\\n    return sqrt(correction * color);\\r\\n}\\r\\n\\r\\nfn trace(ray: Ray, depth: i32) -> vec3<f32> {\\r\\n\\tif (depth <= 0) {\\r\\n\\t\\treturn vec3<f32>(0);\\r\\n\\t}\\r\\n\\t\\tvar accum: vec3<f32> = vec3<f32>(0.0);\\r\\n\\t\\tvar mask: vec3<f32> = vec3<f32>(1.0);\\r\\n\\t\\tvar curr_ray: Ray = ray;\\r\\n\\t\\tvar curr_hit: RayHit;\\r\\n\\t\\tvar refl: f32 = 1.0;\\r\\n\\t\\tvar hits: i32 = 0;\\r\\n\\r\\n\\t\\tvar bounce_results: array<RayHit, light_bounces>;\\r\\n\\r\\n\\t\\tfor (; hits < light_bounces;){\\r\\n\\t\\t\\tif (voxel_ray_any(curr_ray, 0.0001, &curr_hit)) {\\r\\n\\t\\t\\t\\tlet bounce_direction = random_unit_vector() + curr_hit.normal;\\r\\n\\t\\t\\t\\tif (all(bounce_direction == vec3<f32>(0))){\\r\\n\\t\\t\\t\\t\\tcurr_ray = Ray(curr_hit.position, curr_hit.normal, 1 / curr_hit.normal);\\r\\n\\t\\t\\t\\t} else {\\r\\n\\t\\t\\t\\t\\tlet normalized = normalize(bounce_direction);\\r\\n\\t\\t\\t\\t\\tcurr_ray = Ray(curr_hit.position, normalized, 1 / normalized);\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\tbounce_results[hits] = curr_hit;\\r\\n\\t\\t\\t\\thits++;\\r\\n\\t\\t\\t} else {\\r\\n\\t\\t\\t\\t// accum = pow(textureSampleLevel(hdr_tex, hdr_sampler, sample_spherical_map(curr_ray.direction), 0.0).rgb, vec3<f32>(2)) * 5;\\r\\n\\t\\t\\t\\taccum = vec3<f32>(pow(max(0, dot(curr_ray.direction, scene.direct_light) - 0.98) * 40, 1));\\r\\n\\t\\t\\t\\tbreak;\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif (hits == 0){\\r\\n\\t\\t\\t// return textureSampleLevel(hdr_tex, hdr_sampler, sample_spherical_map(ray.direction), 0.0).rgb;\\r\\n\\t\\t\\treturn vec3<f32>(pow(max(0, dot(ray.direction, scene.direct_light) - 0.95) * 20, 1));\\r\\n\\t\\t}\\r\\n\\t\\tif (hits == light_bounces){\\r\\n\\t\\t\\taccum = vec3<f32>(0, 0, 0);\\r\\n\\t\\t} else {\\r\\n\\t\\t\\t// accum = textureSampleLevel(hdr_tex, hdr_sampler, sample_spherical_map(bounce_results[hits - 1].ray_direction), 0.0).rgb;\\r\\n\\t\\t\\t/* accum = vec3<f32>(max(0, dot(bounce_results[hits - 1].ray_direction, scene.direct_light))); */\\r\\n\\t\\t\\t// accum = vec3<f32>(0);\\r\\n\\t\\t}\\r\\n\\t\\tfor (var i: i32 = hits - 1; i >= 0; i--){\\r\\n\\t\\t\\tlet bounce = bounce_results[i];\\r\\n\\t\\t\\t/* accum = min(vec3<f32>(1), accum) * min(vec3<f32>(1), bounce.voxel.color); */\\r\\n\\t\\t\\taccum = accum * bounce.voxel.color\\r\\n\\t\\t\\t\\t+ bounce_results[i].voxel.lightness * bounce_results[i].voxel.color;\\r\\n\\t\\t\\t// if (all(bounce.normal == vec3<f32>(0)) && all(bounce.ray_direction == vec3<f32>(0))){\\r\\n\\t\\t\\t// \\t// accum = textureSampleLevel(hdr_tex, hdr_sampler, sample_spherical_map(bounce_results[i].ray_direction), 0.0).rgb;\\r\\n\\t\\t\\t// \\taccum = vec3<f32>(0.5);\\r\\n\\t\\t\\t// \\tcontinue;\\r\\n\\t\\t\\t// }\\r\\n\\t\\t\\t// accum = accum * bounce.voxel.color;\\r\\n\\t\\t\\t// accum = accum * bounce.voxel.color;\\r\\n\\t\\t}\\r\\n\\treturn accum; // / f32(light_scatter_samples);\\r\\n}\\r\\n\\r\\nfn direct_illumination(orig_hit: RayHit, refl: ptr<function, f32>) -> vec3<f32> {\\r\\n\\tvar hit: RayHit;\\r\\n\\tif (!voxel_ray_any(Ray(orig_hit.position, scene.direct_light, 1 / scene.direct_light), 0.00001, &hit)){\\r\\n\\t\\treturn scene.direct_light_brightness * orig_hit.voxel.color;\\r\\n\\t} else {\\r\\n\\t\\treturn 0.2 * orig_hit.voxel.color;\\r\\n\\t}\\r\\n}\\r\\n\\r\\nfn voxel_ray_any(ray: Ray, start_tolerance: f32, hit: ptr<function, RayHit>) -> bool {\\r\\n\\tvar tmin: f32 = 0.0;\\r\\n\\tvar tmax: f32 = 300000000;\\r\\n\\tfor (var d: i32 = 0; d < 3; d++) {\\r\\n\\t\\tlet t1 = (boundary_min[d] - ray.origin[d]) * ray.inv_direction[d];\\r\\n\\t\\tlet t2 = (boundary_max[d] - ray.origin[d]) * ray.inv_direction[d];\\r\\n\\r\\n\\t\\ttmin = min(max(t1, tmin), max(t2, tmin));\\r\\n\\t\\ttmax = max(min(t1, tmax), min(t2, tmax));\\r\\n\\t}\\r\\n\\t// Hier ist noch ein Fehler drin, tritt nur von ausserhalb des grid auf, das kommt ja vielleicht eh noch weg\\r\\n\\tif tmin > tmax { return false; }\\r\\n    \\tlet ray_entry = ray.origin + ray.direction * tmin;\\r\\n\\tlet ray_exit = ray.origin + ray.direction * tmax;\\r\\n\\r\\n\\tvar voxel: vec3<i32> = max(vec3<i32>(0), min(vec3<i32>(voxel_count - 1), vec3<i32>((ray_entry - boundary_min) / f32(voxel_size))));\\r\\n\\t//var end_voxel: vec3<i32> = max(vec3<i32>(0), min(vec3<i32>(voxel_count - 1), vec3<i32>((ray_exit - boundary_min - ray.direction * 0.000001) / f32(voxel_size))));\\r\\n\\r\\n\\tlet direction_zeros: vec3<bool> = ray.direction == vec3<f32>(0);\\r\\n\\tlet step: vec3<i32> = vec3<i32>(sign(ray.direction));\\r\\n\\tlet tdelta: vec3<f32> = select(voxel_size / abs(ray.direction), vec3<f32>(tmax), direction_zeros);\\r\\n\\tlet voxel_boundary: vec3<f32> = vec3<f32>(voxel + max(vec3<i32>(0), step)) * voxel_size;\\r\\n\\tvar tmax_comp: vec3<f32> = select(tmin + (boundary_min + voxel_boundary - ray_entry) / ray.direction, vec3<f32>(tmax), direction_zeros);\\r\\n\\tvar thit: f32 = tmin;\\r\\n\\tvar hit_normal: vec3<f32> = vec3<f32>(0, 0, 0);\\r\\n\\r\\n\\twhile(all(voxel >= vec3<i32>(0)) && all(voxel < vec3<i32>(voxel_count))) {\\r\\n\\t\\tlet hit_voxel = get_voxel(voxel);\\r\\n\\t\\tif (hit_voxel.opacity > 0.01 && all(tmax_comp > vec3<f32>(start_tolerance))){\\r\\n\\t\\t\\t(*hit).position = ray.origin + ray.direction * thit;\\r\\n\\t\\t\\t(*hit).voxel = hit_voxel;\\r\\n\\t\\t\\t(*hit).voxel_position = voxel;\\r\\n\\t\\t\\t(*hit).depth = 1 - (thit - depth_clip_min) / (depth_clip_max - depth_clip_min);\\r\\n\\t\\t\\t(*hit).normal = hit_normal;\\r\\n\\t\\t\\t(*hit).ray_direction = ray.direction;\\r\\n\\t\\t\\treturn true;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif (tmax_comp.x < tmax_comp.y && tmax_comp.x < tmax_comp.z) {\\r\\n\\t\\t\\tvoxel.x += step.x;\\r\\n\\t\\t\\tthit = tmax_comp.x;\\r\\n\\t\\t\\ttmax_comp.x += tdelta.x;\\r\\n\\t\\t\\thit_normal = vec3<f32>(f32(-step.x), 0, 0);\\r\\n\\t\\t} else if (tmax_comp.y < tmax_comp.z){\\r\\n\\t\\t\\tvoxel.y += step.y;\\r\\n\\t\\t\\tthit = tmax_comp.y;\\r\\n\\t\\t\\ttmax_comp.y += tdelta.y;\\r\\n\\t\\t\\thit_normal = vec3<f32>(0, f32(-step.y), 0);\\r\\n\\t\\t} else {\\r\\n\\t\\t\\tvoxel.z += step.z;\\r\\n\\t\\t\\tthit = tmax_comp.z;\\r\\n\\t\\t\\ttmax_comp.z += tdelta.z;\\r\\n\\t\\t\\thit_normal = vec3<f32>(0, 0, f32(-step.z));\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\treturn false;\\r\\n}\\r\\n\"","export default \"struct penetration {\\r\\n\\tcolor: vec3<f32>,\\r\\n\\tao: f32,\\r\\n\\thit: RayHit,\\r\\n}\\r\\n\\r\\nfn gamma_correct(color: vec3<f32>) -> vec3<f32> {\\r\\n    return color / f32(samples);\\r\\n}\\r\\n\\r\\nfn trace(ray: Ray, depth: i32) -> vec3<f32> {\\r\\n\\tvar hit: RayHit;\\r\\n\\tvar bounces: array<RayHit, reflection_bounces>;\\r\\n\\tvar curr_ray = ray;\\r\\n\\tvar hits: i32 = 0;\\r\\n\\tvar has_next_ray = true;\\r\\n\\tvar penetrations: array<penetration, max_penetrations>;\\r\\n\\tvar penetration_count = 0;\\r\\n\\r\\n\\tfor (var p = 0; p < max_penetrations; p++){\\r\\n\\t\\tvar color = vec3<f32>(0.0);\\r\\n\\t\\tvar ao = 0f;\\r\\n\\t\\tvar first_hit: RayHit;\\r\\n\\t\\tfor (var i = 0; i < reflection_bounces; i++){\\r\\n\\t\\t\\tif(voxel_ray_any(curr_ray, 0.001, &hit)){\\r\\n\\t\\t\\t\\t// return TraceResult(vec3<f32>(hit.uv.x), 0.0);\\r\\n\\t\\t\\t\\tbounces[i] = hit;\\r\\n\\t\\t\\t\\tcurr_ray = ray_reflect(curr_ray, hit.position, hit.normal);\\r\\n\\t\\t\\t\\thits++;\\r\\n\\t\\t\\t\\tif (i == 0){\\r\\n\\t\\t\\t\\t\\tfirst_hit = hit;\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\tif (hit.voxel.roughness > 0.99){\\r\\n\\t\\t\\t\\t\\tbreak;\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t} else {\\r\\n\\t\\t\\t\\t// return TraceResult(vec3<f32>(0.1), 0.0);\\r\\n\\t\\t\\t\\tcolor = scene.background_color;\\r\\n\\t\\t\\t\\tbreak;\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t\\tif (hits == 0){\\r\\n\\t\\t\\tbreak;\\r\\n\\t\\t\\t// return background;\\r\\n\\t\\t\\t// return ray.direction;\\r\\n\\t\\t}\\r\\n\\t\\t// return vec3<f32>(0.2, 0.4, 0.5);\\r\\n\\t\\t// return vec3<f32>(bounces[0].uv.x, bounces[0].uv.y, 0.0);\\r\\n\\r\\n\\t\\tfor (var i: i32 = hits; i >= 0; i--){\\r\\n\\t\\t\\t\\t// return TraceResult(vec3<f32>(0.5), 0.0);\\r\\n\\t\\t\\t// return TraceResult(vec3<f32>(bounces[i].uv.x), 0.0);\\r\\n\\t\\t\\tlet t = bounces[i].voxel.roughness;\\r\\n\\t\\t\\tcolor = color * (1 - t) + t * bounces[i].voxel.color * illumination(bounces[i].position);\\r\\n\\t\\t\\tif (i == 0){\\r\\n\\t\\t\\t\\t//ao = get_point_ao(bounces[0].position);\\r\\n\\t\\t\\t\\tao = 0;\\r\\n\\t\\t\\t\\tlet nrm = vec3<i32>(bounces[i].normal);\\r\\n\\t\\t\\t\\tlet uv = bounces[i].uv;\\r\\n\\t\\t\\t\\tlet am = voxel_ao(bounces[i].voxel_position + nrm, nrm.zxy, nrm.yzx);\\r\\n\\t\\t\\t\\tao = mix(mix(am.z, am.w, uv.x), mix(am.y, am.x, uv.x), uv.y);\\r\\n\\t\\t\\t\\t// return vec3<f32>(uv.x / 10 + interp_ao, uv.y / 10 + interp_ao, interp_ao) / 2;\\r\\n\\t\\t\\t\\t// return vec3<f32>(interp_ao);\\r\\n\\t\\t\\t\\t// let interp_ao = \\r\\n\\t\\t\\t\\t// ao = get_point_ao_lambert(bounces[0].position, bounces[0].normal);\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\t\\r\\n\\t\\t\\tfor (var l: i32 = 0; l < i32(scene.light_count); l++){\\r\\n\\t\\t\\t\\tlet light = lights.data[l];\\r\\n\\t\\t\\t\\tif i32(light.emitter_type) == 0 {\\r\\n\\t\\t\\t\\t\\tlet light_voxel = get_voxel(vec3<i32>(light.location));\\r\\n\\t\\t\\t\\t\\tlet light_voxel_location = light.location * voxel_size + boundary_min;\\r\\n\\t\\t\\t\\t\\tlet light_voxel_location_top = light_voxel_location + voxel_size;\\r\\n\\t\\t\\t\\t\\tlet light_voxel_location_mid = (light_voxel_location + light_voxel_location_top) / 2;\\r\\n\\t\\t\\t\\t\\tlet lray_dir = light_voxel_location_mid - bounces[i].position;\\r\\n\\t\\t\\t\\t\\tlet lray = Ray(bounces[i].position, lray_dir, 1 / lray_dir);\\r\\n\\t\\t\\t\\t\\tvar lhit: RayHit;\\r\\n\\t\\t\\t\\t\\tif (voxel_ray_any(lray, 0.001, &lhit) && all(lhit.voxel_position == vec3<i32>(light.location))){\\r\\n\\t\\t\\t\\t\\t\\tlet dist = distance(light_voxel_location_mid, bounces[i].position);\\r\\n\\t\\t\\t\\t\\t\\tlet intensity = 1 / pow(dist, 2) * lhit.voxel.lightness;\\r\\n\\t\\t\\t\\t\\t\\tcolor += light_voxel.color * vec3<f32>(intensity) * bounces[i].voxel.color;\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\t\\r\\n\\t\\t\\t// let vox = bounces[i].voxel_position;\\r\\n\\t\\t\\t// let gi_vox = vox + vec3<i32>(bounces[i].normal);\\r\\n\\t\\t\\t// color += get_meta_voxel(gi_vox).gi / 5;\\r\\n\\t\\t}\\r\\n\\t\\tpenetrations[p] = penetration(color, ao, first_hit);\\r\\n\\t\\tpenetration_count++;\\r\\n\\t\\tcurr_ray = Ray(first_hit.exit_position, ray.direction, ray.inv_direction);\\r\\n\\t\\tif (first_hit.voxel.opacity > 0.99){\\r\\n\\t\\t\\tbreak;\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\tif (penetration_count == 0){\\r\\n\\t\\treturn scene.background_color;\\r\\n\\t\\t// return TraceResult(scene.background_color, 0);\\r\\n\\t}\\r\\n\\r\\n\\tvar color = penetrations[penetration_count - 1].color;\\r\\n\\tvar ao = penetrations[penetration_count - 1].ao;\\r\\n\\tfor (var i: i32 = penetration_count - 2; i >= 0; i--){\\r\\n\\t\\t// if (i > 0 && all(penetrations[i].voxel_color == penetrations[i - 1].voxel_color)) { continue;}\\r\\n\\t\\tlet pvoxel = penetrations[i].hit.voxel;\\r\\n\\t\\tlet phit = penetrations[i].hit;\\r\\n\\t\\tlet pcolor = penetrations[i].color;\\r\\n\\t\\tlet pao = penetrations[i].ao;\\r\\n\\t\\tlet t = pvoxel.opacity;\\r\\n\\t\\tif (i > 0 && all(penetrations[i - 1].hit.voxel.color == pvoxel.color)) { continue; }\\r\\n\\t\\tcolor = pcolor * t + (1 - t) * color;\\r\\n\\t\\tao = pao * t + (1 - t) * ao;\\r\\n\\t\\t// let t = distance(phit.position, phit.exit_position) / voxel_size;\\r\\n\\t\\t// color += pvoxel.color * t / f32(penetration_count);\\r\\n\\t\\t// color = pvoxel.color * t + color * (1 - t);\\r\\n\\t\\t// color = penetrations[i].color * pvoxel.opacity + color * (1 - pvoxel.opacity);\\r\\n\\t\\t// ao = penetrations[i].ao * pvoxel.opacity + ao * (1 - pvoxel.opacity);\\r\\n\\t}\\r\\n\\r\\n\\treturn color * ao;\\r\\n\\t// return TraceResult(color, ao);\\r\\n\\t// return vec3<f32>(ao);\\r\\n}\\r\\n\\r\\nfn illumination(p: vec3<f32>) -> f32 {\\r\\n\\tvar hit: RayHit;\\r\\n\\tif (!voxel_ray_any(Ray(p, scene.direct_light, 1 / scene.direct_light), 0.001, &hit)){\\r\\n\\t\\treturn max(scene.direct_light_brightness, scene.ambient_light);\\r\\n\\t}\\r\\n\\treturn scene.ambient_light;\\r\\n}\\r\\n\\r\\nfn voxel_ray_any(ray: Ray, start_tolerance: f32, hit: ptr<function, RayHit>) -> bool {\\r\\n\\tvar tmin: f32 = 0.0;\\r\\n\\tvar tmax: f32 = 300000000;\\r\\n\\tfor (var d: i32 = 0; d < 3; d++) {\\r\\n\\t\\tlet t1 = (boundary_min[d] - ray.origin[d]) * ray.inv_direction[d];\\r\\n\\t\\tlet t2 = (boundary_max[d] - ray.origin[d]) * ray.inv_direction[d];\\r\\n\\r\\n\\t\\ttmin = min(max(t1, tmin), max(t2, tmin));\\r\\n\\t\\ttmax = max(min(t1, tmax), min(t2, tmax));\\r\\n\\t}\\r\\n\\t// Hier ist noch ein Fehler drin, tritt nur von ausserhalb des grid auf, das kommt ja vielleicht eh noch weg\\r\\n\\tif tmin > tmax { return false; }\\r\\n    \\tlet ray_entry = ray.origin + ray.direction * tmin;\\r\\n\\tlet ray_exit = ray.origin + ray.direction * tmax;\\r\\n\\r\\n\\tvar voxel: vec3<i32> = max(vec3<i32>(0), min(vec3<i32>(voxel_count - 1), vec3<i32>((ray_entry - boundary_min) / f32(voxel_size))));\\r\\n\\t//var end_voxel: vec3<i32> = max(vec3<i32>(0), min(vec3<i32>(voxel_count - 1), vec3<i32>((ray_exit - boundary_min - ray.direction * 0.000001) / f32(voxel_size))));\\r\\n\\r\\n\\tlet direction_zeros: vec3<bool> = ray.direction == vec3<f32>(0);\\r\\n\\tlet vstep: vec3<i32> = vec3<i32>(sign(ray.direction));\\r\\n\\tlet tdelta: vec3<f32> = select(voxel_size / abs(ray.direction), vec3<f32>(tmax), direction_zeros);\\r\\n\\tlet voxel_boundary: vec3<f32> = vec3<f32>(voxel + max(vec3<i32>(0), vstep)) * voxel_size;\\r\\n\\tvar tmax_comp: vec3<f32> = select(tmin + (boundary_min + voxel_boundary - ray_entry) / ray.direction, vec3<f32>(tmax), direction_zeros);\\r\\n\\tvar thit: f32 = tmin;\\r\\n\\tvar hit_normal: vec3<f32> = vec3<f32>(0, 0, 0);\\r\\n\\tvar mask: vec3<f32>;\\r\\n\\r\\n\\twhile(all(voxel >= vec3<i32>(0)) && all(voxel < vec3<i32>(voxel_count))) {\\r\\n\\t\\tlet hit_voxel = get_voxel(voxel);\\r\\n\\t\\tif (hit_voxel.opacity > 0.01 && all(tmax_comp > vec3<f32>(start_tolerance))){\\r\\n\\t\\t\\t(*hit).position = ray.origin + ray.direction * thit;\\r\\n\\t\\t\\t(*hit).voxel = hit_voxel;\\r\\n\\t\\t\\t(*hit).voxel_position = voxel;\\r\\n\\t\\t\\t(*hit).depth = 1 - (thit - depth_clip_min) / (depth_clip_max - depth_clip_min);\\r\\n\\t\\t\\t(*hit).normal = hit_normal;\\r\\n\\t\\t\\t(*hit).ray_direction = ray.direction;\\r\\n\\t\\t\\t// let v_diff = (*hit).position - (vec3<f32>(voxel) * voxel_size - boundary_min);\\r\\n\\t\\t\\tlet uv = (((*hit).position - boundary_min) - (vec3<f32>(voxel) * voxel_size)) / voxel_size;\\r\\n\\t\\t\\tlet uvx = select(vec3<f32>(1) * mask - mask * uv.yzx, mask * uv.yzx, sign(ray.direction) < vec3<f32>(0));\\r\\n\\t\\t\\tlet uvy = select(vec3<f32>(1) * mask - mask * uv.zxy, mask * uv.zxy, sign(ray.direction) < vec3<f32>(0));\\r\\n\\t\\t\\t// let uvy = mask * uv.zxy;\\r\\n\\t\\t\\t(*hit).uv = vec2<f32>(\\r\\n\\t\\t\\t\\tmax(uvx.x, max(uvx.y, uvx.z)),\\r\\n\\t\\t\\t\\tmax(uvy.x, max(uvy.y, uvy.z)),\\r\\n\\t\\t\\t\\t// dot(mask * v_diff.zxy, vec3<f32>(voxel_size)) / voxel_size,\\r\\n\\t\\t\\t);\\r\\n\\t\\t\\tlet next_mask = step(tmax_comp.xyz, tmax_comp.yzx) * step(tmax_comp.xyz, tmax_comp.zxy);\\r\\n\\t\\t\\tlet tmax_masked = vec3<f32>(next_mask) * tmax_comp;\\r\\n\\t\\t\\t(*hit).exit_position = ray.origin + ray.direction * max(tmax_masked.x, max(tmax_masked.y, tmax_masked.z));\\r\\n\\r\\n\\t\\t\\t\\t\\t\\t// if (tmax_comp.x < tmax_comp.y && tmax_comp.x < tmax_comp.z) {\\r\\n\\t\\t\\t// \\t(*hit).exit_position = ray.origin + ray.direction * tmax_comp.x;\\r\\n\\t\\t\\t// } else if (tmax_comp.y < tmax_comp.z){\\r\\n\\t\\t\\t// \\t(*hit).exit_position = ray.origin + ray.direction * tmax_comp.y;\\r\\n\\t\\t\\t// } else {\\r\\n\\t\\t\\t// \\t(*hit).exit_position = ray.origin + ray.direction * tmax_comp.z;\\r\\n\\t\\t\\t// }\\r\\n\\t\\t\\treturn true;\\r\\n\\t\\t}\\r\\n\\t\\tmask = step(tmax_comp.xyz, tmax_comp.yzx) * step(tmax_comp.xyz, tmax_comp.zxy);\\r\\n\\t\\tvoxel += vstep * vec3<i32>(mask);\\r\\n\\t\\tlet tmax_masked = vec3<f32>(mask) * tmax_comp;\\r\\n\\t\\tthit = max(tmax_masked.x, max(tmax_masked.y, tmax_masked.z));\\r\\n\\t\\thit_normal = -(vec3<f32>(vstep) * mask);\\r\\n\\t\\ttmax_comp += mask * tdelta;\\r\\n\\t}\\r\\n\\r\\n\\treturn false;\\r\\n}\\r\\n\\r\\nfn voxel_ao(pos: vec3<i32>, d1: vec3<i32>, d2: vec3<i32>) -> vec4<f32> {\\r\\n\\tif (get_voxel(pos).opacity > 0) { return vec4<f32>(1); }\\r\\n\\tlet side = vec4<f32>(get_voxel(pos + d1).opacity, get_voxel(pos + d2).opacity, get_voxel(pos - d1).opacity, get_voxel(pos - d2).opacity);\\r\\n\\tlet corner = vec4<f32>(get_voxel(pos + d1 + d2).opacity, get_voxel(pos - d1 + d2).opacity, get_voxel(pos - d1 - d2).opacity, get_voxel(pos + d1 - d2).opacity);\\r\\n\\tlet ao = vec4<f32>(\\r\\n\\t\\tvertex_ao(side.xy, corner.x),\\r\\n\\t\\tvertex_ao(side.yz, corner.y),\\r\\n\\t\\tvertex_ao(side.zw, corner.z),\\r\\n\\t\\tvertex_ao(side.wx, corner.w),\\r\\n\\t);\\r\\n\\treturn 1.0 - ao * scene.ao_strength;\\r\\n}\\r\\n\\r\\nfn vertex_ao(side: vec2<f32>, corner: f32) -> f32 {\\r\\n\\t// return (side.x + side.y) / 2.0;\\r\\n\\treturn max(side.x + side.y, max(corner, side.x * side.y)) / 2;\\r\\n\\treturn (side.x + side.y + max(corner, side.x * side.y)) / 3.0;\\r\\n}\"","export function switch_latte() {\n    const root = document.querySelector(\":root\");\n    document.documentElement.dataset.theme = \"latte\";\n    root.style.setProperty(\"--ctp-crust\", \"#dce0e8\");\n    root.style.setProperty(\"--ctp-mantle\", \"#e6e9ef\");\n    root.style.setProperty(\"--ctp-base\", \"#eff1f5\");\n    root.style.setProperty(\"--ctp-surface0\", \"#ccd0da\");\n    root.style.setProperty(\"--ctp-surface1\", \"#bcc0cc\");\n    root.style.setProperty(\"--ctp-surface2\", \"#acb0be\");\n    root.style.setProperty(\"--ctp-overlay0\", \"#9ca0b0\");\n    root.style.setProperty(\"--ctp-overlay1\", \"#8c8fa1\");\n    root.style.setProperty(\"--ctp-overlay2\", \"#7c7f93\");\n    root.style.setProperty(\"--ctp-subtext0\", \"#6c6f85\");\n    root.style.setProperty(\"--ctp-subtext1\", \"#5c5f77\");\n    root.style.setProperty(\"--ctp-text\", \"#4c4f69\");\n    root.style.setProperty(\"--ctp-lavender\", \"#7287fd\");\n    root.style.setProperty(\"--ctp-blue\", \"#1e66f5\");\n    root.style.setProperty(\"--ctp-sapphire\", \"#209fb5\");\n    root.style.setProperty(\"--ctp-sky\", \"#04a5e5\");\n    root.style.setProperty(\"--ctp-teal\", \"#179299\");\n    root.style.setProperty(\"--ctp-green\", \"#40a02b\");\n    root.style.setProperty(\"--ctp-yellow\", \"#df8e1d\");\n    root.style.setProperty(\"--ctp-peach\", \"#fe640b\");\n    root.style.setProperty(\"--ctp-maroon\", \"#e64553\");\n    root.style.setProperty(\"--ctp-red\", \"#d20f39\");\n    root.style.setProperty(\"--ctp-mauve\", \"#8839ef\");\n    root.style.setProperty(\"--ctp-pink\", \"#ea76cb\");\n    root.style.setProperty(\"--ctp-flamingo\", \"#dd7878\");\n    root.style.setProperty(\"--ctp-rosewater\", \"#dc8a78\");\n}\nexport function switch_mocha() {\n    const root = document.querySelector(\":root\");\n    document.documentElement.dataset.theme = \"mocha\";\n    root.style.setProperty(\"--ctp-crust\", \"#11111b\");\n    root.style.setProperty(\"--ctp-mantle\", \"#181825\");\n    root.style.setProperty(\"--ctp-base\", \"#1e1e2e\");\n    root.style.setProperty(\"--ctp-surface0\", \"#313244\");\n    root.style.setProperty(\"--ctp-surface1\", \"#45475a\");\n    root.style.setProperty(\"--ctp-surface2\", \"#585b70\");\n    root.style.setProperty(\"--ctp-overlay0\", \"#6c7086\");\n    root.style.setProperty(\"--ctp-overlay1\", \"#7f849c\");\n    root.style.setProperty(\"--ctp-overlay2\", \"#9399b2\");\n    root.style.setProperty(\"--ctp-subtext0\", \"#a6adc8\");\n    root.style.setProperty(\"--ctp-subtext1\", \"#bac2de\");\n    root.style.setProperty(\"--ctp-text\", \"#cdd6f4\");\n    root.style.setProperty(\"--ctp-lavender\", \"#b4befe\");\n    root.style.setProperty(\"--ctp-blue\", \"#89b4fa\");\n    root.style.setProperty(\"--ctp-sapphire\", \"#74c7ec\");\n    root.style.setProperty(\"--ctp-sky\", \"#89dceb\");\n    root.style.setProperty(\"--ctp-teal\", \"#94e2d5\");\n    root.style.setProperty(\"--ctp-green\", \"#a6e3a1\");\n    root.style.setProperty(\"--ctp-yellow\", \"#f9e2af\");\n    root.style.setProperty(\"--ctp-peach\", \"#fab387\");\n    root.style.setProperty(\"--ctp-maroon\", \"#eba0ac\");\n    root.style.setProperty(\"--ctp-red\", \"#f38ba8\");\n    root.style.setProperty(\"--ctp-mauve\", \"#cba6f7\");\n    root.style.setProperty(\"--ctp-pink\", \"#f5c2e7\");\n    root.style.setProperty(\"--ctp-flamingo\", \"#f2cdcd\");\n    root.style.setProperty(\"--ctp-rosewater\", \"#f5e0dc\");\n}\n"],"names":["__awaiter","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","value","step","next","e","rejected","result","done","then","apply","EPSILON","VecType$2","Float32Array","create$5","x","y","dst","undefined","fromValues$3","subtract$3","a","b","sub$3","mulScalar$3","v","k","scale$5","inverse$5","invert$4","dot$3","length$3","v0","v1","Math","sqrt","len$3","lengthSq$3","lenSq$3","distance$2","dx","dy","dist$2","distanceSq$2","distSq$2","copy$5","clone$5","multiply$5","mul$5","divide$2","div$2","vec2Impl","Object","freeze","__proto__","add","addScaled","scale","angle","ax","ay","bx","by","mag","cosine","acos","ceil","clamp","min","max","clone","copy","create","cross","z","dist","distSq","distance","distanceSq","div","divScalar","divide","dot","equals","equalsApproximately","abs","floor","fromValues","inverse","invert","len","lenSq","length","lengthSq","lerp","t","lerpV","mul","mulScalar","multiply","negate","normalize","random","PI","cos","sin","round","setDefaultType","ctor","oldType","sub","subtract","transformMat3","m","transformMat4","zero","Map","Float64Array","Array","fill","get","VecType$1","create$3","fromValues$2","subtract$2","sub$2","mulScalar$2","scale$3","inverse$3","invert$2","dot$2","length$2","v2","len$2","lengthSq$2","lenSq$2","distance$1","dz","dist$1","distanceSq$1","distSq$1","copy$3","clone$3","multiply$3","mul$3","divide$1","div$1","vec3Impl","az","bz","t1","t2","getAxis","axis","off","getScaling","xx","xy","xz","yx","yy","yz","zx","zy","zz","getTranslation","zScale","w","transformMat4Upper3x3","Deg2Rad","theta","Ray","constructor","origin","direction","this","inv_direction","RayHit","position","voxel_position","voxel","normal","Voxel","color","opacity","roughness","lightness","MetaVoxel","gi","OrbitCamera","phi","dragged","velocity","forward","right","up","eulers","update","tick","delta_time","screen_to_ray","sx","sy","horizontal_coefficient","vertical_coefficient","ray_direction","oo_oo","i","eval","oo_cm","consoleLog","canvas","document","getElementById","fps","slice_canvas","scene","grid_size","voxel_count","direct_light_phi","direct_light_theta","ao_strength","ambient_light","grid","meta_grid","boundary_min","boundary_max","voxel_size","initialize_grid","direct_light","direct_light_brightness","background_color","input_direct_light","addEventListener","parseInt","input_direct_light_phi","input_direct_light_theta","updateDirectLight","input_ao_strength","input_ambient_light","serialize_scene","JSON","stringify","deserialize_scene","s","des","parse","toString","reset","initialize_default_grid","vox","mvox","set_voxel_comp","calc_gi","ray","get_voxel_center","ray_any","get_voxel_id","tmin","tmax","Infinity","d","ray_entry","ray_exit","voxel_upper_edge","tmax_comp","tdelta","end_voxel","thit","hit_normal","get_voxel","hit_position","get_voxel_id_comp","get_voxel_comp","set_voxel","controller","mouse_down","mouse_dragged","over_canvas","last_move","selected_color","selected_roughness","selected_opacity","selected_lightness","multidraw","last_drawn","camera","performance","now","last_movement","selected_tool","blub_high","blub_low","setup","_a","_b","_c","_d","_e","_f","_g","button","shiftKey","rect","getBoundingClientRect","clientX","left","clientY","top","width","height","n_voxel","n_voxel_pos","map","val","play","r_voxel","d_voxel","movementX","movementY","mouse_drag","nvoxel","calculate_velocity","col","target","match","renderer","initialized","render","lights","push","device","queue","writeBuffer","sceneParameters","Date","getMilliseconds","light_data","lightData","scene_data","scene_meta_data","sceneData","sceneMetaData","commandEncoder","createCommandEncoder","ray_trace_pass","beginComputePass","setPipeline","ray_tracing_pipeline","setBindGroup","ray_tracing_bind_group","dispatchWorkgroups","end","textureView","context","getCurrentTexture","createView","renderPass","beginRenderPass","colorAttachments","view","clearValue","r","g","loadOp","storeOp","screen_pipeline","screen_bind_group","draw","submit","finish","pathtracing","initialize","setupDevice","createAssets","setupPipeline","set_hdr","hdr","shutdown","destroy","color_buffer","secondary_buffer","adapter","navigator","gpu","requestAdapter","requestDevice","getContext","format","err","textContent","configure","alphaMode","_h","_j","createTexture","size","usage","GPUTextureUsage","COPY_DST","STORAGE_BINDING","TEXTURE_BINDING","color_buffer_view","secondary_buffer_view","sampler","createSampler","addressModeU","addressModeV","magFilter","minFilter","mipmapFilter","maxAnisotropy","createBuffer","GPUBufferUsage","UNIFORM","scene_size","STORAGE","createBindGroupLayout","entries","binding","visibility","GPUShaderStage","COMPUTE","storageTexture","access","viewDimension","buffer","type","createBindGroup","layout","label","resource","ray_tracing_pipline_layout","createPipelineLayout","bindGroupLayouts","createComputePipeline","compute","entryPoint","module","createShaderModule","code","constants","screen_bind_group_layout","FRAGMENT","texture","screen_pipeline_layout","createRenderPipeline","vertex","screen_shader","fragment","targets","primitive","topology","cullMode","frontFace","slice_renderer","background","slice","slice_input","set_slice","console","log","set_background","set_axis","sxpv","sypv","clearRect","vox_pos","fillStyle","color_to_string","fillRect","scaled_color","last_time","camera_active","window","scrollY","innerHeight","documentElement","style","setProperty","requestAnimationFrame","elapsed","innerText","theme","btn_switch_theme","root","querySelector","dataset","switch_latte","switch_mocha","btn_rescale_canvas","rescale","scaled","innerWidth","btn_save_scene","file","Blob","createElement","href","URL","createObjectURL","download","click","revokeObjectURL","save","btn_load_scene","input","files","reader","FileReader","readAsText","content","load","btn_reset","preventDefault"],"sourceRoot":""}